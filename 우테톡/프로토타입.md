<h2 id='2.3'>📌 프로토타입 </h2>

**객체의 조작 방법을 알기전에 먼저 프로토타입이라는 개념을 알고있어야 한다.**

콘솔창에다가 아무 객체나 찍어보면 집어넣은적도 없는데 `__proto__`라는게 보인다. 이게 뭐지하고 클릭을 해보면 기묘한 것이 펼쳐진다.
이 기묘한 것들은 프로토타입과 밀접한 관련이 있다는 것을 추적할 수 있다.
프로토타입 자체는 상당히 이해하기 어려운 개념일 뿐더러 코드에 어떻게 적용해야할지 감이 오지 않을 수 있다.
프로토타입을 얕게 이해하는 대표적인 예시가 class 개념을 끌어서 이해하는 것이다.
프로토타입을 설명할때 class의 상속을 섞어서 설명하지만 프로토타입에서의 상속은 class의 상속과는 다르다.
자바스크립트에서는 클래스가 없기 때문이다.
내용을 복사에서 일어나는 상속또한 존재하지 않기 때문이다.
프로토타입은 클래스, 객체의 내용 복사없이도 상속을 구현할 수 있게 해주는 하나의 방법이다.
프로토타입은 '연결'이다.
클래스가 없다면 객체는 어떻게 객체를 설계대로 찍어낼 수 있는 것일까?

```
class Person {
	constructor(name) {
    	this.name = name;
    }

    sayHello() {
    	console.log(`${this.name}: hello!`);
    }
}
//자바스크립트에서 class는 알고보면 아래와 같은 함수이다.
function Person(name) {
	this.name = name;
    this.sayHello = function() {
    	console.log(`${this.name}: hello!`);
    }
}


```

클래스는 객체를 찍어낼 수 있는 하나의 틀이라고 볼 수 있다.
다만 함수를 활용해서 다른 언어의 클래스를 흉내낼 뿐이다.
그 흉내내는 함수에는 return이 없는데 어떻게 객체가 생성되게 되는 것일까?
함수와 new 연산자가 만나면 자바스크립트에서 숨겨진 일들이 일어나기 때문이다.

```
const student = new Person('kim');
```

new 연산자가 새로운 빈 객체를 메모리 상에 생성함
그 후에 생성된 빈 객체가 this에 바인딩 됨
그 상태에서 this 객체의 속성을 채우는 동작이 수행됨
만약에 return 하는 것이 없다면 그렇게 만들어진 this가 return 됨

복사 없이 어떻게 상속을 수행할 수 있는 것일까?

```
class Person {
	constructor(name) {
    	this.name = name;
    }

    sayHello() {
    	console.log(`${this.name}: hello!`);
    }
}

//Person + Crew 내용이 '복사'된 객체
class Crew extends Person {
	constructor(name) {
    	super(name);
    }

    doCoding() {
    	console.log(`${this.name}: coding...!`);
    }
}

```

먼저 일반적인 class에서는 하나의 클래스가 부모 클래스로 부터 상속을 받게되면 자식 클래스로 만들어진 인스턴스에는 부모와 자식 모두의 내용이 합쳐진, 부모의 내용이 자식 클래스에 그대로 복사되어 들어간 내용이 인스턴스에도 반영되게 된다.

하지만 자바스크립트에서는 이러한 기능이 불가능하다.
자바스크립트에서 상속이 만약에 복사를 의미한다면 이런 의미의 상속이 자바스크립트에서 일어날 수 없다.
왜냐하면 자바스크립트에선 객체 자체나 코드 내용을 복사하는 깊은 복사를 수행하지 않기 때문이다.
복사할 수 있는건 오로지 원시값과 객체의 참조값 뿐이다.
하지만 자바스크립트에선 이 상속을 흉내내기 위해서 객체에 연결이라는 개념을 활용한다.
이 연결은 `__proto__`라는 이름의 속성을 바탕으로 수행된다.

> `__proto__` 객체와 객체를 연결하는 링크

자바스크립트의 모든 객체들은 프로토란 속성을 가지고 있는데,
프로토 속성은 객체와 객체를 연결하는 하나의 링크라고 보면 된다.
이런 객체와 객체간의 링크관계는 크게 3가지로 분리될 수 있다.

1. 먼저 다른 객체를 바탕으로 만들어진 객체가 있는 경우

```
const newObj = Object.create(oldObj)
newObj__proto__ === oldObj
```

다른 객체를 바탕으로 만들어진 객체라면 자신의 원형이라고 할 수 있는 객체가 있다면 그 객체를 가리키는 `__proto__` 링크를 자동으로 가짐

2. 그냥 객체가 아니라 함수라면

![](https://velog.velcdn.com/images/ninto_2/post/d23cc193-b1cd-4e71-91a8-c5ce8fac4e68/image.png)

이 경우에는 프로토외에도 함수의 프로토타입 객체가 만들어진다.
그림과 같이 Person이라는 객체가 있다면 그 객체와 자동으로 연결된 prototype이라는 객체가 만들어지는 것이다.

Person함수는 자신의 prototype속성을 통해서 Person함수의 프로토타입 객체를 가리키고, Person함수의 프로토타입객체는 constructor라는 속성을 통해서 Person함수를 가르키는 이런 순환참조 관계를 가지고 있다.

3. new + 함수로 만들어진 객체라면

new연산자와 함수를 통해서 객체가 생성된 경우이다.

```
const student = new Person('kim');
```

만들어진 새로운 객체에 `__proto__` 링크가 Person객체의 Prototype을 가리키게 됨

이때 생성된 객체에 자바스크립트가 생성자 함수의 ProtoType객체를 가리키는 Proto링크를 이렇게 만들어진 객체안에 넣는다.

![](https://velog.velcdn.com/images/ninto_2/post/61c6e4ae-f7ed-42c5-9bc7-ddf1647d1469/image.png)

Person함수에 의해 Kim이라는 객체가 만들어 졌다면 Kim의 Proto링크는 Person함수의 Prototype객체를 가리키게 된다.

```
function sayHello() {
	console.log(`${this.name}: hello!`);
}

funstion Person(name) {
	this.name = name;
}
const foo = new Person('kim');
foo.sayHello();
```

위 와 같은 코드는 당연히 에러가 발생한다.
왜냐하면 foo객체는 Person함수에 의해서 만들어 졌지만 foo객체 내에는 sayHello라는 메서드가 존재하지 않기 때문이다.
하지만 prototype이라는 코드가 추가된다면 결과는 달라진다.

```
function sayHello() {
	console.log(`${this.name}: hello!`);
}

funstion Person(name) {
	this.name = name;
}
Person.prototype.sayHello = sayHello;
const foo = new Person('kim');
foo.sayHello();
```

Person함수에 프로토타입 객체에 sayHello라는 메서드를 추가했을뿐인데 foo객체에서도 이 sayHello를 실행시킬 수 있게 되었다.
왜냐하면 이 안에서는 프로토타입 체이닝이 일어났기 때문이다.

프로토타입 체이닝은 한마디로 간단히 말하자면 `__proto__`를 따라 탐색하는 과정이다.

```
const a = {
	attr1: 'moohan~',
};

const b = {
	attr2: 'mooyaho~',
}

a.__proto__ = b;
console.log(a.attr2) //'mooyaho~'
```

2개의 a와 b라는 객체가 있다고 했을때 a객체의 프로토링크를 직접적으로 b로 연결시키면 a객체에는 없는 속성이 있어도 자바스크립트는 프로토링크를 통해 b객체를 이동하고 거기에서 또 속성을 찾아보기 때문에 a속성에 없는 속성도 b속성에 있다면 자신에게 없는 속성도 사용할 수 있게 되는 것이다.

이런식으로 프로토링크를 따라서 거슬러 올라가서 탐색을 수행하는게 바로 프로토타입 체이닝이다.

```
foo.sayHello
```

이 코드는 foo라는 객체에 sayHello라는 속성이 있는지 먼저 찾아본다.
당연히 찾을 수가 없기 때문에 여기에서 멈추는 것이 아니라 foo객체안에 Proto속성을 통해서 foo객체를 생성했던 Person 함수의 ProtoType객체로 이동해서 다시 한번 더 sayHello라는 속성이 있는지 찾아본다.
이때 여기선 해당 속성을 찾아낼 수 있기 때문에 foo객체 내부에 sayHello가 있든 말든 sayHello를 실행시킬 수 있게 된 것이다.

하지만 Person ProtoType객체 안에서도 sayHello를 찾지 못한 경우라면 찾을때까지 `__proto__`링크를 거슬러 올라가고 Person이라는 함수를 생성한 생성자의 ProtoType 객체로 이동하게 되고 이런식의 탐색을 계속하게 되는 것이다. 이 연쇄는 오브젝트라는 이름의 생성자 함수 프로토타입에 도달했을때 겨우 멈춘다.
이때는 프로토링크안에 null이 있기때문에 이 이상 프로토타입 체이닝을 지속시킬수없기 때문이다.
그래서 sayHello를 찾을 수 없게되면 undefined를 반환하게 되는 것이다.

할당할 때는 어떤 일이 일어날까?
객체들이 어떻게 연결되있는지도 알아냈고 프로토타입 체이닝을 통해서 어떻게 상속이 일어나는지도 알겠는데 그렇다면 sayHello라는 메서드를 새로 할당하게되는 경우에는 어떻게 될까?

```
function sayHello() {
	console.log(`${this.name}: hello!`);
}

funstion Person(name) {
	this.name = name;
}
Person.prototype.sayHello = sayHello;
const foo = new Person('kim');
foo.sayHello = function () {
	console.log('hi~!')
};
```

foo객체에 sayHello메서드를 추가하게 될까 아니면 Person.prototype.sayHello에 덮어씌우기가 될까?
답은 경우에 따라 달라진다.
첫번째 경우는 만약 프로토타입 체이닝 과정을 거쳐서 도달한 sayHello메서드가 읽기 전용이라면 자바스크립트가 엄격모드라면 에러가 발생하지만 비엄격모드에선 아무일도 일어나지 않는다.

```
//엄격 모드 : 에러
//비엄격모드 : 아무일 없음
Object.defineProperty(Person.prototype.'sayHello'.{
	writable: false
    ...
})
```

만약 sayHello메서드가 그냥 setter라면 그냥 그 setter가 수행된다.
하지만 가장 일반적인 경우 sayHello메서드가 읽기전용이 아니라면 Person프로토타입 객체의 sayHello메서드에 무엇인가가 덮어씌워지는 것이 아니라 foo객체의 sayHello메서드가 추가되게 된다.

```
//foo.sayHello 추가
Object.defineProperty(Person.prototype.'sayHello'.{
	writable: true
    ...
})
```

```
function sayHello() {
	console.log(`${this.name}: hello!`);
}

funstion Person(name) {
	this.name = name;
}
Person.prototype.sayHello = sayHello;
const foo = new Person('kim');
foo.sayHello = function () {
	console.log('hi~!')
};
foo.sayHello();
```

하지만 이 마지막 경우에는 foo객체를 통해 Person 프로토타입의 sayHello에 접근할 수 있는 방법이 사라져 버린 것이다.
즉 foo객체에서 기존에 있던 sayHello 함수에 정상적인 방법으로는 접근 이 불가하다.
왜냐하면 foo객체안에서 해당 메서드를 찾을 수 있기 때문에 프로토타입 체이닝이 거기서 멈춰 버렸기 때문이다.
이런식으로 같은 이름의 속성을 객체안에 넣어버린 원래의 프로토타입객체의 속성에는 접근할 수 없게 되는 경우가 있는데 이를 가려짐이라고 부른다.
자바스크립트에서는 클래스 메서드 오버라이딩 대신에 가려짐이 있는 것이다.

```
Method Overriding X
가려짐 O
```

프로토타입을 실생활에서 활용한 예시를 살펴보자.

`$querySelector + hide 기능 추가`
querySelector 로 요소를 불러오는 함수에서 요소객체가 요소를 가릴수 있는 메서드를 포함하도록 만들고 싶다고 가정해보자.

```
//하나의 메서드를 여러 곳에서 재활용
function hide() {
	this.element.classList.add('invisible');
}

function $2(selector, target = document) {
	const all = target.querySelectorAll(selector);
    this.element = all.length > 1 ? [...all] : all[0];
}

$2.prototype.hide = hide;

const button1 = new $2('#button-2');
button1.hide();
```

이 코드에서 $2를 실행시키게 되면 그렇게 해서 만들어진 객체들은 hide라는 함수 하나만을 사용하게 된다. 그렇기 때문에 하나의 메서드를 여러곳에서 재활용 할 수 있기 때문에 메모리 측면에서 더 효율적이라고 볼 수 있게 된다.
