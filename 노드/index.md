## 이해하고 갈 개념들

![](https://velog.velcdn.com/images/ninto_2/post/f45f0076-bfe4-468c-bce3-9ff4bf238fb9/image.png)

- 자바스크립트 이벤트 버블링과 캡처링 개념이해
- 적어도 딥다이브 한 권 완독
- 노드 프로미스, 자바스크립트 프로미스 이해
- 블로킹, 논 블로킹, 동기 , 비동기 이해
- V8 엔진에서 비동기 처리가 어떻게 되는지 이해
- 여기서 나온게 이벤트루프인데 노드랑 브라우저에서의 차이점
- async, await은 왜 등장했을까?
- setTiemout과 setimediate의 차이점
- 모듈의 브라우저와 노드환경에서 차이점

<br>

---

### 동기, 비동기 & 블로킹, 논블로킹

위 개념 모두 이해하려면 첫단계가 바로 동기,비동기 & 블로킹,논블로킹의 개념을 이해하는 것이다.

동기,비동기 & 블로킹,논블로킹은 비슷해보이지만 차이점이 존재한다.

> 동기와 비동기의 차이점은 결과값을 바로 **다음 실행컨텍스트에서 보장받을 수 있냐 없냐**는 문제이다.

`동기는 결과값이 밑에서 바로 보장가능, 비동기는 보장 안됨`

- **동기**: 결과값을 받아서 그 받은 결과값을 가지고 바로 어떤 작업을 수행 해야할때 보장을 받을 수 있는 경우를 동기식이다라고 표현한다.

- **비동기**: **결과값을 다음 실행컨텍스트에서 보장받을 수 없는 경우**

> 블로킹과 논블로킹은 **실행의 제어권을 유지하느냐 아니면 잃어버리냐**를 의미한다. (코드가 멈추냐, 안멈추냐의 개념)

`블로킹은 코드가 멈춤, 논블로킹은 유지`

- 블로킹: 실행 제어권을 잃어버리고 코드가 멈춘다.
- 논블로킹: 실행 제어권을 잃지않고 유지한다.

<br>

---

### 비동기가 발생하는 이유

그렇다면 어떤경우에 보장권이 생기지 않는지 알아보자.
동기와 비동기 개념은 자바스크립트뿐만이 아니라 CS같은 컴퓨터 공학에서도 이야기가 나온다.

![](https://velog.velcdn.com/images/ninto_2/post/d14fa7c8-d5c9-4b05-bc16-d6683b2b023b/image.png)

이 둘을 구분하는 엄청나게 다양한 방식이 있는데 그 중 대표적인게 바로 멀티쓰레드 방식이다.

- 멀티쓰레드: 하나의 프로세스 안에 쓰레드 여러개를 띄워서 일을 나눠 분산시킴 (빛의 속도로 실행되서 마치 동시에 진행되는 것 처럼 보임)

만약 아래와 같이 특정 파일을 호출하는 코드가 있다고 가정해보자.

```js
const a = readFile();
console.log(a);
```

어떤 파일 읽어오기(readFile 실행!) -일떠넘기기> 파일읽는작업함
그리고 나서 다른일함  
파일 다 읽어졌을때 갖다줌

const a 받음
받는데 시간걸려서 콘솔 안찍힘
밑에서 console.log(a) //undefined

이런 상황 발생할 수 있음 바로 밑에서 보장받을 수 없었음.. 비동기작업

만약에 어떤 쓰레드가 하나 있는데
const a = '123123';
console.log();
다음 실행컨텍스트에서 이전 실행컨텍스트의 값을 바로 보장받을 수 있는 상황
동기식 작업!

근데 자바스크립트에선 멀티쓰레드가 아님
어떻게 되어 있냐면 자바스크립트는 실제로
메인 실행컨텍스트가 있고, 옆에 이벤트루프라는게 있음
이벤트루프 이녀석을 잘 이해해야함

메인실행컨텍스트 실행하다가 다 됐음 이벤트루프에 가서 돌아가고있는 작업이 있는지 확인함
다 되면 다시 메인으로 돌아옴 순환순환

//메인실행컨텍스트
const a = readFile() // 파일좀 읽어와라 이벤트루프야
// 이벤트루프에 넣어놓기만 했지 안받았음
console.log(a) // 파일 안나옴 - 비동기 작업

어떻게 해야 얘를 결과를 찍을 수 있을까?

- 블로킹 멈추는거
- 논블로킹 안멈춤

메인실행컨텍스트에서 안멈춤
a를 바로 보장받으려면 어떻게 할까?
받아올때까지 기다려야됨

자바스크립트에서 고전적인 방법에선
바로 콜백을 사용했음

메인실행컨텍스트에서 쭉 코드가 실행됨
코드 실행하면서 이벤트루프한테 일 떠넘길수있음
이벤트루프가 있음

아니면 위에다 a = null
const a = readFile('파일경로' , 콜백함수 던져줌
여기서 파일 읽었으면 console.log(파일) 해라
a = f

)
console.log(a);

처음 a는 null이였는데 파일 읽어라하고 이벤트루프한테 일 하나줌
실행했다 파일 읽었다 함 (파일을 가져오는 작업이 동시성!처리(왔다갔다해서 동시처럼 보이는거))
파일읽어라하면서 콜백함수를 같이 던져줬음
그럼 이벤트루프에 콜백함수가 받음
파일이 다 읽혀서 넘기고 실행됨
파일 다 읽었어요 라는 말이 없었음
외부 콘솔 여기서도 a는 null 나옴 - 논블로킹됨

콜백안에 있는 콘솔은 다 읽었다! 할때 실행됨
내부 콘솔에선 파일 나옴

함수 실행완료되면 보장받아서 콜백안은 동기적인 영역인거임
옛날엔 콜백으로 사용했음

```js
get('/step1', a => {
  get(`/step2/${a}` b => {
    get(`/step3/${b}` c => {
      .
      .
      .
      .
      .

    })
  })
})
```

첫번째 콜백으로 가진 a가지고 또 요청함
또 a가지고 b 또 요청함
또 요청함

이전 요청의 값을 가지고 다음 요청을 순차적으로 처리해야함
이전 요청값이 다음 요청
동기적으로 작업을 처리해야하는 상황
결과값을 다음에 꼭 보장받아야한다.

get이라는 비동기요청을 동기적으로 처리해야하는 상황

비동기작업은 떠넘기는 작업이다.
떠넘기기 때문에 결과값을 바로 보장받을 수 가 없다.

비동기 작업을 동기적으로 처리해야하는 경우
뎁스가 계속 늘어나서 더러움

이런 더러운 문제를 콜백지옥이라함
떠넘기는 작업을 동기적으로 처리해야할때....
첫번째 받은 결과를 받고 꼭 두번째 작업을 처리해야할때..
콜백 안에서 처리
결과 보장받으려면 콜백안에서 처리해야되니까
뎁스가 늘어날수밖에없는 콜백지옥이 생김

심각한 문제가 또 있음

콜백같은 경우는 에러처리가 까다로움
이건 매우 심각한 문제임

try하면 에러가 catch되야 하는데
셋타임아웃해서 몇초뒤에
1초가 지난 시점에 얘를 실행한다. 딱 1초가 아니라 1초가 지난시점 1.000005초 일수도잇음
이걸 보장할 수 없는 이유는 이벤트루프

![](https://velog.velcdn.com/images/ninto_2/post/31148468-590d-4b53-9359-581b8bf4a467/image.png)

1초가 되는 순간 실행되는게 아니라 1초가 지나고나서 거의 1초쯤에 실행됨
ms 단위는 1000분의 1초다

이벤트루프는 사실 몇개의 단계(페이즈)로 이루어져있다.

```js
setimmendiage(() => {
  console.log("즉시실행");
});
// 랜덤으로 찍히는데 왜일까?

//setTimeout 0은 사실 0.0000001초짜리가 등록된거
//결국 1ms
//체크포인트가 랜덤임
setTimeout(() => {
  console.log("타임아웃 0");
}, 0);
```

```js
try {
  setTimeout(() => {
    throw new Error("Error!");
  }, 1000);
} catch (e) {
  console.err("캐치한 에러", e);
}
```

에러가 안됨....
콜백안에잇는 애로는 밖에서 에러가 캐치가 안됨
왜 안될까?

(실행컨텍스트 이벤트루프) 얘가 하나의 쓰레드임 (왔다갔다함)
동시에 돌아가는것처럼 보임
멀티쓰레드는 동시에 실행됨 쭉쭉

실행컨텍스트가 try catch로 묶여있음
이벤트루프에 타이머를 보냈음
1초쯤 지나면 error가 나는데 이벤트루프안에서 남
그래서 실행컨텍스트에선 에러가 안잡힘
실행되는 환경 자체가 다름

콜백을 호출시킨것은 셋타임아웃 함수가 아니다.
이벤트루프는 몇가지의 단계로 되어있음

> 이벤트루프안에서 콜백이 어떻게 실행되는지 찾아보자. - 심화과정 숙제임

콜백의 단점 보완하려고 나온게 프로미스임
프로미스는 비동기작업 비동기처리 , 떠넘기는 작업의 상태와 결과값을 갖는 객체임
프로미스의 접근자타고 올라가면 오브젝트 접근자 나옴
결국에 얘도 오브젝트였음

상태: 떠넘긴 작업이 진행중인지, 이행중인지, 에러났는지 (3가지 상태를 가지고 있음)
떠넘긴 작업의 결과값을 가짐

프로미스 까보면 status랑 result 들어있음

비동기작업이 성공인지 실패인지 누군가는 넣어줘야하는데
그게 바로 resolve랑 reject임
프로미스가 완료인지 종료인지 누군가는 넣줘야함
resolve , reject

작업다됐네 하면 resolve -> 풀필드 이행되었다. 로 바뀜
result 에는 그 값이 들어감

실패했다하면 reject -> 에러가 들어가서 result에 error 담겨잇음
status가 rejected 거절됐다로 바뀜

프로미스는 처음 생성할때 기본적인 pending 상태이다. 대기중인 상태
프로미스 내부에선 떠넘겨진 작업 처리하려고 매개변수로 resolve랑 reject 두개의 콜백을 받는다

그래서 new Promise로 선언하고 콜백넘겨주면 안에서 처리해라 하는거임

```js
const myPromise = new Promise((resolve, reject) => {
	//<----------------------------------------------- 비동기 작업 요청 부분
	if (비동기 처리 성공) {
		resolve(비동기 처리의 결과 값)
	} else {
		// 비동기 처리의 실패
		reject(실패 처리로 넘길 값)
	}
})



myPromise 	//<------------------------------------ 비동기 작업의 결과 처리 부분
	.then(data => { console.log(data); })
	.catch(e => { console.error(e); })
```

프로미스 인스턴스 하나 만들었음 프로미스 객체라서 new로 생성할 수 있음
만약에 비동기처리에서 성공/실패했음 그 자리에 바꿔주는 거임

왜 감쌀까?
그냥 비동기처리 콜백쓰면 되는데
바로 프로미스를 가지고 한번 감싸면 아래코드처럼 쓸수있음 (then , catch)이런거 지원받음
then - resolve 로 성공했을때 안에서 처리한 결과가 then으로 실행됨
then은 1분, 2분, 30분 언젠가는 실행될때 그때 이렇게 실행된다.

![](https://velog.velcdn.com/images/ninto_2/post/8cbcfd72-dcda-49f1-af85-35bb3cedd58f/image.png)

이건 자바스크립트의 기기기기기기기ㅣ기기기초이다...

비동기적으로 실행되는 setTimeout을 콜백으로도 써보고, 프로미스로도 감싸서 써보고 해보자.

- 장단점 비교하기- 우리의 목표

```js
console.log("시작!");
setTimeout(() => {
  console.log("2초지남!");
}, 2000);
console.log("종료!");
```

1. 시작이 찍힘
2. 종료가 찍힘
3. 2초 지남 찍힘

머리속에 그려지는 이벤트 루프.....
블로킹 되지 않았음
2초지남은 비동기적으로 처리됐음

빵사와! -> 2초동안 빵사러감 -> 2초 걸려서 빵다삼 -> 3초동안 우유사러감 -> 3초 걸려서 우유도 사옴 을 콜백으로 구현해보자

```js
console.log("빵사와!");
setTimeout(() => {
  console.log("2초지남! 빵 사옴");
}, 2000); //콜백뒤에다가 초써야됨
setTimeout(() => {
  console.log("3초지남! 우유 사옴"); //비동기적으로 동시에 일어나는것처럼 보인다..
}, 3000);
```

1. 처음에 콘솔실행됨 바로 찍힘 빵
2. 2초 하면 작업떠넘기 2초뒤에 실행되는 폭탄 떠넘김
3. 3초 뒤에 터지는 폭탄도 떠넘김 (얘 1초만에 실행됨)

```js
console.log("빵사와!");
setTimeout(() => {
  console.log("2초지남! 빵 사옴"); //2초지나서 나옴
  setTimeout(() => {
    console.log("3초지남! 우유 사옴"); //2초지나고 3초지나서 나옴
  }, 3000);
}, 2000);
```

실행컨텍스트안에 콜스택이라는 것도 있어서 여기서 작업이 하나하나 일어남

2초짜리 폭탄을 던짐
2초짜리 터지면 콘솔에 찍힘
터지고나서 또 이벤트루프에 3초짜리 폭탄이 또 등록됨
2초 -> 3초
그제서야 우유사옴 나옴

다 사왓는데 또 5초안에 목사탕도 사오라함

```js
console.log("빵사와!");
setTimeout(() => {
  console.log("2초지남! 빵 사옴"); //2초지나서 나옴
  setTimeout(() => {
    console.log("3초지남! 우유 사옴"); //2초지나고 3초지나서 나옴
    setTimeout(() => {
      console.log("5초지남! 여기 목사탕..."); //2초지나고 3초지나서 나옴
    }, 5000);
  }, 3000);
}, 2000);
```

setTimeout이라는건 비동기작업인데 이 비동기 작업을 지금 동기적으로 실행하고 있음
빵이 있어야 우유를 사오고 우유가 있어야 목사탕도 사오고..

동기적으로 수행하는 상황에서 위와 같이 콜백지옥이 생기게 됨!

그래서 프로미스가 등장함

```js
// 이렇게 쓰면 안된다는 예시임
const setTimeoutPromise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log("2초 지남 빵 ...");
    resolve();
  }, 2000); // 프로미스가 생기면 그때 얘가 실행됨 - 동시에 폭탄 3개생김
});

const setTimeoutPromise3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log("3초 지남 우유 ...");
    resolve();
  }, 3000);
});

const setTimeoutPromise5 = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log("5초 지남 목사탕 ...");
    resolve();
  }, 5000);
});

setTimeoutPromise2.then(() => {
  setTimeoutPromise3.then(() => {
    setTimeoutPromise5.then(() => {});
  });
});
```

이 방식은 앞에 콜백지옥이랑 별반 차이가 없다.
코드가 안깔끔함

![](https://velog.velcdn.com/images/ninto_2/post/3708b8e2-a377-418e-bed6-23d30bcbe076/image.png)

```js
//프로미스를 리턴하는 함수를 만들어서 써야됨
//이런 함수가 있습니다.
const setTimeoutPromise2 = (ms) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
};

//여기왔을때 폭탄이 생김
//then은 2초지나서 터질때 then으로 들어감
setTimeoutPromise2(2000).then(() => {
  console.log("2초 지남 빵 ...");
  setTimeoutPromise2(3000).then(() => {
    console.log("3초 지남 우유 ...");
    setTimeoutPromise2(5000).then(() => {
      console.log("5초 지남 빵 ...");
    });
  });
});
```

setTimeoutPromise 함수는 프로미스를 리턴한다.
then함수도 사실 프로미스를 리턴함 -> then() 이거 자체가 resolved 된 프로미스임
그래서 그뒤에도 then().then()할 수 잇음
왜냐면 프로미스니까 fulfiled된 프로미스

`then().then().then().then()` 이런걸 프로미스 체이닝 이라고함

그런데 우리는 2초뒤 -> 3초뒤 -> 5초뒤 이렇게 새로운 비동기 작업을 실행해야 하므로 아래와 같이 작성해줄수 있다.

위 코드를 어떻게 바꿀 수 있을까

```js
const setTimeoutPromise2 = (ms) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
};

// 프로미스 체이닝을 사용하니까 콜백뎁스가 해결되었다!
// 깔끔 편안
setTimeoutPromise(2000)
  .then(() => {
    console.log("2초 지남 빵 ...");
    return setTimeoutPromise(3000);
  })
  .then(() => {
    console.log("3초 지남 우유 ...");
    return setTimeoutPromise(5000);
  })
  .then(() => {
    console.log("5초 지남 목사탕 ...");
  });
```

이런데 자바스크립트 개발자들이 이것도 꼴보기 싫다고 생각을 했음
(아니 왜 도대체 비동기작업을 저렇게 동기처럼 쓰는거야...)

사실 위코드처럼 써도 상관없는데 여기서 파가 나뉨
프로미스체이닝을 좋아하는 파랑 이것도 꼴보기 싫다는 파랑 나뉨

이것도 꼴보기 싫어파 vs 프로미스 체이닝 좋아하는 파

이꼴파가 내세울만한게 바로 async await임
얜 언제쓰냐면 프로미스를 동기적으로 코드를 작성하고 싶을때 사용함
프로미스는 비동기특성을 가졌음
위 코드 12줄을 6줄로 줄일 수 있음

- async: 함수 앞에다 붙여줌, 그 함수안 공간(함수내 지역 스코프)에서 await을 쓸 수 있게됨

- await: 프로미스 앞에 붙여줌! -> await 뒤에는 항상 프로미스가 와야함

프로미스: 비동기적인 작업을 처리하는데 주로 쓰이고, 작업의 상태와 결과값을 가진 객체입니다. 프로미스는 풀필드, 리젝티드, 펜딩 3가지의 상태를 가지고 프로미스를 생성할때는 콜백으로 리졸브랑 리젝트를 갖습니다.

콜백쓰기 싫을때 프로미스로 감싸서 사용하면된다

어싱크 어웨잇은 비동기적으로 써야 하는 상황에서는 사용하면 안됨

2시간 걸리는 작업인데 2시간 동안 계속 로딩돌고있으면 안됨
신청하면 난 2시간동안 놀고 2시간뒤에 신청받아야됨

만약 어떤 상품을 샀는데 상품 산 결과가 바로 반영되야되는데
동기적으로 일어남

어싱크 어웨잇은 동기적인 상황에서만 써야됨
빵, 우유, 목사탕 동시에 사러가는게 훨씬 좋음 (비동기적으로 써야됨)
이땐 어싱크 어웨잇 안쓴다. (동기적으로 처리해야되는 상황에서만 써야된다.)

이거 모르면 프로미슨데 왜 어싱크 어웨잇 안붙였냐고 물어봄
이건 잘못된 생각임

await 뒤에는 항상 프로미스가 와야하지만 그렇다고 해서 프로미스 앞에 항상 await이 와야한다는 것은 아니다! (주의)

왜냐면 동기적인 상황에서만 붙이니까

프로미스는 함수 스코프 안에서 동작한다고 했으니까 함수를 하나 만들어주자

```js
const main = async () => {
  await setTimeoutPromise(2000);
  console.log("2초뒤 빵사옴");

  await setTimeoutPromise(3000);
  console.log("3초뒤 우유사옴");

  await setTimeoutPromise(5000);
  console.log("5초뒤 목사탕사옴");
};
main();
```

![](https://velog.velcdn.com/images/ninto_2/post/51c17279-1e03-48a4-a94e-7b2f318fbfa3/image.png)

자바스크립트 기기기기기초 어떻게 작동하는지 분석해보자

async세상이라 await 쓸 수 있고
2초 폭탄 받음 이 프로미스 앞에 await있음
그러면 코드가 블로킹됨 여기서
await 붙였더니 블로킹 2초동안 기다려짐
... 5초까지

코드 실행제어권이 쭉 실행되야하는데 가다가 갑자기 이벤트루프에서
2초있다가 다시 실행되고 가다가 다시 이벤트루프에서 3초 ..
가다가 5초.. 이렇게 실행
실행의 제어권이 이벤트 루프쪽으로 넘어감 <- 이걸 블로킹 이라함
await을 걸면 이렇게 넘어간다.

지금은 이렇게 코드가 블로킹된다 여기까지만 알아도 본전임

그런데 await이 블로킹 되지않는다고 말하는 사람도 많음
논블로킹과 비동기
await의 동작은 엄연히 블로킹이 아닌가 라는 의문이 들었다.
사람들 마다 의견이 다분했다.
반드시 프로미스를 받아야하기때문에 프로미스 반환값을 기다리는 함수로 생각할 수 있다.
하지만 실제로 내부코드들의 실행을 멈추지 않는다.
await이 블로킹일까?

await은 사실 블로킹이 아니다. <- 결론
(메인쓰레드를 멈추냐 물어볼땐 no임)
(혼란을 일으키긴하지만 실제로 기존 쓰레드를 차단하진 않는다.)

퀴즈: await은 진짜 블로킹일까?

블로킹 - 실행이 멈춤!

실행이 멈출까를 알아보자

```js
const setTimeoutPromise2 = (ms) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
};

const server = async () => {
  console.log("요청받음!");
  await setTimeoutPromise2(10000); //10초
  console.log("10초 지남! 응답 여깄어여!");
};
server();
```

![](https://velog.velcdn.com/images/ninto_2/post/c931919b-baf1-418b-95a1-9c090085b48d/image.png)

노드js는 무조건 논블로킹인데 블로킹된것처럼 보이는거임
블로킹이냐 논블로킹이냐는 생각하기 나름인것임

전체적으로 생각하면 논블로킹이지만 지역적으로 보면 블로킹인거
자바스크립트가 await을 만나면 await 밑에 있는 부분들을 다 이벤트 루프로 보내버림(콜백으로)
그럼 await보내고 밑에 있는 코드를 다 10초뒤에 실행해라 이런 느낌인거임

awiait을 만나면 이벤트루프한테 일을 떠넘겼고, 시스템이 멈춘게 아니였음
계속 일을 떠넘기는 일을 하고 있는거였음 그래서 논블로킹이다라고 얘기하는거였음

이벤트루프 딜레이

```js
//예제1
setTimeout(() => {
  console.log("1초 지남");
}, 1000);

let a = 0;
//대략 5초짜리 for문
for (let i = 0; i < 10000000000; i++) {
  a++;
}
//for문 끝남이 끝나야 1초 지남이 출력됨
console.log("for문 끝남!:", a);
```

왜 이런걸까? (브라우저도 그러는지 모르겠는데)
노드js는 싱글 쓰레드라서 그럼
싱글 쓰레드: 일꾼이 한명
일꾼이 일을 하는 길이 for문에서 사로잡혀버렸음 빠져서 루트따라 아래까지갔는데 이벤트루프 갈틈이 없어짐
왜? 일꾼이 한명이라서

이런걸 이벤트 루프 지연현상이라 하고, 노드 js는 싱글쓰레드라 그럼
for무한루프같이 CPU를 이 쓰레드혼자 다 쓰고 있는거임
이걸 CPU 바운드작업이라 함 (블랙홀 비유) -> 이벤트루프가 그만큼 실행이 안될 수 도 있다.
그래서 이걸 항상 유념하고, CPU 바운드 작업을 피해야 한다.

```js
//예제2
const setTimeoutPromise = (ms) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
};

const main = async () => {
  setTimeoutPromise(1000).then(() => {
    console.log("1초 지남!");
  }); //1초 뒤 작업 예약

  console.log("안녕");

  await setTimeoutPromise(10000);
  console.log("10초 지남!");
};

main();
```

왜 이때는 이벤트 루프 딜레이가 안일어나는지 연구해와야됨...
