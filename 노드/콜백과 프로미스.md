보통 콜백을 쓰는 상황은 비동기 혹은 non-blocking로 작동하기 때문임

- non-blocking:
  - 요청한 작업을 즉시 마칠수 없다면 즉시 return함
  - 일반적으로 즉시 return하지않음(일을 못하게 막음)
  - 하나의 쓰레드가 여러개의 I/O를 처리 가능

```js
//전형적인 콜백 코드의 구성
Users.findOne("kim", (err, user) => {
  if (error) {
    return console.error(error);
  }
  console.log(user);
});
//콜백안에있는 콘솔보다 외부에 있는 콘솔이 더 먼저 뜸
console.log("다 찾았나요?");
```

데이터베이스에 유저라는 테이블이 있고 거기서 한사람을 찾아오는 상황
만약 한사람을 찾았을때 뒤에 넣은 콜백이 실행됨

보통은 데이터베이스에 가서 네트워크에 해당 쿼리를 날리는데
이런 과정이 시간을 상당히 소요함 (시간이 얼마나 걸릴지 모름)

non-blocking 방식으로 먼저 요청만 보내놓고 외부에있는 다음코드를 실행함
그 다음 데이터베이스가 findOne kim 찾았으면 다시 이벤트루프로 콜백을 넣어줘서 콜백안에 있는 부분이 실행되게 됨

만약 찾는 과정에서 에러가 있었다면 if문이 실행되고,
만약 정상적으로 찾았다면 콘솔user가 실행된다.
위 과정이 흔히보던 콜백의 모습이라고 할 수 있다.

하지만, 순서가 애매하다는 단점이 존재한다.
콜백같은 경우는 코드를 열심히 써도 실행순서 파악이 어려워서 순서를 어떻게 잡아야하는지 힘든 경우가 종종 있다.
특히 콜백이 연달아 이어지는 경우

```js
// 콜백 지옥의 시작 (점점 깊어짐)
Users.findOne("kim", (err, user) => {
  if (error) {
    return console.error(error);
  }
  console.log(user);
  //콜백안에 또 다른 콜백이 존재하는 경우
  Users.update("kim", "lee", (err, updatedUser) => {
    console.log(updatedUser);
    //또 콜백안에 들어가서 써야됨
    Users.remove("lee", (err, removedUser) => {
      console.log(removedUser);
    });
  });
});
console.log("다 찾았나요?");
```

비동기라서 한번 비동기로 들어가게 되면 그 다음부터는 모든 코드를 이 콜백안에 써야됨
계속 들어가다보면 끝없이 들어가는 구조를 쓸 수 밖에 없음 (콜백 헬)
만약 이런 코드를 직장에서 사수가 보게된다면 다시 공부해오라고 혼날 가능성이 매우 높음

그렇다면 이 콜백헬을 어떻게 극복하면 좋을까?
하지만 옛날 문법으로는 한계가 있었다.
옛날에는 콜백지옥을 없애기 위해서 콜백을 변수로 빼서 사용하는 방법을 주로 택했다.

```js
//콜백 변수로 빼기
//하지만 한눈에 흐름을 파악하기 쉽지 않음
const afterRemove = (err, removedUser) => {
  console.log(removedUser);
};

const afterUpdate = (err, updatedUser) => {
  console.log(updatedUser);
  User.remove("lee", afterRemove);
};

Users.findOne("kim", (err, user) => {
  if (error) {
    return console.error(error);
  }
  console.log(user);
  Users.update("kim", "lee", afterUpdate); //코드 또 찾으러 올라가야됨(코드가 역순이 되버리고 가독성이 안좋아짐)
});
console.log("다 찾았나요?");
```

ES2015에서 다른 언어에서 따온 좋은 문법이 등장함 (그게 바로 프로미스)
프로미스가 나온 이후로 자바스크립트랑 노드.js의 비동기가 완전 차원이 달라졌다.
그동안 프로미스 구현하려고 블루버드같은 라이브러리를 쓰고 그랬는데
제이쿼리도 가짜 프로미스라고 프로미스 비슷하게 흉내내던 것임
ES2015에선 정식으로 자바스크립트 스펙에 프로미스가 들어왔기때문에 다른 라이브러리 사용없이 구현이 가능해졌음

프로미스를 적용해보면 콜백지옥도 깔끔하게 바뀔 수 있다.

```js
//레거시 콜백지옥 코드 프로미스로 바꾸기
Users.findOne("kim")
  .then((user) => {
    console.log(user);
    return Users.update("kim", "lee");
  })
  .then((updatedUser) => {
    console.log(updaedUser);
    return Users.remove("lee");
  })
  .then((removedUser) => {
    console.log(removedUser);
  })
  .catch((err) => {
    console.error(err); //에러처리하는건 마지막에 한번에
  });
console.log("다 찾았나요?");
```

콜백헬 코드와 비교해서 깊이가 깊어지지도 않고, 항상 최대 2뎁스를 유지하는 깔끔한 코드 작성이 가능해짐
비동기 하나가 실행되면 그 다음 비동기로 아래로 순차적으로 흐름이 내려가고 있음.
이래서 프로미스가 처음 나왔을때 엄청난 인기를 끌었음
