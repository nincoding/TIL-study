## DOM이란?

자바스크립트의 탄생 배경
자바스크립트는 Web 문서를 제어하기 위해 개발된 언어이다.
정적인 web에서 요소의 content를 변경한다거나, 추가하거나 제거하는 등
HTML문서를 조작하기 위해 만들어졌다.

HTML파일을 자바스크립트 제어할 수 있는 원리는 무엇일까?
브라우저안에는 웹 문서를 해석할 수 있는 랜더링 엔진이 존재한다.
브라우저에서 HTML파일을 열게되면 랜더링 엔진이 한 줄 한 줄 해석한다.
그리고 해석이 끝나면 HTML문서를 객체화하여 자바스크립트로 접근할 수 있도록 한다.

문서를 객체화 하였다고 해서 **문서 객체 모델 (Document Object Model) DOM** 이라고 표현한다.
Script언어로 HTML요소를 제어할 수 있도록 웹 문서를 객체화 한 것을 말한다.

![](https://velog.velcdn.com/images/ninto_2/post/df00501c-6cbc-4f8f-be0c-2e5229e2d8fd/image.png)

이 DOM은 Tree구조를 가지고 있다.
HTML문서를 자세히 살펴보면, 안에 head태그와 body태그를 가지고 있다.
또, body태그 안에는 h1, p, div, ul, li 등의 다양한 태그들이 들어갈 수 있다.

이렇듯 HTML요소는 하나의 부모 태그와 n개의 자식 태그를 가질 수 있다. (DOM트리 형태)
위 그림에서 각각의 요소를 노드라고 한다.
각각의 요소인 노드에 접근해서 웹 문서를 조작할 수 있게 된다. (1.접근 2.제어)

Web문서를 객체화한 것을 DOM이라고 했다면, 브라우저 자체를 제어할 수 있도록 모델링 한 것을
Browser Object Model(브라우저 객체 모델)이라고 한다.
또, CSS를 자바스크립트로 조작할 수 있도록 한 것은 CSS Object Model (CSSOM)이다.

BOM에는 브라우저 영역을 제어할 수 있도록 제공하는 `document` 객체가 있다.
`document` 객체는 DOM Tree의 최상위에 위치하며 최상위 노드이다.
즉, 이 `document` 최상위 노드로 먼저 접근하여 원하는 요소에 접근이 가능해진다. (DOM 요소에 접근하기 위한 진입점)

**노드에 접근**

```js
// HTML 브라우저 콘솔창에
document.getRootNode(); // document - 최상위 노드를 반환
document.childNodes; // [<!DOCTYPE html>, html] 그 다음 하위 노드를 반환
document.childNodes[1]; // html로 접근
document.childNodes[1].childNodes[2]; // body - 이런식으로 연속적으로 childNodes를 이용해서 접근이 가능하다.
document.childNodes[1].childNodes[2].childNodes[1].textContent = "제목"; // h1 - textContent로 수정 가능
```

`document` 객체의 위와 같은 방식으로 DOM객체에 접근해서 DOM객체에서 지원하는 `textContent`와 같은 프로퍼티로 제어가 가능하다.

하지만 위 방식보다 더 쉽게 접근할 수 있는 코드가 있다.

```js
let domObj = document.querySelector("h1"); //querySelector괄호안에 접근하고 싶은 노드요소를 입력합니다.

domObj.textContent = "변경";
```

이렇듯, DOM은 문서 객체 모델로 브라우저에서 자바스크립트 요소로 html요소를 제어할 수 있도록,
제공하는 API이다.

이 API는 자바스크립트 언어 자체가 아니다. (브라우저에서 제공하는 기능같은 것)

<br>

---

## BOM이란?

Browser Object Model(브라우저 객체 모델)이란 것은 말 그대로 Web 브라우저를 객체화 한 것을 의미한다.
객체화를 한 이유는 브라우저 언어를 Script로 제어하기 위해서 이다.
우리가 마우스라는 H/W 인터페이스를 통해서 브라우저의 새 탭을 열 수 도, 주소창에 특정 주소를 입력함으로써 Web 문서를 이동할 수 도 있다.
이렇듯, 마우스로 브라우저의 기능을 이용했던 것 처럼 이 브라우저를 객체화 함으로써 자바스크립트로도 제어가 가능한 것이다.

즉, BOM을 브라우저를 제어하기 위한 인터페이스 라고도 말한다.

그렇다면 브라우저 객체에는 어떤 것들이 있고, 기능은 무엇일까?

**Brower 객체**

- `window` : 모든 객체가 소속된 객체이며, 브라우저 창 자체를 의미합니다.
- `document` : 현재 문서에 대한 정보를 가지고 있는 객체입니다.
- `history` : 현재의 브라우저가 접근했던 URL history를 제어할 수 있습니다.
- `location` : 문서의 주소와 관련된 객체, window 객체의 프로퍼티인 동시에 document의 프로퍼티이다.
  이 객체를 이용하여 윈도우의 문서 URL을 변경할 수 있고, 문서의 위치와 관련해서 다양한 정보를 얻을 수 있다.
- `screen` : 사용자의 디스플레이 화면에 대한 다양한 정보를 갖고 있는 객체이다.
- `navigator` : 실행중인 애플리케이션(브라우저)에 대한 정보를 알 수 있다.
  (크로스 브라우징 이슈를 해결할 때 사용가능하다. ex. Chrome -> addEventListener, IE -> attachEvent)
  - `navigator.geolocation.getCurrentPosition()` : 현재 애플리케이션에 대한 위치 정보
    (`navigator`에 `geolocation`라는 멤버변수에 `getCurrentPosition()`메서드를 통해 현재 위치정보를 가져올 수 있다.)
  - `navigator.appName` : 앱(브라우저) 이름을 반환한다.
  - `navigator.appVersion` : 앱(브라우저)에 대한 버전 정보를 반환한다.
  - `navigator.userAgent` : 서버에 요청할 때 앱(브라우저)에 대한 정보이다.

브라우저 객체에는 위 와 같은 객체들이 존재한다.

```js
// 만약 브라우저창에서 새 탭을 열고 싶다면 콘솔창에
window.open("홈페이지 주소"); // 해당 주소의 새 탭이 open됨. open('주소') === window.open()
window.close(); // 탭이 닫힘
alert("경고창"); // alert은 window가 가지고 있는 메서드이다. alert() === window.alert()
```

window의 특징으로는 모든 객체가 소속된 객체이지만, 앞에 window 생략이 가능하다.
HTML Web문서는 브라우저에 의해 해석되면서 DOM트리로 변환되고, `document`는 이러한 정보를 가지고 있다.
그래서 `document`객체에서 제공하는 메서드로 다양한 DOM요소를 가져올 수 있다.

```js
document.querySelector("#custom-id"); //괄호안에 해당 태그의 CSS 선택자를 넣으면 해당 태그를 가져옴
document.querySelector("#custom-id").textContent = "원하는 텍스트 변경";

document === window.document; // window는 생략 가능하므로 타이핑 줄이기 위해 대체로 생략함
```

이 `document`객체도 객체기 때문에 `window` 객체에 소속된 객체이다.

`history`기능은 브라우저 상에 보이는 '뒤로가기', '앞으로 가기' 기능이라고 생각해도 좋다.
만약 뒤로가기 기능을 `history`객체를 통해 표현하고 싶다면,

```js
history.back(); // 뒤로가짐
history.forward(); //앞으로가짐
```

`location`은 window 객체의 프로퍼티인 동시에 document의 프로퍼티 이므로 `location`으로 바로 사용할 수 있지만,
`window.location`, `document.location`으로도 사용이 가능하다. (= 같은 의미를 가진다.)

```js
// Web 브라우저 console창에 아래의 코드를 입력하면
location.host; // 'www.naver.com' - 해당 홈페이지의 host를 가져옴
location.href = "https://google.com"; // href프로퍼티를 통해 웹문서의 주소를 변경할 수 있음
```

이렇듯, `location`객체는 Web문서 URL에 대한 정보를 가지고 있다고 보면 된다.

사용자의 디스플레이 화면은 스마트폰, 데스크탑 모니터 등 다양한 디스플레이가 될 수 있다.

```js
// 브라우저 console 창에

console.log("text출력"); // 'text출력'
console.dir(screen); // dir을 사용하면 해당 객체에 대한 정보를 볼 수 있다.
/*
// 아래와 같이 현재 디스플레이 정보를 자세히 살펴 볼 수 있다.
availHeight: 1638
availLeft: 0
availTop: 0
availWidth: 1018
colorDepth: 24
height: 1638
isExtended: false
onchange: null
orientation: ScreenOrientation {angle: 0, type: 'portrait-primary', onchange: null}
pixelDepth: 24
width: 1018
[[Prototype]]: Screen
*/
```

사용자 디스플레이에 대한 정보가 필요하다면 `screen`객체를 사용하면 된다.
사용자의 위치 정보가 필요하다면 `navigator`객체의 메서드를 이용해서 가져올 수 있다.
MDN에 검색해보면, 해당 API에 대한 사용법을 알 수 있다.

```js
navigator.geolocation.getCurrentPosition(success, error, [options]); // MDN에 나와있는 사용방법

navigator.geolocation.getCurrentPosition(function success(pos) {
  const crd = pos.coords; // pos는 position 위도, 경도, 좌표의 위치정보를 보내줌

  console.log("Your current position is:");
  console.log(`Latitude : ${crd.latitude}`);
  console.log(`Longitude: ${crd.longitude}`);
  console.log(`More or less ${crd.accuracy} meters.`);
});

// 위치 정보 권한 허용을 누르면 위치 정보를 가져올 수 있다.
```

BOM의 더 자세하고 다양한 속성과 메서드를 알아보기 위해서는 MDN 사이트를 참고하면 도움이 많이 된다.

<br>

---

## load, defer, async

HTML 파일에서 자바스크립트 파일을 가져올 때, 효과적으로 가져올 수 있는 방법에 대해 알아보자.
보통은 `index.html`파일에서 `script`태그를 통해 js파일을 가져올 수 있다.

```html
<!-- index.html 파일 -->
<script src="script.js"></script>
<button id="btn">버튼</button>
```

```js
// script.js 파일
let btn = document.querySelector("#btn"); //버튼에 대한 요소를 선택한 뒤
// addEventListener를 통해서 버튼을 클릭시 이벤트 조작이 가능
console.log(btn); // null - script태그가 html 버튼보다 위에 있기 때문 (script load 문제발생)
btn.addEventListener("click", function () {
  alert("경고!");
});
```

해당 js파일에서 코드를 변경하게 되면, script로 연결된 html파일도 같이 변한다.
하지만 위 코드는 에러가 발생한다. 그 이유는 무엇일까?

브라우저에서는 이 index.html 파일을 만났을 때, 위에서 아래로 순차적으로 코드를 파싱(= 읽는다)한다.
파싱을 하다가 script 태그를 만나면 파싱을 잠시 멈추고 해당 script파일을 가져오게 된다.
그리고 script코드를 실행하게 된다.
그런데 해당 script파일에서는 `document.querySelector`를 이용해 button에 접근을 했지만,
이 버튼은 브라우저에서 해당 html을 파싱한 후에 DOM 요소를 생성하기 때문에 파싱도 하기전에 script파일이 먼저
실행되어서 null로 찾지 못했다는 에러가 발생하게 된 것이다.

**script 로드 해결방법**

과거에는 아래와 같은 2가지 방법으로 문제를 해결했다.

1. body 최하단에서 script태그를 선언하여 로드 (body 종료태그 위에 선언)
   (script태그 위치를 변경함으로서 HTML파싱을 먼저 하는 방법)

```html
<body>
  <button id="btn">버튼</button>
  ...
  <script src="script.js"></script>
  <!-- HTML파싱이 먼저 이루어짐으로 DOM요소에 접근이 가능해짐 -->
</body>
```

버튼 태그를 먼저 파싱 함으로써 script를 불러오기 전에 브라우저에서 생성하게 만들었다.
그 다음에 script를 실행하는 방식.

2. load 관련 이벤트 리스너 등록

`window.onload` : HTML파싱을 다 한 후, DOM을 생성하고 외부 콘텐츠(images, script, css, etc)가 로드된 후 발생하는 이벤트이다.
그래서 `window.onload` 안에 DOM요소를 가져올 수 있도록 코드를 작성했다.

```js
//script.js 파일
window.onload = function () {
  let btn = document.querySelector("#btn");
  btn.addEventListener("click", function () {
    alert("경고!");
  });
};
```

```html
<head>
  <script src="script.js"></script>
</head>
<body>
  <button id="btn">버튼</button>
</body>
```

script를 가져오고, script의 코드가 실행된다. 하지만 `window.onload`안에 있는 이벤트는 아직 실행되지 않은 상태이다.
모든 html을 파싱한 뒤에 실행되는 이벤트이기 때문이다.

하지만 이 `onload`이벤트 같은 경우에는 비효율적일 수 있다.
예를 들어, image를 100개 정도 가져와야 되는 상황에서 onload에 있는 코드를 실행하는데 이미지 100개를 모두 다 가져올 때까지 기다릴 필요는 없다.
그래서 이런 경우에는 document에 있는 `DOMContentLoaded` 이벤트를 사용하는 편이 더 효율적이다.

`DOMContentLoaded` : HTML 파싱 후 DOM 생성 후 발생하는 이벤트 (다시말해, 외부 콘텐츠는 기다리지 않는다.)

```js
//script.js 파일
document.addEventListener("DOMContentLoaded", function () {
  let btn = document.querySelector("#btn");
  btn.addEventListener("click", function () {
    alert("경고!"); // 정상적으로 작동됨
  });
});
```

```html
<head>
  <script src="script.js"></script>
</head>
<body>
  <button id="btn">버튼</button>
</body>
```

`onload`보다 `DOMContentLoaded`가 더 빨리 실행된다.

```js
window.onload = function () {
  alert("onload 경고!");
};
document.addEventListener("DOMContentLoaded", function () {
  alert("DOMContentLoaded 경고!");
}); // 먼저 출력됨
```

![](https://velog.velcdn.com/images/ninto_2/post/7fda839e-b8ba-46a4-bc4f-538ae9bdd3b8/image.png)

script 태그를 head 태그 위에 기본적으로 선언하게 되면, HTML 파싱을 쭉 하다가 Script 태그를 만나면 하던 일을 멈추고
Script fetch가 이루어진다. 그리고 Script 태그를 실행한다. 이 코드가 모두 종료된 후에 다시 HTML 파싱을 시작한다.

이렇게 HTML 파싱이 종료되지 않은 시점에서 Script 태그를 실행하게 되니까 HTML DOM 요소를 가져오지 못하는 상황이 발생하게 된 것이다.

![](https://velog.velcdn.com/images/ninto_2/post/38800598-1e6a-441c-b597-c1a2b76f0e9a/image.png)

하지만, script 태그를 html의 body태그 최하단에 넣게 되면, HTML 파싱을 모두 종료한 후에 Script fetch와 Script 코드 실행이 이루어지므로 정상적으로 HTML파싱 후 DOM 요소가 생성되어 원활하게 접근이 가능해진다.

그렇지만 위와 같은 방법도 단점이 존재한다.
예를들어, HTML 파싱이 모두 완료된 후에야 Script를 실행을 하도록 구현했지만 HTML 파싱을 할 때, Script 파일을 fetch하게 된 다면 더 효율적일 수 있을 것이다.

그래서 HTML5에서 등장한 `defer`와 `async` 속성이 있다.
이 두가지의 속성을 잘 활용하면 자바스크립트 파일을 효과적으로 가져올 수 있게 된다.

**HTML5 script load 해결 방법**

HTML5에서는 `defer`와 `async`속성을 통해 비동기 script 로드가 가능해져서 위와 같은 문제가 근본적으로 해결되었다.

`defer` : HTML 파싱과 함께 비동기로 JavaScript 파일을 불러온다.

```html
<head>
  <!-- 이런식으로 script 태그안에 defer를 붙여주면 HTML파싱이 완료된 후 자바스크립트 코드를 실행하게 된다. -->
  <script src="script.js" defer></script>
</head>
```

HTML 파싱을 하다가 script 태그를 만나면, defer 속성을 사용하기 전에는 HTML 파싱을 멈췄지만 defer 속성을 만나면 HTML 파싱을 그대로 진행하게 된다. 그러면서 동시에 Script fetch가 이루어진다.
(하던 작업을 멈추지 않고 병렬적으로 처리가 가능해짐으로 논블로킹, 비동기 처리가 가능해진다.
반대로 동기는 하던 작업을 멈추고 Script 파일을 가져올 때까지 기다리는 것이다.)
기다리는 시간이 비효율적이기 때문에 비동기로 만들어서 HTML 파싱 처리할 때 Script fetch까지 같이 가져올 수 있도록 구현한 것이다.

![](https://velog.velcdn.com/images/ninto_2/post/bca012c0-8809-44e5-acd9-01a32e5e80f2/image.png)

실행은 HTML 파싱이 끝 난 후에 Script 코드 실행이 이루어지는 방식이다.
(HTML 파싱이 모두 끝나고 DOM 요소가 생성이 된 후이기 때문에 코드 실행이 원활히 이루어지게 된다.)

```html
<!-- 아래와 같은 코드는 에러를 발생시킨다. -->
<head>
  <script src="script.js"></script>
</head>
<body>
  <button id="btn">버튼</button>
</body>
```

HTML 파싱이 모두 완료되기 전에 Script 태그를 fetch하고 실행하는 걸 기다리기 때문에 생성되지 않은 버튼에 접근하려고 하니 에러를 내보낸다.

```html
<!-- 위와 같은 코드에 defer를 붙여주게되면 비동기 fetch가 이루어져 에러가 발생되지 않음 -->
<head>
  <script src="script.js" defer></script>
</head>
<body>
  <button id="btn">버튼</button>
  <!-- 버튼실행도 정상적으로 잘 동작하게 된다. -->
</body>
```

HTML 파싱 중에 Script fetch를 하면서 HTML 파싱이 모두 완료 한 후에 Script 코드를 실행하는 방식이기 때문에 오류없이 원활히 DOM 요소에 접근이 가능해졌다.

defer속성은 HTML 파싱과 함께 비동기로 자바스크립트 파일을 가져오지만, 자바스크립트 코드 실행은 HTML 파싱이 모두 완료된 후에야 이루어진 다는 점에서 `async`와 속도 차이가 생길 수 있다.

`async` : HTML 파싱과 함께 비동기로 JavaScript 파일을 불러온다.
(HTML 파싱이 완료되지 않았더라도 먼저 로딩되는 자바스크립트 파일부터 실행이 시작된다.)

![](https://velog.velcdn.com/images/ninto_2/post/922056d6-d87e-4b79-b632-b42822da1f6f/image.png)

`async` 속성 같은 경우에는 `defer`와 마찬가지로 HTML 파싱을 하면서 Script 태그를 만나게 되면 논블로킹으로 비동기로 잘 fetch하게 된다. 그리고 나서 Script 파일을 실행할 때는 HTML 파싱이 일시적으로 중지되면서 실행을 하게 된다. 그래서 순서에 따라 원활하게 못 가져올 수도 있다.
그렇기에 `async` 같은 경우에는 꼭 필요한 순간에 사용을 해야하며, 일반적으로 Script 파일을 효과적으로 불러올 때는 `defer`속성을 사용하는 것이 안전할 수 있다.

<br>

---

## 자바스크립트의 this

자바스크립트에서 this는 객체를 가리키는 키워드이다. 쉽게 말해서 `this`는 객체이다.
그렇다면 `this`는 과연 어떤 객체를 가리키는 걸까?

가볍게 생각해보자면 `this`는 호출한 객체라고 볼 수 있다.
MDN에서는 this의 값은 대부분의 경우 함수를 호출한 방법에 의해 결정된다고 정의 해놓았다.

```js
console.log(this === window); // true
```

기본적으로 this를 호출한 주체가 없을 경우 기본값으로 `window`객체가 호출한 주체가 된다.

```js
// index.js 파일
const person = {
  name: "foo",
  age: 20,
  printThis: function () {
    console.log(this);
    console.log(this === person); // true
    console.log(this.name); // 'foo'
    console.log(this.age); // 20
  },
};
person.printThis(); // { name: 'foo', age: 20, printThis: f }
```

```html
<script src="index.js" defer></script>
```

이렇게 this는 person인걸 알 수 있다. 즉, this는 호출하는 방법에 의해 결정이 된다.
현재 person에 의해 호출되어 졌기 때문에 this는 person이 되었다. 따라서 this를 이용해서 해당 프로퍼티에도 접근이 가능하다.

```js
const person = {
  name: "foo",
  age: 20,
  printThis: function () {
    console.log(this); // Window
    console.log(this === person); // false
    console.log(this.name); // undefined
    console.log(this.age); // undefined
    console.log(this === window); // true
  },
};
let printThis = person.printThis;
printThis(); // 앞에 호출한 주체가 없기 때문에 this의 주체는 default로 window 전역객체가 된다.
```

this를 호출하는 메서드를 만약 변수에 할당하게 된다면 this가 person이 아니라고 나오게 된다.
이런식으로 호출하게 되었을 경우 this에는 window 객체가 들어간 모습을 볼 수 있다.
window 전역객체라는 것은 브라우저 창이라고 생각해도 된다. 여기서 말하는 브라우저 창은 자바스크립트로 이 브라우저를 제어할 수 있도록 브라우저에서 제공하는 전역객체이다.

```js
function printThis() {
  console.log(this); // default로 this는 window 객체
}
printThis(); // window

const person1 = {
  name: "foo1",
  printThis: printThis,
};
person1.printThis(); // this의 값은 person1이 된다.

const person2 = {
  name: "foo2",
  printThis: printThis,
};
person2.printThis(); // 마찬가지로 여기서 this의 값은 person2가 된다.
```

MDN에서는 대부분의 경우 this의 값을 함수를 호출한 방법에 의해 결정된다고 말하는데, 위 코드에서 살펴본 바로 person1에서 호출하였기에 this의 값은 person1이 되고, person2도 마찬가지의 값이 나온 것을 확인할 수 있다.

하지만, 대부분의 경우에서 this의 값을 의미하는 것이므로 모두가 다 그렇지만은 않다는 것을 알 수 있다.

**this 값의 예외**

- 전역 스코프에서의 this는 window 객체이다.
- 화살표 함수에서의 this
- Strict Mode에서의 this

위 3가지 경우의 this는 각각 의미가 다르다.

```html
<head>
  <script src="index.js" defer></script>
</head>
<body>
  <button id="btn">버튼</button>
</body>
```

```js
// index.js

const btn = document.querySelector("#btn");
btn.addEventListener("click", function () {
  console.log(this); // HTML button 요소가 나옴
  console.log(this === btn); // true
});
```

이 콜백함수 안에서 this가 window가 아니라 button인 이유는 둘 중 하나이다.
이 콜백함수가 `addEventListener` 메서드 내부 안에서 btn에 의해 다시 호출이 되었거나 아니면 내부에서 이 this를 button으로 설정했을 것이다.
그렇다면, 콜백함수 안에 있는 this를 마음대로 다른 객체로 변경하기 위해서는 어떻게 해야할까?

그래서 나온것이 ES5에서 this를 설정할 수 있는 `bind` 메서드 이다.

```js
function printThis() {
  console.log(this); // default로 this는 window 객체
}

const person1 = {
  name: "foo",
};

printThis(); // 호출하는 주체가 없기 때문에 이 this의 값은 window 객체
const printThisOutput = printThis.bind(person1); // bind 메서드를 통해 this에 person1 객체를 설정
printThisOutput(); // {name: 'foo'} person1이 바인딩 되서 this의 값으로 들어감
```

bind안에 this의 값으로 설정하고 싶은 객체를 넣어주면 된다. 이렇게되면, this에 person1이 바인딩 된 함수를 반환하게 된다.

```js
function printThis() {
  console.log(this); // default로 this는 window 객체
}

const person1 = {
  name: "foo1",
};

const person2 = {
  name: "foo2",
};

const printThisOutput1 = printThis.bind(person1);
const printThisOutput2 = printThisOutput.bind(person2);
printThisOutput2(); // person1이 출력됨
```

person1이 출력된 이유는, bind는 단 한번만 사용할 수 있기 때문이다. 다시 말해 원래의 함수 `printThis`에 단 한번만 bind를 등록할 수 있다는 개념이다.

브라우저에서 `setTimeout()`이라는 함수를 제공하는데, 이 함수의 파라미터로는 콜백함수와 시간이라는 인자를 받는다.
이 시간의 단위는 1ms 즉, 1000ms는 1초가 된다.

```js
const person = {
  name: "foo",
  age: 20,
  hello: function () {
    // 이 함수의 기능은 1초 후에 이 함수를 실행하는 기능이다.
    setTimeout(function () {
      console.log(this); // 여기서 this는 person객체가 아닌 window를 가리킨다.
      console.log(this.name, this.age);
    }, 1000);
  },
};

person.hello(); // undefined
```

위 코드에서 `this.name`과 `this.age`이 출력되지 않은 이유를 살펴보자.
setTimeout에 콜백함수를 정의했을 때, 안에 있는 this가 window인 이유는 내부에서 그렇게 정의를 하였기 때문이다.
여기서 중요한 점은 이 콜백함수 안의 this를 person으로 바인딩 시켜주어야 한다는 점이다.

```js
const person = {
  name: "foo",
  age: 20,
  hello: function () {
    console.log(this); // person 객체

    setTimeout(
      function () {
        console.log(this); // 바인딩되어 person 객체
        console.log(this.name, this.age); // 'foo' '20'
      }.bind(this),
      1000
    );
  },
};

person.hello();
```

어떠한 객체로 함수를 호출했을 때, 이때 함수에서 사용되는 this는 호출한 객체가 된다.
그리고 호출한 객체가 없을 경우엔 기본적으로 window 객체가 this의 값이 된다.

**전역 스코프에서의 this**

```js
console.log(this); // window 객체
console.log(this === window); // true
```

특이점으로는 화살표 함수와 스트릭 모드에서 this는 전역 스코프에서의 this 와 다르게 동작한다.

**Arrow Function this**

ES6에서 등장한 화살표 함수가 나오기 전까지는 함수는 어떻게 호출되는지에 따라 자신의 this 값을 정의했다.
하지만 화살표 함수는 자신을 포함하고 있는 외부 스코프에서 this를 전달받는다.
(쉽게말해 화살표 함수에서의 this는 존재하지 않으므로, 외부 스코프에서 this를 물려받게 된다.)
화살표 함수에서 this는 자신을 감싸고 있는 정적 범위이다.

```js
const person = {
  name: "foo",
  age: 20,
  hello: function () {
    console.log(this); // person

    setTimeout(() => {
      console.log(this); // person - 화살표 함수로 변경, 일반함수에서는 this의 값이 window였음
    }, 1000);
  },
};

person.hello();
```

hello메서드에서의 this는 호출한 객체였던 person이였다. 화살표 함수는 자신을 감싸고 있는 외부 스코프에서 this의 값을 물려 받기 때문에 hello메서드의 this값과 동일한 person이 나오게 된다.

```js
const person = {
  name: "foo",
  age: 20,
  hello: function () {
    const that = this; // 화살표 함수가 나오기전에 this를 바인딩했던 방법

    setTimeout(function () {
      console.log(this); // window
      console.log(that.name, that.age); // 'foo' 20
    }, 1000);
  },
};

person.hello();
```

화살표 함수가 등장하기 전까지는 this를 사용하기 위해 변수에 this값을 넣어서 사용을 하였다.
콜백함수안에서의 this는 window이지만 외부 this를 담고 있는 변수를 이용해서 원하는 값에 접근이 가능한 방법이였지만, 콜백함수에서 this를 사용할 때에는 일반함수에 this를 바인딩 하기 보단 화살표 함수를 이용하는 편이 더 간결하다.

하지만 화살표 함수를 사용하면 안되는 경우도 존재한다.

```js
const person = {
  name: "foo",
  age: 20,
  printThis: () => {
    console.log(this); // window 객체
  },
};
person.printThis(); // window 객체
```

위 코드처럼 객체의 메서드로 화살표 함수를 사용해서 this의 값을 사용하면 person이 아닌 window 객체를 가지게 된다.
화살표 함수는 외부 스코프에서 this를 물려받는다고 했는데 왜 window가 나왔을까?
그 이유는 printThis를 감싸고 있는 스코프는 전역 스코프이기 때문이다. 전역 스코프에서의 this는 window이므로 printThis의 this는 window가 출력되게 된다.

```js
const person = {
  name: "foo",
  age: 20,
  printThis: function () {
    console.log(this, this.name, this.age); // person 객체 'foo' 20
  },
};
person.printThis();
```

객체 메서드 같은 경우에서 this는 일반적으로 해당 객체의 다른 프로퍼티에 접근하기 위해 사용하므로, 화살표 함수보다 일반 함수를 사용하여 만드는 것이다.

또한, addEventListener 함수의 콜백 함수에서 화살표 함수로 사용하게 되면, this가 상위 컨텍스트를 가리킨다.

- addEventListener에서 화살표 함수로 등록하면 this 는 무조건 window 객체를 가리키게 된다.

```js
const btn = document.querySelector("button");
btn.addEventLister("click", () => {
  console.log(this === window); // true
  this.innerHTML = "Clicked btn";
});
```

그렇기 때문에 위와 같은 경우에서는 화살표 함수를 지양해야 할 경우가 발생한다.

```js
const btn = document.querySelector("button");
btn.addEventLister("click", function () {
  console.log(this === window); // false;
  console.log(this === button); // true;
  this.innerHTML = "Clicked btn";
});
```

**스트릭 모드의 this**

Strict Mode(엄격 모드)에서는 호출한 객체가 없을 경우 this의 기본값을 window가 아닌, undefined로 설정한다.

```js
"use strict";
function printThis() {
  console.log(this);
}
printThis(); // undefined
```

<br>

---

## API란?

Application Programming Interface (API)

> API는 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.

- Interface(인터페이스): 상호간에 소통을 위해 만들어진 접점
  (상호간에라는 뜻은 사람과 사람뿐만 아니라, 사람과 컴퓨터, 컴퓨터와 컴퓨터등 어떠한 서로 다른 2개 이상의 것들이 소통하기 위한 방법을 의미한다.)

![](https://velog.velcdn.com/images/ninto_2/post/3477d360-a954-4715-9ae8-02d5aeedbf11/image.png)

만약 달리는 자동차에서 문을 열고싶다면, 스마트 키의 열림 버튼을 눌러서 열게 만들 수 있다.
이처럼 스마트 키를 사용해서 문을 열었기 때문에 스마트 키는 사람과 자동차의 접점인 인터페이스라고 할 수 있다.

![](https://velog.velcdn.com/images/ninto_2/post/f0b4ebd9-6a52-403e-b9c9-1f30f43c2710/image.png)

컴퓨터와 사람간의 인터페이스도 마찬가지이다.
인터페이스에서 소통이라고 하는 것은 쉽게 말해 읽거나, 쓰는 것을 의미한다.

또 다른 예시로, 스마트폰 앱에 있는 모든 버튼, 모든 화면을 인터페이스라고 할 수 있다.
왜냐하면 App이라는 시스템은 이러한 화면을 통해 사용자의 소통의 역할을 하기 때문이다.
이처럼 사용자가 사용하는 인터페이스를 `User Interface` (UI)라고 부른다.
다만 스마트 키나 키보드, 모니터 같은 경우엔 물리적인 하드웨어 UI이고 APP이나 Web과 같은 것들은 소프트웨어 UI라고 볼 수 있다.

일반적으로 IT에서 UI라고 하면, 소프트웨어적인 UI를 의미한다.
이러한 UI가 Web을 통해 보여지면 Web UI, 모바일을 통해 보여지면 모바일 UI라고도 한다.

정리하자면, 인터페이스는 소통을 하기 위한 접점이며, UI는 사용자가 소통을 하기 위한 접점이라고 보면 된다.

![](https://velog.velcdn.com/images/ninto_2/post/d719110d-7c55-48b1-b04b-06b7df7c47f4/image.png)

API는 사용자가 아닌 응용 프로그램에서 소통하기 위한 인터페이스를 말한다.
여기서 말하는 응용 프로그램은 운영체제에서 실행되는 모든 소프트웨어를 의미한다. 다른 말로 애플리케이션이라고도 말한다.
즉, API는 애플리케이션에서 데이터를 읽거나 쓰기 위해 사용하는 인터페이스를 말하는 것이다.

예를들어, 우리 동네 날씨 정보를 보여주는 앱을 만들기 위해서는 우리 동네 날씨 정보가 먼저 있어야 한다.
이러한 날씨 정보는 보통 기상청에 있기 마련이다.

이 앱을 만들기 위해서는 기상청에 날씨 정보를 Request(요청)해서, 기상청에게 Response(응답)을 받은 후 화면에 날씨 정보를 보여주면 된다.
이때 날씨 정보 데이터를 가져오기 위해 기상청에서 제공하는 접점을 바로 API라고 한다.

API의 생김새는 주로 `http://api.data.go.kr/weather/list` 이런식으로 주소의 형태를 띄고있다.
이러한 API를 제공해주면, App에서는 `curl http://api.data.go.kr/weather/list` 이렇게 요청해서
`{'today': '2023-02-02', 'weather': '맑음'}`이러한 데이터를 응답을 받아, 사용자에게 보여줄 UI를 개발하면 된다.

정확히 얘기하자면 위와 같은 형식의 API를 `HTTP API`라고 한다.

공공 데이터 포털 사이트 `data.go.kr`에 들어가게 되면, 오픈API를 통해 API를 확인할 수 있다.

기상청에서는 동네 날씨 정보를 DB(데이터베이스)서버에 보관한다.
그리고 기상청에서는 날씨와 같은 API를 다른 애플리케이션에서 가져갈 수 있도록 서버에 다양한 API를 개발하고,
날씨정보앱에서는 이런 API를 조회하여 사용자에게 보여질 UI를 개발한다.

![](https://velog.velcdn.com/images/ninto_2/post/d64e0be3-3745-42cb-8361-fd58c018bc43/image.png)

이때 사용자에게 보여질 앞 단인 UI를 개발하는 쪽이 프론트엔드라고 하며, 데이터를 제공하는 뒷 단을 백엔드라고 지칭한다.
그리고 넓은 의미로는 프론트엔드를 클라이언트(요청자)라고 부르며, 백엔드를 서버(제공하는자)라고도 한다.

![](https://velog.velcdn.com/images/ninto_2/post/f4a6ea72-a83f-4071-8f62-3d34fb46eeb7/image.png)

애플리케이션을 개발하는 백엔드 팀에서는 데이터를 조회할 수 있도록 다양한 API를 개발해 놓았을 것이다.
그리고 프론트엔드 개발 팀에서는 이러한 API를 사용하여 사용자에게 보여질 UI를 개발한다.

이렇게 사용자는 UI를 통해 소통하며, 애플리케이션은 API를 사용하여 소통하는 것이다.

만약 특정 통계 기능을 개발해달라는 업무를 받게 되었다면, 백엔드에서는 해당 데이터에서 통계자료를 추출하여 프론트엔드 애플리케이션이 호출할 수 있도록 API를 개발한다. 그리고 프론트엔드에서 이 API를 사용하여 마케팅 팀에게 보여질 웹 UI를 개발하는 방식이다.

다시말해, API는 애플리케이션에서 데이터를 읽거나 쓰기 위해 사용하는 인터페이스 이다.
그리고 회사 자체 서비스를 만들기 위해 사내에서 개발하고 사용하는 API를 `Private API`라고 하며 이러한 `Private API`는 제3자에게 공개되지 않는다.
반면 기상청 API와 같이 누구나 사용할 수 있도록 개방해놓은 API를 `Public API` 또는 `Open API`라고 한다.
그리고 이런 오픈 API에는 공공 API, Youtube API, Instagram API, Facebook API, Naver API, Kakao API 등 많은 플랫폼에서 자체 데이터나 기능을 활용할 수 있도록 다양한 API를 제공한다.
그리고 이러한 API는 HTTP API를 말하며, `HTTP`는 주로 인터넷 상에서 데이터를 주고받을 때 사용하는 프로토콜이다.

> HTTP API = 프로토콜 = 소통방법 = 통신방법 = 통신규약

애플리케이션이 소통을 할 때도 상황에 따라 다양한 소통방법이 존재한다.

만약 미세먼지 측정기에서 미세먼지 농도 값을 읽어와서, 공기가 안좋으면 자동으로 창문을 개방하는 IOT 애플리케이션을 개발하고 싶다면,
미세먼지 측정기와 스마트 창문에 소통할 수 있는 API가 있는지 확인해야 한다.
이때 사용하는 소통 방법은 저사양, 저환경에 적합한 `MQTT, CoAP API` 프로토콜을 사용해야 할 것이다.

또, API는 통신 프로토콜 레벨이 아닌 `Class`나 `Function`와 같은 소스코드 레벨이 될 수 도 있다.
우리가 보통 자바스크립트로 콘솔에 소스코드를 찍을 때 `Console API`를 사용한다.
만약 자바를 사용해 개발을 한다면, Java의 클래스나 메서드를 사용해서 개발할 것 이다.

즉, API에는 용도에 맞는 다양한 API들이 존재하고 있다.

일반적으로 오픈 API와 같은 용어로 사용할 때에는 인터넷 상에서 데이터를 주고 받는 HTTP API를 말한다는 것을 인지하면 된다.

<br>

---

## 동기와 비동기란?

쉽게 말하자면 동기(Synchronous)는 답변을 기다리는 것, 비동기(Asynchronous)는 답변을 기다리지 않는 것이다.

일상 생활에서 예시로 생각해보자면 동기식으로 일을 한다는 건 한 사람이 물건을 던지면 상대방이 물건을 잘 받았는지 안 받았는지 답변을 기다리게 된다.
그때까지 다음 일은 하지 않는 상태이다. 상대방의 답변이 OK라면 그때서야 비로소 다음 물건을 전달해주는 방식이다.

그렇다면, 비동기식으로 일을 하는 경우는 어떤 경우를 말하는 걸까?
비동기식으로 일을 한다는 것은 물건을 상대방에게 전달할 때, 상대방의 상황은 고려하지 않고 계속해서 물건을 상대방에게 전달하는 방식을 의미한다.

택배 운송 작업을 생각해보자, 나에게 배송 물품이 6개 정도 있고 각각 6개의 집에 물건을 배송하는 업무를 해야한다.
동기식으로 일을 한다면, 물건을 가지고 1번 집에 찾아가서 받는 사람의 답변을 기다린 뒤 답변을 받으면 다음 2번 일을 하는 방식이다.
이렇게 계속 답변을 받을 때까지 기다리는 것이다. (쉽게 말해, 배달 오프라인 결제 시스템과 비슷)

비동기식으로 일을 한다면, 물건을 가지고 1번 집에 찾아가서 물건을 놓고 답변을 기다리지 않고 바로 다음 2번 일을 수행한다.
이렇게 비동기 식은 답변을 기다리지 않고 바로 다음 일을 수행한다. (비대면 배달과 같은 방식)

위와 같은 상황을 생각해보면, 비동기 방식이 더 효율적이라고 느낄 수 있다.
왜냐하면 동기식은 답변을 기다려야 하기 때문에 비동기 방식이 더 자원을 효율적으로 사용할 수 있게 보인다.

하지만, 비동기식으로 일을 하면 확인이 안된다. 즉, 물건을 상대방이 잘 전달 받았는지 받지 못했는지를 결과를 확인 할 수 없다.

예를들어, 운송기사가 상품을 전달했다고 했는데 받는 사람이 못 받았다고 말하면 문제가 발생할 수 있다.
그래서 비동기 방식에서 다음과 같은 프로세스를 추가했다.
비동기 식으로 일을 처리하되, 배송 도착 사진을 촬영해서 받는 사람에게 전송하는 것이다. (비대면 배달 후 문자 전송 시스템같은 방식)
이렇게 되면 효율적인 일 처리를 하되 배송을 완료했다는 정당성이 생긴다.

중요한건 비동기로 일을 할 때에는 효율적이지만 그 업무 프로세스가 조금 복잡해 질 수 있다는 점이다.

**동기와 비동기의 장단점**

![](https://velog.velcdn.com/images/ninto_2/post/2dfa9f2f-0d59-4ff1-adae-27172e01a906/image.png)

동기식으로 일을 진행 할 때에는 업무가 단순하다는 장점이 있지만, 자원을 비효율적으로 사용하게 된다는 단점이 존재한다.
비동식인 경우에는 자원을 효율적으로 사용하지만, 업무가 복잡해 질 수 있다는 단점이 존재한다.

- Blocking(블로킹): 동기식에서 답변이 올 때까지 기다리는 상태를 의미한다. (쉽게말해 기다리는 것)
- Non-Blocking(논블로킹): 비동기식에서 답변이 올 때까지 기다리지 않는 상태를 의미한다.
- 동기: 결과를 기다리는 것
- 비동기: 결과를 기다리지 않는 것

그렇다면, 프로그래밍을 구현할 때 비동기가 효율적이니까 복잡하더라도 계속 비동기로 일을 해야 하는 것 일까?
물론 프로그램을 구현할 때 효율성을 가지고 따질 때는 그럴 수 있겠지만 동기와 비동기는 어떤 상황이냐에 따라 선택할 수 있다.

어떤 일을 수행한 결과로 다음 일을 수행 할 때는 동기로 해야 한다.
(다음 일에서 결과를 보장 받을 수 있을 경우)
예를 들어서 편의점에서 아이스크림을 사고, 남은 돈으로 정육점에서 고기를 산다고 가정을 했을 때 편의점에서 결과인 거스름돈 받는 걸 기다리지 않고 나오면 안되기 때문이다.
지금처럼 결과가 다음 행동에 지장을 주는 경우에는 동기로 일을 진행해야 한다.

만약 계좌 이체 프로그램을 구현하려고 한다고 가정했을 때, A계좌에서 B로 10000원을 송금할 예정이다.
이러한 프로그램은 동기식으로 구현을 해야 한다.

```js
function ATM() {
  A계좌로_인출(); // A계좌에서 만원을 인출하는 프로그램을 실행

  B계좌로_송금(); // 결과를 기다리지않고 B계좌에 만원을 송금하면 안된다.
}

function A계좌로_인출() {
  console.log("A계좌 인출"); // 인출과정에서 잔액이 부족하다거나 올바르지 않은 계좌번호라던지, 은행 점검시간 등의 문제가 발생할 수 있기 때문
}

function B계좌로_송금() {
  console.log("B계좌 송금");
}
```

위와 같은 프로그램에서는 결과가 성공해야지만, 다음 함수를 호출하는 식으로 이루어져야 한다.
즉, A프로그램을 실행하고 동기식으로 기다렸다가 B프로그램을 실행해야 한다.
이처럼 프로그램의 상황에 따라 동기식, 비동기식 구현 여부가 달라 질 수 있다.

<br>

---

## 프론트엔드 & 백엔드

![](https://velog.velcdn.com/images/ninto_2/post/729d1269-3dd6-4b0b-a56c-04d60fa0b8d7/image.png)

쉽게 말하자면, 프론트엔드는 웹사이트에서 사용자들이 사용하는 화면과 같은 앞 단을 의미한다.
그리고 이러한 사용자 화면(UI)를 개발하는 사람을 프론트엔드 개발자라고 한다.
(요청하는 앞 단의 영역)

백엔드는 눈에 보이지 않는 영역으로 API와 같은 뒷 단의 영역을 말한다.
그리고 이러한 API를 개발하는 사람을 백엔드 개발자라고 한다.
(요청에 응답하는 뒷 단의 영역)

넓은 의미로는 이 둘을 클라이언트와 서버라고도 한다.

클라이언트는 인터넷상에서 요청하는 쪽을 말하며, 서버는 이러한 요청에 대해 서비스를 제공하는 역할을 한다.

예를 들어, 어떤 회사에서 포켓몬 도감 웹사이트를 개발한다고 가정을 해보자.
이 웹 사이트의 기능은 간단하다. 사용자가 웹페이지에 접근했을때 포켓몬 목록을 보여 주면 된다.
그러면 이 회사의 백엔드 개발자는 프론트엔드에서 포켓몬 목록을 가져갈 수 있도록 자바, 파이썬, 노드js와 같은 서버 개발 언어를 사용하여 `http://api.pokemon.co.kr/pokemons`와 같은 포켓몬 목록 API를 개발한다.

API는 위와 같은 URL 형식의 주소를 말한다. 예를들어 이 API를 호출하면

```js
[
  {
    name: "꼬부기",
    image: "https://127.0.0.1/꼬부기.png",
  },
  {
    name: "이상해씨",
    image: "https://127.0.0.1/이상해씨.png",
  },
];
```

와 같은 결과값을 반환한다.
백엔드 개발자는 이 API를 프론트엔드 개발자에게 제공한다.
물론 이 URL만 단순히 제공하는 것이 아니라 이 API를 어떻게 사용하는지 API 명세서를 정리해놓는다.

프론트엔드 개발자는 백엔드 개발자들이 만들어 놓은 이 API 명세서(API Docs)를 확인한 후,
HTML,CSS,JavaScript와 같은 웹 개발 언어를 사용하여 일반적인 사용자가 볼 수 있도록 사용자 인터페이스를
즉 UI를 개발하는 업무를 맡는다.

이 도감 사이트가 인기가 많아져서 유저들이 직접 포켓몬을 등록할 수 있는 기능 추가를 하기로 했다고 가정해보자,

![](https://velog.velcdn.com/images/ninto_2/post/cd7e6755-c1a1-4c87-bf37-fecce929e486/image.png)

스펙이 추가되었으므로 백엔드 개발팀에서는 유저 포켓몬을 등록할 수 있는 등록 API도 개발한다.

![](https://velog.velcdn.com/images/ninto_2/post/91443b79-e829-4e63-b0bd-81af0125233b/image.png)

그리고 프론트엔드 개발팀은 사용자가 유저 포켓몬을 등록할 수 있도록, 백엔드 개발팀에서 제공하는 API를 사용하여 등록할 수 있는 화면을 개발한다.

이렇듯, 백엔드 개발팀은 서버측(Server Side)를 개발하고, 클라이언트 개발팀은 클라이언트측(Client Side)를 개발한다.
그래서 클라이언트 개발자, 서버 개발자 라고도 한다.

참고로, 서버 개발자라고 해서 서버를 개발하는게 아니라 서버 위에서 실행되는 애플리케이션을 개발하는 개발자를 의미한다.

위 회사에서 또 다른 기능으로 매일 포켓몬을 가장 많이 등록한 유저를 추첨하는 기능을 추가한다고 해보자.

![](https://velog.velcdn.com/images/ninto_2/post/2900930c-ce1d-4511-839e-dbc36eb1cf1b/image.png)

이러한 기능은 사용자의 이벤트에 의해 실행되는 것이 아니라, 서버측에서 매일 하루에 한 번씩 자동으로 데이터베이스에 접근하여 정기적으로 수행해야 하는 작업이다.
이렇게 정기적으로 반복해서 수행하거나 정해진 규칙에 따라 일괄처리 하는 것을 배치프로그램 이라고 한다.

![](https://velog.velcdn.com/images/ninto_2/post/5ce6c0c1-0e68-4b78-826a-9cf2e1fc488d/image.png)

백엔드 개발팀에서는 프론트엔드에서 요청하는 API뿐만 아니라 서버측에서 실행되는 모든 애플리케이션을 개발하는 역할을 담당한다.

이 회사에서는 또 안드로이드와 iOS 어플까지 론칭 하기로 했다고 가정해보자.
그러면 자바나 코틀린으로 안드로이드를 개발하고 Object-C나 Swift와 같은 언어를 사용하여 iOS 앱을 개발한다.

프론트엔드와 백엔드를 언급하는건 보통 웹의 경우에 많이 쓰이며, 모바일과 같은 경우에는 클라이언트 개발자, 모바일 또는 안드로이드, iOS 개발자라고 한다.

이러한 용어를 언급하는 이유는 과거에 웹사이트를 개발할 때 JSP나 PHP와 같은 템플릿엔진을 기반으로 개발을 많이 진행했었는데 이런 경우에는 따로 프론트, 백엔드를 나누지 않고 그냥 웹개발자로서 개발을 진행했기 때문이다.

하지만 현대 웹애플리케이션에서는 React, Vue, Angular와 같은 강력한 웹 개발 프레임워크가 등장했고,
브라우저와 HTML5 기술이 발전하면서 웹 개발 폭이 조금 더 다양해졌다.

과거의 템플릿 엔진으로 하나의 웹 애플리케이션을 개발하던 시절과는 달리 프론트엔드, 백엔드의 완전한 분리 구조를 이루면서 서로 API통신을 주고받는 웹개발 방식으로 점차 바뀌게 되었다.

이렇게 웹개발 방식의 분리 구조가 명확해지면서 이러한 용어가 쓰이게 되었다.

<br>

---

## 이벤트 버블링과 캡처링

브라우저에서 이벤트가 발생했을 때 과연 어떠한 흐름으로 Event Phase(이벤트 전파)가 이루어 질까?

```html
<html>
  <head>
    <title>Event Phase</title>
    <script src="index.js" defer></script>
  </head>
  <body>
    body 영역
    <main>
      main 영역
      <div>
        div 영역
        <p>
          p 영역
          <span>span 영역</span>
        </p>
      </div>
    </main>
  </body>
</html>
```

![](https://velog.velcdn.com/images/ninto_2/post/798f07bb-cfb2-45b4-90d1-3ece31ad6fd6/image.png)

예를들어, 가장 안쪽에 있는 span 태그에 click 이벤트가 발생했다고 가정해보자.
그러면 이벤트의 흐름은 최상위 요소인 html요소부터 자식 태그로 타고 내려가서 target 이벤트 요소까지 이벤트가 전파된다.
그리고 나서 반대로, 다시 부모요소로 타고 올라가는 흐름을 보인다.

![](https://velog.velcdn.com/images/ninto_2/post/01d837cb-a828-4b05-ad08-b07eb0657ae6/image.png)

즉, 이벤트의 흐름은 최상위 요소부터 target 이벤트 요소까지 이벤트가 전파된 다음에 다시 부모부터 최상위 요소까지 전파되는 흐름이다.

그리고 최상위 요소부터 target 이벤트 요소까지 이벤트가 전파되는 과정을 이벤트 캡쳐링(Event capturing)이라고 하며, 반대로 부모요소부터 최상위 요소까지 이벤트가 전파되는 과정을 이벤트 버블링(Event bubbling)이라고 한다.

보통 자바스크립트에서 이벤트를 등록할 때, `addEventListener`를 이용해서 등록하는데, 이때 기본 동작은 이벤트 버블링으로 동작하게 된다.

```js
const $body = document.querySelector("body");
const $main = document.querySelector("main");
const $div = document.querySelector("div");
const $p = document.querySelector("p");
const $span = document.querySelector("span");

$span.addEventListener("click", function () {
  console.log("span 태그");
});
$p.addEventListener("click", function () {
  console.log("p 태그");
});
$div.addEventListener("click", function () {
  console.log("div 태그");
});
$main.addEventListener("click", function () {
  console.log("main 태그");
});
$body.addEventListener("click", function () {
  console.log("body 태그");
});

/* 
span태그 클릭시 span부터 시작해서 body태그까지 버블링으로 올라가는 것을 확인할 수 있다.
"span 태그"
"p 태그"
"div 태그"
"main 태그"
"body 태그"
*/
```

위와 같은 이벤트는 버블링으로 동작하기 때문에 해당 위치에 이벤트가 등록되었다라고 생각하면 된다.

그렇다면, 이벤트가 캡처링될 때 동작은 어떻게 이루어 질까?

```js
const $body = document.querySelector("body");
const $main = document.querySelector("main");
const $div = document.querySelector("div");
const $p = document.querySelector("p");
const $span = document.querySelector("span");

// 이벤트 캡처링
$span.addEventListener(
  "click",
  function () {
    console.log("캡처링 span 태그");
  },
  true
); // addEventListener에 호버를 하게 되면, 3번째 파라미터로  boolean 타입이나 이벤트리스너 옵션타입을 받을 수 있다.
$p.addEventListener(
  "click",
  function (event) {
    console.log(`${event.eventPhase} 캡처링 p 태그`); // 이벤트 페이즈는 현재 캡처링 단계에서 페이즈값을 확인할 수 있다. [2]
  },
  true
);
$div.addEventListener(
  "click",
  function () {
    console.log("캡처링 div 태그");
  },
  true
);
$main.addEventListener(
  "click",
  function () {
    console.log("캡처링 main 태그");
  },
  true
);
$body.addEventListener(
  "click",
  function () {
    console.log("캡처링 body 태그");
  },
  true
);

// 이벤트 버블링
$span.addEventListener(
  "click",
  function () {
    console.log("버블링 span 태그");
  },
  false
);
$p.addEventListener("click", function () {
  console.log("버블링 p 태그");
});
$div.addEventListener("click", function () {
  console.log("버블링 div 태그");
});
$main.addEventListener("click", function () {
  console.log("버블링 main 태그");
});
$body.addEventListener("click", function () {
  console.log("버블링 body 태그");
});
```

![](https://velog.velcdn.com/images/ninto_2/post/eae3af7e-a043-40bf-b561-982aba65ee1f/image.png)

`addEventListener`의 3번째 파라미터로 `true`를 전달하게 되면 이벤트 캡처링으로 동작하게 된다.
default값은 기본적으로 `false`로 되어있다.(default가 false면 일반적으로 버블링)

이 상태에서 다시 클릭하게 되면, body태그부터 이벤트가 발생한 span태그까지 전파되는 것을 확인할 수 있다.
그리고 다시 이벤트가 발생한 span태그를 실행한 후에 부모로 이벤트가 전파되는 과정을 확인 할 수 있다.

![](https://velog.velcdn.com/images/ninto_2/post/969c40d5-b777-4576-befd-abecca7cf5a3/image.png)

또한, 이벤트객체에는 `eventPhase`라는 속성이 있다.
캡처링 될 때는 이벤트 페이즈의 값이 [1]이고, 타겟 요소에 왔을 때는 [2], 버블링 될 때에는 [3]이 나오는 것을 확인할 수 있다.

> Event 인터페이스의 `eventPhase` 읽기 전용 속성은 **현재 평가 중인 이벤트 흐름 단계**를 나타낸다. - MDN

즉, 캡처링 될 때 부모객체를 통해 타깃 이벤트까지 전달될 때에는 값이 [1], 타깃에 도착했을 때는 [2], 역으로 버블링되어 부모요소로 올라갈 때에는 [3] 이라고 보면 된다.

그러면 이러한 이벤트의 전파를 막는 방법은 무엇일까?
이럴때에는 이벤트 객체의 이벤트 전파를 막아주는 `event.stopPropagation()` 메서드를 사용할 수 있다.

```js
$span.addEventListener(
  "click",
  function (event) {
    event.stopPropagation(); // 이 메서드를 사용하게 되면 이벤트 전파를 막을 수 있다.
    console.log("버블링 span 태그");
  },
  false
);
// 이 밑으로는 실행되지 않음
$p.addEventListener("click", function () {
  console.log("버블링 p 태그");
});
$div.addEventListener("click", function () {
  console.log("버블링 div 태그");
});
$main.addEventListener("click", function () {
  console.log("버블링 main 태그");
});
$body.addEventListener("click", function () {
  console.log("버블링 body 태그");
});
```

이렇게 버블링되는 시점에서 이벤트 전파를 막아주게 되면, 캡처링과 "버블링 span 태그"까지만 출력이 되고 그 다음 전파는 막아진 것을 확인 할 수 있다.
이러한 메서드는 실무에서도 자주 사용되기 때문에 잘 알아두면 좋다.

이벤트를 막는 메서드 중에 `event.stopPropagation()`이러한 web API말고, `Event.preventDefault()` API가 존재한다.
이 메서드는 해당 HTML 요소에 대한 기본 동작을 실행하지 않도록 지정한다.

```html
<body>
  body 영역
  <main>
    main 영역
    <div>
      div 영역
      <p>
        p 영역
        <span>span 영역</span>
      </p>
    </div>
    <a href="http://naver.com">네이버</a>
  </main>
  <script src="index.js"></script>
</body>
```

HTML에서 a태그를 클릭하게되면 해당 주소로 이동이 이루어진다.
이러한 기본동작을 막고 싶다면 `preventDefault()` 메서드를 사용하게 되면 문서 이동이 막아진다.

```js
// index.js
const $a = document.querySelector("a");
$a.addEventListener("click", function (event) {
  event.preventDefault(); // 이 메서드를 호출하게되면 기본동작을 막아준다.
});
```

이러한 메서드는 submit 이벤트를 막거나, 앵커태그(a 태그) 기본 기능을 막을 때 주로 사용된다.

<br>

### Array.prototype.reduce로 중복 요소의 값 제거하기

```js
const nums = [1, 2, 3, 4, 2, 3, 4, 5];
const result = nums.reduce((arr, cur) => {
  if (!arr.includes(cur)) arr.push(cur);
  return arr;
}, []);
console.log(result); // [1, 2, 3, 4, 5]
```

<br>

---

## JavaScript 모듈 시스템

![](https://velog.velcdn.com/images/ninto_2/post/d869f075-e9fe-45ea-87c9-cd8febe15b79/image.png)

자바스크립트는 원래 Web문서 안에서 간단히 웹 브라우저를 조작하기 위한 언어였다.
하지만 애플리케이션의 규모가 커지면서 파일을 여러개로 분리해야 하는 상황이 오게 되었다.
그래서 이렇게 분리된 하나의 파일을 Module(모듈)이라고 부른다.

```js
import a from "./a.js";
import b from "./b.js";
import c from "./c.js";
```

그리고 이러한 모듈을 언제든지 불러올 수 있도록 하는 방법을 모듈 시스템이라고 한다.

```html
<head>
  <script src="a.js"></script>
  <script src="b.js"></script>
  <script src="c.js"></script>
</head>
```

자바스크립트에서 모듈 시스템이 있기 전에는 브라우저에서 script태그를 사용하여 불러왔다.
하지만 이러한 방법은 전역 스코프를 공유한다는 문제가 있었다.
이렇게 여러개의 파일이 나뉘어 있어도 실제로 동작할 때는 하나의 파일 안에 있는 것처럼 전역 스코프를 공유하기 때문이다.

```js
// a.js
var number = 10;
console.log(number);
```

```js
// b.js
var number = 20;
console.log(number);
```

```html
<script src="a.js"></script>
<script src="b.js"></script>
<script>
  console.log(number);
</script>
```

브라우저에서 확인을 해보면, a.js에서 number는 10, b.js에서 number는 20으로 나오지만
실제 HTML 파일에서 number는 20으로 출력된 것을 확인할 수 있다.
그 이유는 HTML에서 b.js파일을 가장 나중에 불러왔기 때문이다. (number가 20으로 덮어씌워짐)

```html
<script src="b.js"></script>
<script src="a.js"></script>
<script>
  console.log(number);
</script>
```

a.js파일을 가장 나중에 불러오게 되면 number에는 10이 출력된다.
이처럼 실제로 js파일이 나누어져 있지만, 브라우저에서 동작할 때에는 마치 하나의 파일 안에 있는 것처럼 동작을 하게된다.
그렇기 때문에 만약 이름이 같은 변수가 있다면 덮어씌워지는 등 의도하지 않은 값이 출력되는 문제가 발생할 수 있다.

애플리케이션의 규모가 커지면 커질 수록 이러한 자바스크립트 파일을 여러개로 분리해야 될 때가 많이 발생하는데
그래서 다양한 자바스크립트 커뮤니티에서는 파일을 각각의 효과적으로 분리하기 위해 다양한 방법을 만들었다.
이런 시스템을 바로 모델 시스템이라고 한다.

즉, 모듈은 독립적으로 자신만의 스코프를 갖기 때문에 전역 스코프에서 발생되는 문제를 해소할 수 있다.

```js
// b.js
console.log("1번 number" + number); // 10 - a.js의 number 값인 10이 출력됨
var number = 20;
console.log("2번 number" + number); // 20
```

그렇다면, a와 b.js파일에 있는 number를 HTML에서 각각 사용하고 싶다면 어떻게 해야할까?

```html
<script type="module" src="b.js"></script>
<script type="module" src="a.js"></script>
<script type="module">
  console.log(number); // ReferenceError: number is not defined
</script>
```

script태그에 type module을 설정하게 되면, 해당 파일은 모듈로 간주된다.
출력이 안되는 이유는 각각의 모듈별로 스코프를 갖기 때문이다.

```html
<script type="module">
  import a_number from "./a.js";
  import b_number from "./b.js";
  console.log(a_number, b_number); // 10 20
</script>
```

모듈을 가져올 때는 `import`를 통해서 가져올 수 있다. 그리고 해당 모듈에서는 `export`를 사용해 자원을 내보내야 한다.

```js
// a.js
var number = 10;
console.log(number);

export default number;
```

```js
// b.js
var number = 20;
console.log(number);

export default number;
```

위와 같은 모듈 시스템은 ES6에서 도입된 모듈 시스템이다.
모듈시스템을 활용함으로써 a모듈과 b모듈에 있는 자원을 가져올 수 있다.

**모듈 시스템의 장점**

- 유지보수 용이 : 기능들이 모듈화가 잘 되어 있는 경우, 의존성을 줄일 수 있기 때문에 기능을 개선이나 수정이 용이하다.
  (독립적으로 코드가 떨어져있기 때문에 수정할 때 용이하다.)
- 네임스페이스화 : 코드의 양이 많아질수록 전역 스코프에 존재하는 변수명이 겹치는 경우가 존재한다.
  이때 모듈로 분리하면 모듈만의 네임스페이스를 갖기 때문에 문제를 해결할 수 있다.
- 재사용성 : 같은 코드를 반복하지 않고 모듈로 분리시켜서 필요할 때마다 재활용할 수 있다.
  (만약 b모듈에서 a모듈에 있는 2,3번 기능을 가져오고 싶다고 했을때 해당 2,3번의 기능을 모듈화시켜서 재활용 할 수 있다.)

**모듈 시스템 종류**

- AMD : 가장 오래된 모듈 시스템 중 하나로 `require.js`라는 라이브러리를 통해 처음 개발되었다.
- **CommonJS** : NodeJS 환경을 위해 만들어진 모듈 시스템이다.
- UMD: AMD와 CommonJS와 같은 다양한 모듈 시스템을 함께 사용하기 위해 만들어졌다.
- **ES Module** : ES6(ES2015)에 도입된 자바스크립트 모듈 시스템이다.

**ES Module 방식**

ES6(ES2015)에 도입된 자바스크립트 모듈 시스템이다.
`script`태그에 `type='module'` 속성을 추가해주면, 이 파일은 모듈로서 동작하게 된다.

```html
<script type="module" src="module/index.js"></script>
```

모듈을 외부에서 사용할 수 있도록 내보낼 때는 `export`, `export default`와 같은 키워드를 사용하며,
외부에서 모듈을 불러올 때는 `import`를 사용하여 모듈을 불러올 수 있다.

- `named export`를 사용하여 함수 또는 변수를 내보낼 수 있다.

```js
//module/math.js
export const perfectScore = 100;

export const sum = (num1, num2) => {
  return num1 + num2;
};

export const avg = function (score1, score2) {
  return (score1 + score2) / 2;
};
```

(각각의 변수나 함수를 선언해서 사용하는 방식)

```js
//module/index.js

import { perfectScore, sum, avg } from "./math.js";
console.log(perfectScore, sum(80, 10), avg(80, 90));
```

```html
<script type="module" src="module/index.js"></script>
```

이렇게 모듈로 연결시켜주면 HTML파일에서 `100 90 85`처럼 해당 모듈을 잘 불러오는 것을 확인할 수 있다.
모듈을 받아올 때 아래와 같이도 선언이 가능하다. (as를 이용해서 별칭을 적용)

```js
//module/index.js

import * as math from "./math.js";
console.log(math.perfectScore, math.sum(80, 10), math.avg(80, 90));
```

- `export default`를 사용하여 하나 기본 함수를 내보낼 수 있다. (단, 모듈 당 하나만 사용가능)

```js
//module/math.js
export const perfectScore = 100;

export const sum = (num1, num2) => {
  return num1 + num2;
};

export const avg = function (score1, score2) {
  return (score1 + score2) / 2;
};

const subtract = (num1, num2) => {
  return num1 - num2;
};

export default subtract; // default 함수 지정
```

위와 같이 default로 함수를 선언한 경우에는 바로 default 함수를 받을 수 있다.

```js
//module/index.js

import { perfectScore, sum, avg } from "./math.js";
import subtract2 from "./math.js";
console.log(perfectScore, sum(80, 10), avg(80, 90), subtract2(80, 90)); // 100 90 85 -10
```

default 함수같은 경우에는 이름을 마음대로 지정할 수 있다.
ES Module을 내보낼 때 각각의 변수나 함수를 모듈로 내보낼 수 있지만, 한번의 기본값으로도 전달이 가능하다.

```js
//module/math.js
const perfectScore = 100;

const sum = (num1, num2) => {
  return num1 + num2;
};

const avg = function (score1, score2) {
  return (score1 + score2) / 2;
};

const subtract = (num1, num2) => {
  return num1 - num2;
};

export default {
  perfectScore,
  sum,
  avg,
  subtract,
};
```

```js
//module/index.js
import math from "./math.js";
console.log(
  math.perfectScore,
  math.sum(80, 10),
  math.avg(80, 90),
  math.subtract(80, 90)
); // 100 90 85 -10
```

이렇듯, 내보내는 방식은 다양하기 때문에 팀의 컨벤션이나 효율에 맞게 선해해서 사용하는 것이 중요하다.

**CommonJS 방식**

> NodeJS에서는 기본적으로 `CommonJS`모듈 시스템을 사용하고 있으며, NodeJS버전 13.2부터 `ES모듈`시스템에 대한 정식 지원이 시작됨에 따라 다른 도구 없이 NodeJS에서도 쉽게 ES모듈을 사용 할 수 있다. - MDN

모듈을 내보낼 때에는 `exports`, `module.exports`와 같은 키워드를 사용하며, 외부에서 모듈을 불러올 때는 `require`를 사용하여 모듈을 불러 올 수 있다.

- `exports`변수의 속성으로 내보낼 함수를 설정 할 수 있다.

```js
//module/math.js
exports.perfectScore = 100;

exports.sum = (num1, num2) => {
  return num1 + num2;
};

exports.avg = function (score1, score2) {
  return (score1 + score2) / 2;
};

exports.subtract = (num1, num2) => {
  return num1 - num2;
};
```

```js
//module/index.js
const { perfectScore, sum, avg, subtract } = require("./math"); // 전개구문으로 받는 방식
console.log(perfectScore, sum(80, 10), avg(80, 90), subtract(80, 90));
// node에서 실행하게 되면 100 90 85 -10이 출력된다.
```

```js
//module/index.js
const math = require("./math"); // 한꺼번에 math라는 하나의 객체로 받을 수도 있다.
console.log(
  math.perfectScore,
  math.sum(80, 10),
  math.avg(80, 90),
  math.subtract(80, 90)
); //사용할 땐 앞에 객체를 붙여야 한다.
```

- `modeule.exports`를 사용하여 하나의 객체로 묶어서 내보낼 수 있다.

```js
//module/math.js
const perfectScore = 100;

const sum = (num1, num2) => {
  return num1 + num2;
};

const avg = function (score1, score2) {
  return (score1 + score2) / 2;
};

const subtract = (num1, num2) => {
  return num1 - num2;
};

module.exports = {
  perfectScore,
  sum,
  avg,
  subtract,
};
```

```js
//module/index.js
const { perfectScore, sum, avg, subtract } = require("./math"); // 동일한 결과가 출력됨
console.log(perfectScore, sum(80, 10), avg(80, 90), subtract(80, 90));
// node에서 실행하게 되면 100 90 85 -10이 출력된다.
```

CommonJS에서도 그 때 상황에 맞게 사용하면 된다.
이렇게 현재 가장 많이 사용되고 있는 모듈 시스템은 CommonJS와 ES Module 시스템이다.
프론트엔드 웹 개발시에는 ES Module를 많이 사용하고, CommonJS 모듈 시스템은 NodeJS환경에서 사용하는 기본 모듈 시스템이다.

그렇다면 NodeJS환경에서 ES Module 시스템을 사용하는 방법에 대해 알아보자.

**ES Module for NodeJS**

CommonJS 모듈 시스템을 채택했던 노드 환경에서 ES Module 시스템을 사용하려면 Babel과 같은 트랜스파일러(transpiler)를 사용해야 했는데, `NodeJS버전 13.2`부터 ES모듈 시스템에 대한 정식 지원이 시작됨에 따라 다른 도구 없이 노드환경에서 손쉽게 ES Module 시스템을 사용할 수 있게 되었다.

- NodeJS 에서 ES Module 사용법 : `package.json -> "type" : "module"` 선언

터미널에서 node로 해당 파일을 실행해보자.
노드는 실행할 때 package.json 파일을 참고하기 때문에

```json
{
  "type": "module"
}
```

package.json파일을 수정후에 다시 명령어로 node로 파일을 실행하게 되면, 해당 내용이 에러없이 출력되는 것을 확인할 수 있다.

<br>

---

## NPM 기초개념

![](https://velog.velcdn.com/images/ninto_2/post/9b01fd1f-de1f-4100-98e7-5adcd1c74bf4/image.png)

- Node Package Manager (NPM)

자바스크립트로 어떠한 애플리케이션을 개발할 때 다양한 모듈이 필요하다.
NPM은 이러한 모듈을 쉽게 다운받을 수 있도록 해주는 도구이다.

예를 들어, 애플리케이션에 날짜를 표시한다고 가정을 해보자.

```js
const getToday = () => {
  const today = new Date();
  const year = today.getFullYear();
  const month = today.getMonth() + 1;
  const date = today.getData();

  return `${year}년 ${month}월 ${date}일`;
};
console.log(getToday());
```

자바스크립트로 위와 같이 코딩을 함으로써 표현할 수 있다.
하지만 보다 더 세부적인 조건의 시간과 초가 추가 된다면, 코드는 더 길어지게 되고 복잡해지게 된다.
이렇듯, 다양한 포맷이 요구된다면 그 복잡도는 더더욱 증가하게 된다.
그리고 매번 프로젝트를 진행할 때마다 같은 코드를 반복해야 한다면 매우 비효율적이게 된다.

![](https://velog.velcdn.com/images/ninto_2/post/64751ec8-ca70-4734-80b6-159fb2f02483/image.png)

그래서 자주 사용하는 이러한 기능을 모듈화 한 후 모듈을 다른 프로젝트에서 다운받아 편하게 사용할 수 있도록 모듈 저장소라는 공간에 공유를 하는 것이다.

이러한 모듈을 쉽게 다운받을 수 있도록 도와주는 도구가 바로 `npm`(Node Package Manager)이다.

`npm install 모듈명`

npm을 사용하려면 기본적으로 먼저 설치를 진행해야 한다.
npm은 기본적으로 Node.js 설치 시 자동으로 설치가 된다. (따라서 npm을 사용하기 위해서는 Node.js를 설치해야 한다.)

- Node.js : Chrome V8 JavaScript 엔진으로 빌드된 자바스크립트 런타임이다.

자바스크립트를 웹 브라우저에서 실행하게 되면 웹 애플리케이션이 되는 것이고, 자바스크립트를 Node.js환경에서 실행하게 되면 이것은 백엔드 애플리케이션이다.

Node설치는 운영환경에서는 안정화된 환경을 설치하는 것이 좋다.

설치가 잘 되었는지 확인하는 방법은 터미널에서 아래와 같은 명령어를 입력하면 된다.
(VS 코드 툴에서도 명령어는 동일)

```
node -v // 노드 버전이 출력됨
npm -v // npm 버전이 출력됨
```

날짜 모듈을 다운받을 때는 `npm install dayjs` 이나 `npm i dayjs`

```json
// package.json

{
  "name": "learn_npm",
  "version": "1.0.0",
  "dependencies": {
    "dayjs": "^1.10.8"
  } // npm install dayjs 입력하면 node_modules라는 폴더와 함께 package-lock.json자동으로 추가됨
}
```

- `npmjs.com` : npm 라이브러리를 공유해 놓은 사이트

해당 사이트에 가서 라이브러리를 검색하면 install 명령어와 함께 깃허브 레파지토리, 홈페이지, 다운로드 수, 버전 등 다양한 정보를 확인할 수 있다.

라이브러리를 설치한 후에 해당 라이브러리 홈페이지에서 사용법을 확인할 수 있는데, 다양한 사용법 포맷 방법이 나와있다.

```js
// index.js
const dayjs = require("dayjs");
console.log(dayjs("2013-02-04").format("[YYYYescape] YYYY-MM-DDTHH:mm:ssZ[Z]"));
console.log(dayjs().format("YYYY-MM-DD")); // 오늘 날짜로 잘 출력됨
// node에서 실행 - node index.js
```

`require`를 해서 모듈로 가져올 때 입력을 하게 되면, node_modules 디렉토리를 참고해서 다운로드 받은 라이브러리가 있는 것을 확인할 수 있고, `require`를 해서 접근을 하게 되면, default로 node_modules 디렉토리를 참고한다.

**package.json**

package.json 파일은 프로젝트에 대한 정보를 갖고 있는 파일이다.
그리고 `dependencies`와 같은 속성을 활용하여 프로젝트에 의존된 라이브러리를 관리한다.
package.json 파일은 직접 작성할 수 도 있고, `npm init`명령어를 통하여 자동으로 생성할 수 있다.

**package.json 파일 만들기**

```
npm init
//
package name
version
description
...
// 기본적으로 default 설정으로 enter키를 눌러주면 package.json 파일이 생성된다.
```

package.json파일은 npm으로 프로젝트를 관리할 때 반드시 필요한 필수 파일이다.

- **name**: 프로젝트 이름으로 가장 중요함 (필수항목)
- **version**: 프로젝트 버전을 정의함. 주로 3단계 버전을 사용한다. (필수항목) - ex. 1.0.0
- **description**: 프로젝트 설명을 기술함. npm search로 검색된 리스트에 표시되기 때문에 사람들이 패키지를 찾아내고 이해하는데 도움이 된다.
- **keywords**: 프로젝트를 검색할 때 참조되는 키워드. description과 마찬가지로 npm search로 검색된 리스트에 표시된다.
- **private**: true로 설정되면 npm 게시를 거부함. 이 값은 개인 레포지토리가 실수로 게시되는 것을 방지한다.
  (한마디로 이 소스를 공유하지 않겠다는 의미)
- **main**: main은 프로그램의 기본 진입점임.
- **scripts**: 프로젝트에서 자주 실행하는 명령어를 scripts로 작성해두면 npm 명령어로 실행 가능하다.
- **author**: 제작자의 이름을 지정함.
- **license**: 패키지에 대한 라이센스를 지정하여 사람들이 패키지를 사용할 수 있는 방법과 패키지에 대한 제한사항을 알 수 있도록 해야 함.
- **dependencies**: 프로젝트에서 사용하는(의존하는)모듈을 기술하는 부분임. 따라서 이 프로젝트가 어떤 모듈을 사용하는지 한 눈에 볼 수 있다. 애플리케션을 설치할 때 이 내용을 참조하여 필요한 확장 모듈을 자동으로 설치한다. 따라서 개발한 애플리케이션에서 사용하는 모듈은 여기에 꼭 명시를 해주어야 한다. (중요)
- **devDependencies**: 개발할 때만 의존하는 모듈을 관리한다. (중요)

```json
// package.json

{
  "name": "learn_npm",
  "version": "1.0.0",
  "description": "npm 실습 프로젝트",
  "main": "index.js",
  "scripts": {
    "start": "echo hello hello hello hello",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "dayjs": "^1.10.8"
  }
}
```

```
npm run test // scripts안에 test 키를 입력하게 되면 뒤에 있는 문이 실행된다.
echo hello // 'hello' - 터미널에 입력한 명령어를 출력하는 명령어
npm run start // scripts안에 start 키의 문을 실행 - npm start 로도 실행가능
```

`start`나 `test`같은 명령어들은 프로젝트를 빌드할 때 자주 사용되는 명령어 이므로 잘 알아두어야 한다.
`dependencies`와 `devDependencies`는 예를들어 A,B,C,D,E라는 모듈이 있다고 가정했을 때, E라는 모듈은 개발할 때만 필요하고 실제로 운영할 때는 필요없는 모듈이라고 한다면 굳이 E라는 모듈까지 배포할 필요는 없기 때문에 그때 E라는 모듈이 `devDependencies`에 들어가게 된다. 나머지 A,B,C,D모듈은 `dependencies` 속성에 기술된다.

같은 날짜 라이브러리인 `moment`를 설치해보자.

```
npm i moment
npm install --save-dev nodemon // 해당 라이브러리는 devDependencies에 기술하기 때문에 다음과 같은 명령어를 앞에 입력해준다.
```

```json
// package.json

{
  "name": "learn_npm",
  "version": "1.0.0",
  "description": "npm 실습 프로젝트",
  "main": "index.js",
  "scripts": {
    "start": "echo hello hello hello hello",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    // 운영, 배포할 때 필요한 라이브러리
    "dayjs": "^1.10.8",
    "moment": "^2.29.1"
  },
  "devDependencies": {
    "nodemon": "^2.0.15" // 개발할 때 필요한 라이브러리
  }
}
```

이런식으로 개발과 운영시에 필요한 라이브러리를 나눌 수 있다.
속성은 위에서 살펴본 속성들 말고도 다양한 속성이 있다. (더 알고싶다면 `package.json docs`사이트에 가서 확인)

**node_modules**

node_modules 디렉토리에는 `package.json`에 설치된 모듈 뿐만 아니라, package.json에 있는 모듈이 의존하고 있는 `package-lock.json` 모듈 전부가 설치된 디렉토리이다.
(즉, 우리가 사용할 라이브러리들이 실제로 설치된 경로폴더)

위에서 실제로 설치한 라이브러리는 총 3개 였지만 node_modules 폴더에는 엄청나게 많은 라이브러리들이 설치되어 있다.

**package-lock.json**

프로젝트에 설치된 **모듈들의 의존성 트리를 기록**하고 있으며, `package-lock.json` 파일을 참고하여 `node_modules`디렉토리안에 모듈을 다운받는다.

예를들어, A라는 프로젝트를 개발하려고 할 때 a와 b라는 라이브러리가 필요하다고 가정해보자.
그런데 b라는 라이브러리에서는 b-1, b-2 라는 또 다른 라이브러리를 사용하고 있다.
마찬가지로 b-2라는 라이브러리에서도 c-1, c-2, c-3라는 라이브러리를 사용할 수 있다고 할 때 이렇듯, 라이브러리들 간에는 의존 관계를 가지고 있다.
(의존관계이기 때문에 반드시 모든 라이브러리를 가지고 있어야 한다.)
따라서, 이러한 의존관계성을 가지고 있는 라이브러리들의 정보를 package-lock.json라고 볼 수 있다.
(package-lock.json파일에 들어가서 require로 검색해보면 의존성 라이브러리들을 확인할 수 있다. - 따라서 node_modules폴더에 굉장히 많은 라이브러리들이 같이 설치된 것임)

**npm 명령어**

| 명령어                              | 설명                                                                                                  |
| :---------------------------------- | :---------------------------------------------------------------------------------------------------- |
| npm init                            | 새로운 프로젝트(패키지)를 시작할 때 사용하는 명령어로 package.json 파일을 생성한다.                   |
| npm init -y                         | -y 옵션을 사용하여 기본값을 자동으로 설정할 수 있다.                                                  |
| npm install <패키지명>(축약 i)      | 패키지(= 라이브러리, 모듈)를 설치하는 명령어 이다.(로컬 설치)                                         |
| npm install <패키지명@버전>         | 버전과 함께 사용하면 특정 버전을 설치할 수 있다.                                                      |
| npm install --save 축약 -S          | --save 옵션을 사용하면 dependencies에 추가된다. (npm@5 버전 이후부터는 디폴트로 --save 옵션이 적용됨) |
| npm install --save-dev 축약 -D      | 사용하면 devDependencies에 추가된다.                                                                  |
| npm install <패키지명1> <패키지명2> | 여러개의 설치를 할 수 있다. (공백을 이용해 여러개 설치 가능)                                          |
| npm install -g <패키지명>           | 전역설치를 할 수 있다. (또는 --global)                                                                |
| npm install                         | package.json에 설정된 모든 패키지를 설치한다.                                                         |
| npm install --production            | package.json에 설정된 모든 패키지를 설치하지만 devDependencies는 제외한다.                            |
| npm uninstall <패키지명>            | 로컬 패키지 삭제                                                                                      |
| npm uninstall -g <패키지명>         | 전역 패키지 삭제                                                                                      |
| npm update <패키지명>               | 설치한 패키지를 업데이트 한다.                                                                        |
| npm root                            | 로컬 패키지 설치 디렉토리 확인 (절대 경로 확인가능)                                                   |
| npm root -g                         | 전역 패키지 설치 디렉토리 확인 (전역으로 설치된 절대 경로 확인가능)                                   |
| npm ls                              | 로컬 설치된 패키지 확인 (설치된 모듈을 확인가능)                                                      |
| npm ls --depth=2                    | 2뎁스 까지의 의존성 모듈을 모두 확인할 수 있음                                                        |
| npm ls -g                           | 전역으로 어떠한 모듈이 설치되어 있는지 확인가능                                                       |
| npm start                           | package.json 파일의 script 속성의 start 실행                                                          |
| npm run <script-name>               | package.json 파일의 script 속성의 start의 스크립트 실행                                               |

자주 사용하는 패키지를 전역으로 설치하기 위해서는 관리자 권한이 필요하다.
맥OS같은 경우는 `sudo npm install -g 패키지명` 을 입력하고, 윈도우 같은 경우는 해당 터미널에서 우클릭을 하여 관리자 권한을 허용하면 해결 된다.
전역 설치된 패키지는 어디에서든지 접근이 가능하다.

한 가지 팁으로 package.json파일의 scripts 에서 접근을 설정할 수 있다.

```json
"scripts": {
  "start":"nodemon index.js", // nodemon이라는 라이브러리를 간단하게 접근할 수 있도록 설정
}
```

`npm run start`또는 `npm start` 로 접근하게 되면 실행이 됨.

만약 이 소스를 깃허브 저장소나 소스 파일을 옮기고 싶을 때, node_modules폴더에는 엄청나게 많은 라이브러리들이 있기 때문에 이 모든 라이브러리들을 복사해서 옮겨놓거나 저장해놓게 되면 매우 비효율적일 수 있다.
따라서 소스를 옮길 때에는 node_modules는 옮기지 않아도 된다. (node_modules폴더 삭제)

만약 모듈을 다시 설치하고 싶다면, `npm install` 명령어만 입력하면 된다.
그러면 자동으로 `dependencies`와 `devDependencies`를 참고해서 자동으로 다시 설치를 한다. (node_modules폴더가 다시 생성됨)

만약에 의존되는 모듈의 버전이 꼬였거나, 이런 에러가 발생했다면 node_modules와 package-lack.json 파일을 삭제하고 다시 `npm install`해주면 된다.

그리고 운영환경에 배포할 때 devDependencies에 들어있는 라이브러리는 배포를 하면 안된다.
그럴때 설치하는 방법은 `npm install --production`을 주면 devDependencies의 모듈을 제외한 dependencies의 모듈만 설치를 한다.

```
// 맥OS에서 패키지 업데이트 하는 방법
sudo npm i -g nodemon // nodemon 패키지를 전역으로 설치
nodemon -v // 2.0.15 버전 정보가 표시됨
sudo npm i -g nodemon@2.0.14 //만약 2.0.14버전으로 재설치
sudo npm update -g nodemon // 해당 패키지 버전 업데이트
```

npm 명령어의 경우 종류가 굉장히 많으며, 이 모든 명령어들을 외울 필요는 없다.
프로젝트를 생성 후 `npm init`를 해서 package.json 파일을 생성한 뒤 원하는 모듈을 `npm install`로 설치하면 된다. 그리고 필요없는 모듈은 `npm uninstall`로 제거하면 된다.
그런뒤 script 명령어를 실행해서 서버를 빌드하거나 이러한 작업을 수행하면 된다.
나머지는 필요할 때 그때그때 검색을 하여 자연스럽게 익숙해지도록 하자.

**전역설치와 지역설치**

- 시스템 상에서 해당 라이브러리의 명령어를 인식하게끔 설정하기 위해서 전역 설치를 한다. (ex. vue-cli)
- 프로젝트에서 사용할 라이브러리는 지역설치
- 시스템 레벨에서 사용할 자바스크립트 라이브러리(해당 라이브러리명을 명령어로 인식)는 전역설치

```
npm install -g nodemon // nodemon이라는 패키지를 전역설치
```

> 유닉스 리눅스 맥OS에서 관리자 권한으로 실행은 명령어 앞에 `subo`를 붙이고, 윈도우에서는 cmd를 실행할 때 마우스 우클릭 후 `관리자 권한으로 실행`을 클릭해서 명령어를 입력한다.

**버전**

기본적으로 버전은 `[MAJOR , MINOR, PATCH]`로 구성되어 있다.
이러한 표기법은 시맨틱 버저닝(Semantic Versioning)규칙을 따르고 있다.
`package.json`에 버전 명시를 다음과 같이 할 수 있다.
`1.2.3` `> 1.2.3` `>=1.2.3` `<1.2.3` `<=1.2.3` `~1.2.3` `^1.2.3`

**시맨틱 버저닝(Semantic Versioning)**

시맨틱 버저닝은 소프트웨어의 버전 변경 규칙에 대한 제안이다.
`[MAJOR , MINOR, PATCH]` (ex.1.0.2)

- MAJOR(메이저): 주요변화, 기존 API 추가/변경/삭제 등, 이전 버전과 호환이 안 될 수 있음
  (소프트웨어의 큰 변경이 있을 경우 메이저버전을 변경 후 배포한다.)
- MINOR(마이너): **기능**추가, 이전 버전과 호환됨
- PATCH(패치): **버그**수정, 이전 버전과 호환됨

**틸드(~)**
틸드는 현재 지정한 버전의 마지막 자리 내의 범위에서만 자동으로 업데이트 한다.

- `~0.0.1` : `>=0.0.1 <0.1.0`
- `~0.1.1`: `>=0.1.1 <0.2.0`
- `~0.1`: `>=0.1.0 <0.2.0`
- `~0`: `>=0.0 <1.0`

<br>

---

## Webpack (웹팩)

웹팩에 대해 알기전에 모듈에 대해서 알고 있어야한다.
우리가 자바스크립트를 이용해서 개발을 하다보면 코드의 유지보수 측면에서 파일을 여러개로 분리해서 개발을 하곤 한다.
이렇게 분리된 파일을 모듈이라고 한다.
자바스크립트 코드를 모듈로 분리하게 되면 이러한 모듈을 필요한 어떤 곳에서든 재사용이 가능하기 때문에 자주 사용하는 코드같은 경우에는 모듈로 분리해서 개발을 하는 것이다.

![](https://velog.velcdn.com/images/ninto_2/post/a24d1358-3f5d-4eb0-a505-e4dfbb99f141/image.png)

이런식으로 웹 애플리케이션이 완선이 되면, 웹서버에 배포를 하게 되고 사용자들이 브라우저를 통해 웹사이트에 접근을 하게되면
브라우저는 사용자들에게 UI를 보여주기 위해 웹서버에 파일과 같은 자원을 요청한다.
그리고 웹서버는 준비된 자원을 브라우저에게 응답함으로써 사용자들은 UI를 볼 수 있게 된다.

하지만 개발 편의성을 위해 모듈을 계속해서 분리하다보면 그만큼 브라우저에서 서버에게 요청하는 개수가 많아지고,
이러한 네트워크 비용의 증가는 페이지 로딩 시간을 길어지게 함으로써 UX에 좋지 않은 경험을 발생시킬 수 있다.

그러면 개발 편의를 위해 모듈로 분리해서 개발을 하고, 페이지 로딩시간을 줄일 수 있는 방법이 없을까?

그 방법은 바로 서버에게 요청하는 HTTP 요청의 개수를 줄이는 것이다.
개발을 할 때에는 모듈로 나누어서 개발을 진행하고, 웹서버에 배포하기 전에 이러한 모듈들을 하나의 파일로 묶어서 배포하는 방식이다.
이렇게 되면 그만큼 서버로 요청하는 개수가 줄어들기 때문에 UX를 향상시킬 수 있다.

![](https://velog.velcdn.com/images/ninto_2/post/8c6adc98-35d6-4ca9-bc63-8b944857fad0/image.png)

이렇게 하나로 묶는 작업을 **번들링**이라고 하며, 여러개의 파일을 하나로 묶어주는 도구를 **모듈 번들러** 라고한다.

![](https://velog.velcdn.com/images/ninto_2/post/001b1dca-115d-4f45-87a3-a9ca2a563525/image.png)

모듈 번들러의 종류는 다양하지만, 프론트엔드에서 가장 많이 사용되는 모듈 번들러가 바로 **웹팩(Webpack)**이다.
다시 정리하자면, 웹팩이란 여러개의 파일들을 하나로 묶어주는 모듈 번들러이다.
주로 자바스크립트 파일을 위한 모듈 번들러이지만 위 그림과 같이 플러그인을 포함하는 경우 자바스크립트 뿐만 아니라 HTML,CSS,이미지와 같은 자원들도 변환할 수 있다.

**웹팩이 있기 전**

```js
// a.js
var number = 10;
```

```js
// b.js
var number = 20;
```

```js
// c.js
var number = 30;
```

```html
<!--index.html-->
<script src="./a.js"></script>
<script src="./b.js"></script>
<script src="./c.js"></script>
<script>
  console.log(number); // 마지막 script가 된 c파일의 30이 출력됨
</script>
```

위와 같은 문제를 해결하기 위해 모듈 시스템이 탄생했고, ES6에서 추가된 문법으로 가져올 수 있다.

```js
// a.js
var number = 10;
export default number;
```

```js
// b.js
var number = 20;
export default number;
```

```js
// c.js
var number = 30;
export default number;
```

```html
<!--index.html-->
<script type="module">
  import a_number from "./a.js";
  import b_number from "./b.js";
  import c_number from "./c.js";
  console.log(a_number, b_number, c_number); // 10 20 30
</script>
```

![](https://velog.velcdn.com/images/ninto_2/post/ae44d2a5-a827-4beb-95d7-084151eca70b/image.png)

모듈로 연결을 하면 HTML파일에서 잘 불러올 수 있지만, Network창을 확인해보면 현재 모듈을 3개 불러왔기 때문에, 브라우저에서 3개의 모듈을 확인할 수 있다.
하지만 모듈이 많아지게 된다면 비효율적이게 된다.

```js
//a-1.js
var number = 100;
export default number;
```

```js
//a-2.js
var number = 200;
export default number;
```

```js
// a.js
import number1 from "./a-1.js";
import number2 from "./a-2.js";

var number = number1 + number2;
export default number;
```

![](https://velog.velcdn.com/images/ninto_2/post/c89e2d78-12a2-42b6-b9a1-5f8cbf72439a/image.png)

HTML에서는 3개의 모듈을 사용했지만, Network창에서는 a-1.js와 a-2.js 파일이 추가된 것을 확인할 수 있다.
이렇게 모듈이 점점 증가하게 되면 비효율적인 이유가 모듈을 클릭해서 Timing을 살펴보면 이러한 컨텐츠를 가져오는 총 시간을 나타내는 탭이라고 보면 된다.
이런 컨텐츠를 요청하고 커넥션하는 시간은 컨텐츠 마다 계속 소비되는 시간이기 때문이다.

그렇기 때문에 위와 같은 컨텐츠를 하나의 컨텐츠로 가져올 수 있다면, 불필요하게 낭비되는 시간을 줄일 수 있다.
그러면 이번에는 웹팩을 사용해서 여러개의 파일을 하나로 묶어서 HTTP 요청을 줄여보도록 하자.

먼저 소스 폴더를 만든 뒤 모듈들을 소스 폴더에 넣어준다.

```js
// src 폴더의 index.js

import a_number from "./a.js";
import b_number from "./b.js";
import c_number from "./c.js";
console.log(a_number, b_number, c_number);

const $buttonA = document.querySelector("#button-a");
const $buttonB = document.querySelector("#button-b");
const $buttonC = document.querySelector("#button-c");
const $dispaly = document.querySelector("#display");

$buttonA.addEventListener("click", function () {
  $dispaly.textContent = a_number;
});
$buttonB.addEventListener("click", function () {
  $dispaly.textContent = b_number;
});
$buttonC.addEventListener("click", function () {
  $dispaly.textContent = c_number;
});
```

웹팩으로 번들링하기 전에 간단한 기능을 추가해보자.

```html
<script type="module" src="./src/index.js"></script>
<body>
  <button type="button" id="button-a">a_number</button>
  <button type="button" id="button-b">b_number</button>
  <button type="button" id="button-c">c_number</button>
  <div id="display"></div>
</body>
```

위 기능은 각각의 버튼을 클릭했을때 해당하는 number값을 div위치에 출력시키는 기능이다.

웹팩을 설치하기 이전에는 위 프로젝트가 npm에 의해 관리가 되어야 한다.

```
// package.json 파일 생성하기
npm init -y

// webpack과  webpack-cli를 로컬 환경에 설치하기
npm install --save-dev webpack webpack-cli
```

웹팩같은 경우 운영환경에 배포될 일이 없기 때문에, devDependencies에 추가될 수 있도록 `--save-dev`를 붙여준다.
로컬환경에 설치된 cli 명령어를 사용하기 위해서는 `npx` 명령어를 이용해서 실행 해야한다.

- dist 폴더 추가 생성

```
// entry는 웹팩의 진입점이다 (어떠한 파일을 기준으로 번들링할 것인지 설정- 뒤에 번들링을 할 진입점 파일경로를 써준다.)
// output은 디렉토리 하나를 생성한 다음 그 디렉토리안에 번들링을 할 파일을 생성하도록 설정해준다.
// 참고로 mode development를 적용하게 되면 압축없이 main.js가 생성된다.
npx webpack --entry ./src/index.js --output-path ./dist --mode development
```

위와 같이 사용하면, 해당 파일을 기준으로 사용하고 있는 모듈과 그 모듈안에서 사용하고 있는 모듈들까지 모두 계속해서 추적해 나간다.
output에 폴더를 입력해주면, 해당 폴더 안에 main.js가 생성된 것을 볼 수 있다.

번들링을 할 때 기본적으로 production이 적용되었기 때문에 띄어쓰기 없이 압축되어 파일이 생성된 것을 확인할 수 있다.

```html
<script type="module" src="./dist/main.js"></script>
<body>
  <button type="button" id="button-a">a_number</button>
  <button type="button" id="button-b">b_number</button>
  <button type="button" id="button-c">c_number</button>
  <div id="display"></div>
</body>
```

HTML파일안에서는 script로 웹팩에서 생성한 main.js를 src해준다.

![](https://velog.velcdn.com/images/ninto_2/post/62b3499b-97ac-4975-ab9c-236ae1fc1155/image.png)

이렇게 되면, 그 전과는 다르게 Network를 확인했을때 main.js 파일 하나만 HTTP 요청을 보낸 것을 확인할 수 있다. (시간도 이전과 절반정도 차이가 남)
그리고 그 전과 동일하게 기능은 똑같이 동작하고 있다.
즉, 웹팩을 사용하게 되면 실제 운영환경에서는 엄청난 성능향상 차이를 경험할 수 있다.

**웹팩의 환경설정 파일을 적용해서 사용**

```js
// webpack.config.js
const path = require("path");

// 여기에서 node를 지정해줄 수 있다.
module.exports = {
  node: "production", // 혹은 development
  entry: "./src/index.js",
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "bundle.js",
  },
};
```

웹팩을 사용할 때 기본적으로 `webpack.config.js`을 참조하기 때문에, webpack홈페이지에서 가져온 코드를 해당 파일에 붙여넣는다.
entry는 진입점을 설정하는 속성이고, output은 번들링 파일이 위치할 파일 path, 파일명을 지정해주면 된다.
위처럼 파일을 작성한 뒤 npx webpack으로 바로 진입을 해보자.

```
npx webpack
```

그러면, webpack.config.js를 참고해서 dist 폴더에 'bundle.js' 파일을 생성함

```html
<script type="module" src="./dist/bundle.js"></script>
<body>
  <button type="button" id="button-a">a_number</button>
  <button type="button" id="button-b">b_number</button>
  <button type="button" id="button-c">c_number</button>
  <div id="display"></div>
</body>
```

이렇게 번들링하는 명령어는 자주 사용하는 명령어이기 때문에 package.json 파일에 scripts에 빌드 명령어로 추가를 해놓는다.

```json
"scripts": {
  "test": "echo \"Error: no test specified\" && exit 1",
  "build": "webpack", // 로컬 환경에 설치해놓았기 때문에 바로 webpack 명령어 실행이 가능
}
```

```
npm run build
```

위와 같이 명령어를 추가해주면 dist폴더에 bundle.js파일이 잘 생성되는 것을 확인할 수 있다.

![](https://velog.velcdn.com/images/ninto_2/post/c8eb742c-bfde-43e5-a954-9a9aad60212b/image.png)

이렇게 웹팩은 배포하기 전에 번들링해주는 도구이다.
우리가 개발 편의성이나 재사용, 유지보수 측면에서 소스를 모듈별로 분리해서 개발을 한다.
그리고 배포할 때에는 이 dist폴더에 번들링을 한 다음에 bundle.js파일만 배포를 하는 것이다.

이렇게 되면, src폴더 안과 그 아래에 있는 파일들은 배포할 필요가 없고 dist폴더에 있는 bundle.js파일과 index.html파일만 배포를 하면된다.
그리고 웹팩은 자바스크립트 파일 뿐만 아니라 이미지, CSS 등 다양한 데이터를 변환할 수 있다.

정리하자면 웹팩은 여러개의 파일들을 하나의 파일로 묶어주는 모듈 번들러이다.
이러한 모듈 번들러는 프론트엔드에서 서버로 요청할 때, HTTP 요청 개수를 줄여줌으로서 퍼포먼스를 확장을 하고
공백과 같은 것들을 줄임으로써 리소스를 최적화한다.
그렇기 때문에 이러한 모듈번들러를 사용하면 사용자 경험이 더 좋아질 수 있다.
