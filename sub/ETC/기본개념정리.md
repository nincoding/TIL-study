## DOM이란?

자바스크립트의 탄생 배경
자바스크립트는 Web 문서를 제어하기 위해 개발된 언어이다.
정적인 web에서 요소의 content를 변경한다거나, 추가하거나 제거하는 등
HTML문서를 조작하기 위해 만들어졌다.

HTML파일을 자바스크립트 제어할 수 있는 원리는 무엇일까?
브라우저안에는 웹 문서를 해석할 수 있는 랜더링 엔진이 존재한다.
브라우저에서 HTML파일을 열게되면 랜더링 엔진이 한 줄 한 줄 해석한다.
그리고 해석이 끝나면 HTML문서를 객체화하여 자바스크립트로 접근할 수 있도록 한다.

문서를 객체화 하였다고 해서 **문서 객체 모델 (Document Object Model) DOM** 이라고 표현한다.
Script언어로 HTML요소를 제어할 수 있도록 웹 문서를 객체화 한 것을 말한다.

![](https://velog.velcdn.com/images/ninto_2/post/df00501c-6cbc-4f8f-be0c-2e5229e2d8fd/image.png)

이 DOM은 Tree구조를 가지고 있다.
HTML문서를 자세히 살펴보면, 안에 head태그와 body태그를 가지고 있다.
또, body태그 안에는 h1, p, div, ul, li 등의 다양한 태그들이 들어갈 수 있다.

이렇듯 HTML요소는 하나의 부모 태그와 n개의 자식 태그를 가질 수 있다. (DOM트리 형태)
위 그림에서 각각의 요소를 노드라고 한다.
각각의 요소인 노드에 접근해서 웹 문서를 조작할 수 있게 된다. (1.접근 2.제어)

Web문서를 객체화한 것을 DOM이라고 했다면, 브라우저 자체를 제어할 수 있도록 모델링 한 것을
Browser Object Model(브라우저 객체 모델)이라고 한다.
또, CSS를 자바스크립트로 조작할 수 있도록 한 것은 CSS Object Model (CSSOM)이다.

BOM에는 브라우저 영역을 제어할 수 있도록 제공하는 `document` 객체가 있다.
`document` 객체는 DOM Tree의 최상위에 위치하며 최상위 노드이다.
즉, 이 `document` 최상위 노드로 먼저 접근하여 원하는 요소에 접근이 가능해진다. (DOM 요소에 접근하기 위한 진입점)

**노드에 접근**

```js
// HTML 브라우저 콘솔창에
document.getRootNode(); // document - 최상위 노드를 반환
document.childNodes; // [<!DOCTYPE html>, html] 그 다음 하위 노드를 반환
document.childNodes[1]; // html로 접근
document.childNodes[1].childNodes[2]; // body - 이런식으로 연속적으로 childNodes를 이용해서 접근이 가능하다.
document.childNodes[1].childNodes[2].childNodes[1].textContent = "제목"; // h1 - textContent로 수정 가능
```

`document` 객체의 위와 같은 방식으로 DOM객체에 접근해서 DOM객체에서 지원하는 `textContent`와 같은 프로퍼티로 제어가 가능하다.

하지만 위 방식보다 더 쉽게 접근할 수 있는 코드가 있다.

```js
let domObj = document.querySelector("h1"); //querySelector괄호안에 접근하고 싶은 노드요소를 입력합니다.

domObj.textContent = "변경";
```

이렇듯, DOM은 문서 객체 모델로 브라우저에서 자바스크립트 요소로 html요소를 제어할 수 있도록,
제공하는 API이다.

이 API는 자바스크립트 언어 자체가 아니다. (브라우저에서 제공하는 기능같은 것)

<br>

---

## BOM이란?

Browser Object Model(브라우저 객체 모델)이란 것은 말 그대로 Web 브라우저를 객체화 한 것을 의미한다.
객체화를 한 이유는 브라우저 언어를 Script로 제어하기 위해서 이다.
우리가 마우스라는 H/W 인터페이스를 통해서 브라우저의 새 탭을 열 수 도, 주소창에 특정 주소를 입력함으로써 Web 문서를 이동할 수 도 있다.
이렇듯, 마우스로 브라우저의 기능을 이용했던 것 처럼 이 브라우저를 객체화 함으로써 자바스크립트로도 제어가 가능한 것이다.

즉, BOM을 브라우저를 제어하기 위한 인터페이스 라고도 말한다.

그렇다면 브라우저 객체에는 어떤 것들이 있고, 기능은 무엇일까?

**Brower 객체**

- `window` : 모든 객체가 소속된 객체이며, 브라우저 창 자체를 의미합니다.
- `document` : 현재 문서에 대한 정보를 가지고 있는 객체입니다.
- `history` : 현재의 브라우저가 접근했던 URL history를 제어할 수 있습니다.
- `location` : 문서의 주소와 관련된 객체, window 객체의 프로퍼티인 동시에 document의 프로퍼티이다.
  이 객체를 이용하여 윈도우의 문서 URL을 변경할 수 있고, 문서의 위치와 관련해서 다양한 정보를 얻을 수 있다.
- `screen` : 사용자의 디스플레이 화면에 대한 다양한 정보를 갖고 있는 객체이다.
- `navigator` : 실행중인 애플리케이션(브라우저)에 대한 정보를 알 수 있다.
  (크로스 브라우징 이슈를 해결할 때 사용가능하다. ex. Chrome -> addEventListener, IE -> attachEvent)
  - `navigator.geolocation.getCurrentPosition()` : 현재 애플리케이션에 대한 위치 정보
    (`navigator`에 `geolocation`라는 멤버변수에 `getCurrentPosition()`메서드를 통해 현재 위치정보를 가져올 수 있다.)
  - `navigator.appName` : 앱(브라우저) 이름을 반환한다.
  - `navigator.appVersion` : 앱(브라우저)에 대한 버전 정보를 반환한다.
  - `navigator.userAgent` : 서버에 요청할 때 앱(브라우저)에 대한 정보이다.

브라우저 객체에는 위 와 같은 객체들이 존재한다.

```js
// 만약 브라우저창에서 새 탭을 열고 싶다면 콘솔창에
window.open("홈페이지 주소"); // 해당 주소의 새 탭이 open됨. open('주소') === window.open()
window.close(); // 탭이 닫힘
alert("경고창"); // alert은 window가 가지고 있는 메서드이다. alert() === window.alert()
```

window의 특징으로는 모든 객체가 소속된 객체이지만, 앞에 window 생략이 가능하다.
HTML Web문서는 브라우저에 의해 해석되면서 DOM트리로 변환되고, `document`는 이러한 정보를 가지고 있다.
그래서 `document`객체에서 제공하는 메서드로 다양한 DOM요소를 가져올 수 있다.

```js
document.querySelector("#custom-id"); //괄호안에 해당 태그의 CSS 선택자를 넣으면 해당 태그를 가져옴
document.querySelector("#custom-id").textContent = "원하는 텍스트 변경";

document === window.document; // window는 생략 가능하므로 타이핑 줄이기 위해 대체로 생략함
```

이 `document`객체도 객체기 때문에 `window` 객체에 소속된 객체이다.

`history`기능은 브라우저 상에 보이는 '뒤로가기', '앞으로 가기' 기능이라고 생각해도 좋다.
만약 뒤로가기 기능을 `history`객체를 통해 표현하고 싶다면,

```js
history.back(); // 뒤로가짐
history.forward(); //앞으로가짐
```

`location`은 window 객체의 프로퍼티인 동시에 document의 프로퍼티 이므로 `location`으로 바로 사용할 수 있지만,
`window.location`, `document.location`으로도 사용이 가능하다. (= 같은 의미를 가진다.)

```js
// Web 브라우저 console창에 아래의 코드를 입력하면
location.host; // 'www.naver.com' - 해당 홈페이지의 host를 가져옴
location.href = "https://google.com"; // href프로퍼티를 통해 웹문서의 주소를 변경할 수 있음
```

이렇듯, `location`객체는 Web문서 URL에 대한 정보를 가지고 있다고 보면 된다.

사용자의 디스플레이 화면은 스마트폰, 데스크탑 모니터 등 다양한 디스플레이가 될 수 있다.

```js
// 브라우저 console 창에

console.log("text출력"); // 'text출력'
console.dir(screen); // dir을 사용하면 해당 객체에 대한 정보를 볼 수 있다.
/*
// 아래와 같이 현재 디스플레이 정보를 자세히 살펴 볼 수 있다.
availHeight: 1638
availLeft: 0
availTop: 0
availWidth: 1018
colorDepth: 24
height: 1638
isExtended: false
onchange: null
orientation: ScreenOrientation {angle: 0, type: 'portrait-primary', onchange: null}
pixelDepth: 24
width: 1018
[[Prototype]]: Screen
*/
```

사용자 디스플레이에 대한 정보가 필요하다면 `screen`객체를 사용하면 된다.
사용자의 위치 정보가 필요하다면 `navigator`객체의 메서드를 이용해서 가져올 수 있다.
MDN에 검색해보면, 해당 API에 대한 사용법을 알 수 있다.

```js
navigator.geolocation.getCurrentPosition(success, error, [options]); // MDN에 나와있는 사용방법

navigator.geolocation.getCurrentPosition(function success(pos) {
  const crd = pos.coords; // pos는 position 위도, 경도, 좌표의 위치정보를 보내줌

  console.log("Your current position is:");
  console.log(`Latitude : ${crd.latitude}`);
  console.log(`Longitude: ${crd.longitude}`);
  console.log(`More or less ${crd.accuracy} meters.`);
});

// 위치 정보 권한 허용을 누르면 위치 정보를 가져올 수 있다.
```

BOM의 더 자세하고 다양한 속성과 메서드를 알아보기 위해서는 MDN 사이트를 참고하면 도움이 많이 된다.

<br>

---

## load, defer, async

HTML 파일에서 자바스크립트 파일을 가져올 때, 효과적으로 가져올 수 있는 방법에 대해 알아보자.
보통은 `index.html`파일에서 `script`태그를 통해 js파일을 가져올 수 있다.

```html
<!-- index.html 파일 -->
<script src="script.js"></script>
<button id="btn">버튼</button>
```

```js
// script.js 파일
let btn = document.querySelector("#btn"); //버튼에 대한 요소를 선택한 뒤
// addEventListener를 통해서 버튼을 클릭시 이벤트 조작이 가능
console.log(btn); // null - script태그가 html 버튼보다 위에 있기 때문 (script load 문제발생)
btn.addEventListener("click", function () {
  alert("경고!");
});
```

해당 js파일에서 코드를 변경하게 되면, script로 연결된 html파일도 같이 변한다.
하지만 위 코드는 에러가 발생한다. 그 이유는 무엇일까?

브라우저에서는 이 index.html 파일을 만났을 때, 위에서 아래로 순차적으로 코드를 파싱(= 읽는다)한다.
파싱을 하다가 script 태그를 만나면 파싱을 잠시 멈추고 해당 script파일을 가져오게 된다.
그리고 script코드를 실행하게 된다.
그런데 해당 script파일에서는 `document.querySelector`를 이용해 button에 접근을 했지만,
이 버튼은 브라우저에서 해당 html을 파싱한 후에 DOM 요소를 생성하기 때문에 파싱도 하기전에 script파일이 먼저
실행되어서 null로 찾지 못했다는 에러가 발생하게 된 것이다.

**script 로드 해결방법**

과거에는 아래와 같은 2가지 방법으로 문제를 해결했다.

1. body 최하단에서 script태그를 선언하여 로드 (body 종료태그 위에 선언)
   (script태그 위치를 변경함으로서 HTML파싱을 먼저 하는 방법)

```html
<body>
  <button id="btn">버튼</button>
  ...
  <script src="script.js"></script>
  <!-- HTML파싱이 먼저 이루어짐으로 DOM요소에 접근이 가능해짐 -->
</body>
```

버튼 태그를 먼저 파싱 함으로써 script를 불러오기 전에 브라우저에서 생성하게 만들었다.
그 다음에 script를 실행하는 방식.

2. load 관련 이벤트 리스너 등록

`window.onload` : HTML파싱을 다 한 후, DOM을 생성하고 외부 콘텐츠(images, script, css, etc)가 로드된 후 발생하는 이벤트이다.
그래서 `window.onload` 안에 DOM요소를 가져올 수 있도록 코드를 작성했다.

```js
//script.js 파일
window.onload = function () {
  let btn = document.querySelector("#btn");
  btn.addEventListener("click", function () {
    alert("경고!");
  });
};
```

```html
<head>
  <script src="script.js"></script>
</head>
<body>
  <button id="btn">버튼</button>
</body>
```

script를 가져오고, script의 코드가 실행된다. 하지만 `window.onload`안에 있는 이벤트는 아직 실행되지 않은 상태이다.
모든 html을 파싱한 뒤에 실행되는 이벤트이기 때문이다.

하지만 이 `onload`이벤트 같은 경우에는 비효율적일 수 있다.
예를 들어, image를 100개 정도 가져와야 되는 상황에서 onload에 있는 코드를 실행하는데 이미지 100개를 모두 다 가져올 때까지 기다릴 필요는 없다.
그래서 이런 경우에는 document에 있는 `DOMContentLoaded` 이벤트를 사용하는 편이 더 효율적이다.

`DOMContentLoaded` : HTML 파싱 후 DOM 생성 후 발생하는 이벤트 (다시말해, 외부 콘텐츠는 기다리지 않는다.)

```js
//script.js 파일
document.addEventListener("DOMContentLoaded", function () {
  let btn = document.querySelector("#btn");
  btn.addEventListener("click", function () {
    alert("경고!"); // 정상적으로 작동됨
  });
});
```

```html
<head>
  <script src="script.js"></script>
</head>
<body>
  <button id="btn">버튼</button>
</body>
```

`onload`보다 `DOMContentLoaded`가 더 빨리 실행된다.

```js
window.onload = function () {
  alert("onload 경고!");
};
document.addEventListener("DOMContentLoaded", function () {
  alert("DOMContentLoaded 경고!");
}); // 먼저 출력됨
```

![](https://velog.velcdn.com/images/ninto_2/post/7fda839e-b8ba-46a4-bc4f-538ae9bdd3b8/image.png)

script 태그를 head 태그 위에 기본적으로 선언하게 되면, HTML 파싱을 쭉 하다가 Script 태그를 만나면 하던 일을 멈추고
Script fetch가 이루어진다. 그리고 Script 태그를 실행한다. 이 코드가 모두 종료된 후에 다시 HTML 파싱을 시작한다.

이렇게 HTML 파싱이 종료되지 않은 시점에서 Script 태그를 실행하게 되니까 HTML DOM 요소를 가져오지 못하는 상황이 발생하게 된 것이다.

![](https://velog.velcdn.com/images/ninto_2/post/38800598-1e6a-441c-b597-c1a2b76f0e9a/image.png)

하지만, script 태그를 html의 body태그 최하단에 넣게 되면, HTML 파싱을 모두 종료한 후에 Script fetch와 Script 코드 실행이 이루어지므로 정상적으로 HTML파싱 후 DOM 요소가 생성되어 원활하게 접근이 가능해진다.

그렇지만 위와 같은 방법도 단점이 존재한다.
예를들어, HTML 파싱이 모두 완료된 후에야 Script를 실행을 하도록 구현했지만 HTML 파싱을 할 때, Script 파일을 fetch하게 된 다면 더 효율적일 수 있을 것이다.

그래서 HTML5에서 등장한 `defer`와 `async` 속성이 있다.
이 두가지의 속성을 잘 활용하면 자바스크립트 파일을 효과적으로 가져올 수 있게 된다.

**HTML5 script load 해결 방법**

HTML5에서는 `defer`와 `async`속성을 통해 비동기 script 로드가 가능해져서 위와 같은 문제가 근본적으로 해결되었다.

`defer` : HTML 파싱과 함께 비동기로 JavaScript 파일을 불러온다.

```html
<head>
  <!-- 이런식으로 script 태그안에 defer를 붙여주면 HTML파싱이 완료된 후 자바스크립트 코드를 실행하게 된다. -->
  <script src="script.js" defer></script>
</head>
```

HTML 파싱을 하다가 script 태그를 만나면, defer 속성을 사용하기 전에는 HTML 파싱을 멈췄지만 defer 속성을 만나면 HTML 파싱을 그대로 진행하게 된다. 그러면서 동시에 Script fetch가 이루어진다.
(하던 작업을 멈추지 않고 병렬적으로 처리가 가능해짐으로 논블로킹, 비동기 처리가 가능해진다.
반대로 동기는 하던 작업을 멈추고 Script 파일을 가져올 때까지 기다리는 것이다.)
기다리는 시간이 비효율적이기 때문에 비동기로 만들어서 HTML 파싱 처리할 때 Script fetch까지 같이 가져올 수 있도록 구현한 것이다.

![](https://velog.velcdn.com/images/ninto_2/post/bca012c0-8809-44e5-acd9-01a32e5e80f2/image.png)

실행은 HTML 파싱이 끝 난 후에 Script 코드 실행이 이루어지는 방식이다.
(HTML 파싱이 모두 끝나고 DOM 요소가 생성이 된 후이기 때문에 코드 실행이 원활히 이루어지게 된다.)

```html
<!-- 아래와 같은 코드는 에러를 발생시킨다. -->
<head>
  <script src="script.js"></script>
</head>
<body>
  <button id="btn">버튼</button>
</body>
```

HTML 파싱이 모두 완료되기 전에 Script 태그를 fetch하고 실행하는 걸 기다리기 때문에 생성되지 않은 버튼에 접근하려고 하니 에러를 내보낸다.

```html
<!-- 위와 같은 코드에 defer를 붙여주게되면 비동기 fetch가 이루어져 에러가 발생되지 않음 -->
<head>
  <script src="script.js" defer></script>
</head>
<body>
  <button id="btn">버튼</button>
  <!-- 버튼실행도 정상적으로 잘 동작하게 된다. -->
</body>
```

HTML 파싱 중에 Script fetch를 하면서 HTML 파싱이 모두 완료 한 후에 Script 코드를 실행하는 방식이기 때문에 오류없이 원활히 DOM 요소에 접근이 가능해졌다.

defer속성은 HTML 파싱과 함께 비동기로 자바스크립트 파일을 가져오지만, 자바스크립트 코드 실행은 HTML 파싱이 모두 완료된 후에야 이루어진 다는 점에서 `async`와 속도 차이가 생길 수 있다.

`async` : HTML 파싱과 함께 비동기로 JavaScript 파일을 불러온다.
(HTML 파싱이 완료되지 않았더라도 먼저 로딩되는 자바스크립트 파일부터 실행이 시작된다.)

![](https://velog.velcdn.com/images/ninto_2/post/922056d6-d87e-4b79-b632-b42822da1f6f/image.png)

`async` 속성 같은 경우에는 `defer`와 마찬가지로 HTML 파싱을 하면서 Script 태그를 만나게 되면 논블로킹으로 비동기로 잘 fetch하게 된다. 그리고 나서 Script 파일을 실행할 때는 HTML 파싱이 일시적으로 중지되면서 실행을 하게 된다. 그래서 순서에 따라 원활하게 못 가져올 수도 있다.
그렇기에 `async` 같은 경우에는 꼭 필요한 순간에 사용을 해야하며, 일반적으로 Script 파일을 효과적으로 불러올 때는 `defer`속성을 사용하는 것이 안전할 수 있다.

<br>

---

## 자바스크립트의 this

자바스크립트에서 this는 객체를 가리키는 키워드이다. 쉽게 말해서 `this`는 객체이다.
그렇다면 `this`는 과연 어떤 객체를 가리키는 걸까?

가볍게 생각해보자면 `this`는 호출한 객체라고 볼 수 있다.
MDN에서는 this의 값은 대부분의 경우 함수를 호출한 방법에 의해 결정된다고 정의 해놓았다.

```js
console.log(this === window); // true
```

기본적으로 this를 호출한 주체가 없을 경우 기본값으로 `window`객체가 호출한 주체가 된다.

```js
// index.js 파일
const person = {
  name: "foo",
  age: 20,
  printThis: function () {
    console.log(this);
    console.log(this === person); // true
    console.log(this.name); // 'foo'
    console.log(this.age); // 20
  },
};
person.printThis(); // { name: 'foo', age: 20, printThis: f }
```

```html
<script src="index.js" defer></script>
```

이렇게 this는 person인걸 알 수 있다. 즉, this는 호출하는 방법에 의해 결정이 된다.
현재 person에 의해 호출되어 졌기 때문에 this는 person이 되었다. 따라서 this를 이용해서 해당 프로퍼티에도 접근이 가능하다.

```js
const person = {
  name: "foo",
  age: 20,
  printThis: function () {
    console.log(this); // Window
    console.log(this === person); // false
    console.log(this.name); // undefined
    console.log(this.age); // undefined
    console.log(this === window); // true
  },
};
let printThis = person.printThis;
printThis(); // 앞에 호출한 주체가 없기 때문에 this의 주체는 default로 window 전역객체가 된다.
```

this를 호출하는 메서드를 만약 변수에 할당하게 된다면 this가 person이 아니라고 나오게 된다.
이런식으로 호출하게 되었을 경우 this에는 window 객체가 들어간 모습을 볼 수 있다.
window 전역객체라는 것은 브라우저 창이라고 생각해도 된다. 여기서 말하는 브라우저 창은 자바스크립트로 이 브라우저를 제어할 수 있도록 브라우저에서 제공하는 전역객체이다.

```js
function printThis() {
  console.log(this); // default로 this는 window 객체
}
printThis(); // window

const person1 = {
  name: "foo1",
  printThis: printThis,
};
person1.printThis(); // this의 값은 person1이 된다.

const person2 = {
  name: "foo2",
  printThis: printThis,
};
person2.printThis(); // 마찬가지로 여기서 this의 값은 person2가 된다.
```

MDN에서는 대부분의 경우 this의 값을 함수를 호출한 방법에 의해 결정된다고 말하는데, 위 코드에서 살펴본 바로 person1에서 호출하였기에 this의 값은 person1이 되고, person2도 마찬가지의 값이 나온 것을 확인할 수 있다.

하지만, 대부분의 경우에서 this의 값을 의미하는 것이므로 모두가 다 그렇지만은 않다는 것을 알 수 있다.

**this 값의 예외**

- 전역 스코프에서의 this는 window 객체이다.
- 화살표 함수에서의 this
- Strict Mode에서의 this

위 3가지 경우의 this는 각각 의미가 다르다.

```html
<head>
  <script src="index.js" defer></script>
</head>
<body>
  <button id="btn">버튼</button>
</body>
```

```js
// index.js

const btn = document.querySelector("#btn");
btn.addEventListener("click", function () {
  console.log(this); // HTML button 요소가 나옴
  console.log(this === btn); // true
});
```

이 콜백함수 안에서 this가 window가 아니라 button인 이유는 둘 중 하나이다.
이 콜백함수가 `addEventListener` 메서드 내부 안에서 btn에 의해 다시 호출이 되었거나 아니면 내부에서 이 this를 button으로 설정했을 것이다.
그렇다면, 콜백함수 안에 있는 this를 마음대로 다른 객체로 변경하기 위해서는 어떻게 해야할까?

그래서 나온것이 ES5에서 this를 설정할 수 있는 `bind` 메서드 이다.

```js
function printThis() {
  console.log(this); // default로 this는 window 객체
}

const person1 = {
  name: "foo",
};

printThis(); // 호출하는 주체가 없기 때문에 이 this의 값은 window 객체
const printThisOutput = printThis.bind(person1); // bind 메서드를 통해 this에 person1 객체를 설정
printThisOutput(); // {name: 'foo'} person1이 바인딩 되서 this의 값으로 들어감
```

bind안에 this의 값으로 설정하고 싶은 객체를 넣어주면 된다. 이렇게되면, this에 person1이 바인딩 된 함수를 반환하게 된다.

```js
function printThis() {
  console.log(this); // default로 this는 window 객체
}

const person1 = {
  name: "foo1",
};

const person2 = {
  name: "foo2",
};

const printThisOutput1 = printThis.bind(person1);
const printThisOutput2 = printThisOutput.bind(person2);
printThisOutput2(); // person1이 출력됨
```

person1이 출력된 이유는, bind는 단 한번만 사용할 수 있기 때문이다. 다시 말해 원래의 함수 `printThis`에 단 한번만 bind를 등록할 수 있다는 개념이다.

브라우저에서 `setTimeout()`이라는 함수를 제공하는데, 이 함수의 파라미터로는 콜백함수와 시간이라는 인자를 받는다.
이 시간의 단위는 1ms 즉, 1000ms는 1초가 된다.

```js
const person = {
  name: "foo",
  age: 20,
  hello: function () {
    // 이 함수의 기능은 1초 후에 이 함수를 실행하는 기능이다.
    setTimeout(function () {
      console.log(this); // 여기서 this는 person객체가 아닌 window를 가리킨다.
      console.log(this.name, this.age);
    }, 1000);
  },
};

person.hello(); // undefined
```

위 코드에서 `this.name`과 `this.age`이 출력되지 않은 이유를 살펴보자.
setTimeout에 콜백함수를 정의했을 때, 안에 있는 this가 window인 이유는 내부에서 그렇게 정의를 하였기 때문이다.
여기서 중요한 점은 이 콜백함수 안의 this를 person으로 바인딩 시켜주어야 한다는 점이다.

```js
const person = {
  name: "foo",
  age: 20,
  hello: function () {
    console.log(this); // person 객체

    setTimeout(
      function () {
        console.log(this); // 바인딩되어 person 객체
        console.log(this.name, this.age); // 'foo' '20'
      }.bind(this),
      1000
    );
  },
};

person.hello();
```

어떠한 객체로 함수를 호출했을 때, 이때 함수에서 사용되는 this는 호출한 객체가 된다.
그리고 호출한 객체가 없을 경우엔 기본적으로 window 객체가 this의 값이 된다.

**전역 스코프에서의 this**

```js
console.log(this); // window 객체
console.log(this === window); // true
```

특이점으로는 화살표 함수와 스트릭 모드에서 this는 전역 스코프에서의 this 와 다르게 동작한다.

**Arrow Function this**

ES6에서 등장한 화살표 함수가 나오기 전까지는 함수는 어떻게 호출되는지에 따라 자신의 this 값을 정의했다.
하지만 화살표 함수는 자신을 포함하고 있는 외부 스코프에서 this를 전달받는다.
(쉽게말해 화살표 함수에서의 this는 존재하지 않으므로, 외부 스코프에서 this를 물려받게 된다.)
화살표 함수에서 this는 자신을 감싸고 있는 정적 범위이다.

```js
const person = {
  name: "foo",
  age: 20,
  hello: function () {
    console.log(this); // person

    setTimeout(() => {
      console.log(this); // person - 화살표 함수로 변경, 일반함수에서는 this의 값이 window였음
    }, 1000);
  },
};

person.hello();
```

hello메서드에서의 this는 호출한 객체였던 person이였다. 화살표 함수는 자신을 감싸고 있는 외부 스코프에서 this의 값을 물려 받기 때문에 hello메서드의 this값과 동일한 person이 나오게 된다.

```js
const person = {
  name: "foo",
  age: 20,
  hello: function () {
    const that = this; // 화살표 함수가 나오기전에 this를 바인딩했던 방법

    setTimeout(function () {
      console.log(this); // window
      console.log(that.name, that.age); // 'foo' 20
    }, 1000);
  },
};

person.hello();
```

화살표 함수가 등장하기 전까지는 this를 사용하기 위해 변수에 this값을 넣어서 사용을 하였다.
콜백함수안에서의 this는 window이지만 외부 this를 담고 있는 변수를 이용해서 원하는 값에 접근이 가능한 방법이였지만, 콜백함수에서 this를 사용할 때에는 일반함수에 this를 바인딩 하기 보단 화살표 함수를 이용하는 편이 더 간결하다.

하지만 화살표 함수를 사용하면 안되는 경우도 존재한다.

```js
const person = {
  name: "foo",
  age: 20,
  printThis: () => {
    console.log(this); // window 객체
  },
};
person.printThis(); // window 객체
```

위 코드처럼 객체의 메서드로 화살표 함수를 사용해서 this의 값을 사용하면 person이 아닌 window 객체를 가지게 된다.
화살표 함수는 외부 스코프에서 this를 물려받는다고 했는데 왜 window가 나왔을까?
그 이유는 printThis를 감싸고 있는 스코프는 전역 스코프이기 때문이다. 전역 스코프에서의 this는 window이므로 printThis의 this는 window가 출력되게 된다.

```js
const person = {
  name: "foo",
  age: 20,
  printThis: function () {
    console.log(this, this.name, this.age); // person 객체 'foo' 20
  },
};
person.printThis();
```

객체 메서드 같은 경우에서 this는 일반적으로 해당 객체의 다른 프로퍼티에 접근하기 위해 사용하므로, 화살표 함수보다 일반 함수를 사용하여 만드는 것이다.

또한, addEventListener 함수의 콜백 함수에서 화살표 함수로 사용하게 되면, this가 상위 컨텍스트를 가리킨다.

- addEventListener에서 화살표 함수로 등록하면 this 는 무조건 window 객체를 가리키게 된다.

```js
const btn = document.querySelector("button");
btn.addEventLister("click", () => {
  console.log(this === window); // true
  this.innerHTML = "Clicked btn";
});
```

그렇기 때문에 위와 같은 경우에서는 화살표 함수를 지양해야 할 경우가 발생한다.

```js
const btn = document.querySelector("button");
btn.addEventLister("click", function () {
  console.log(this === window); // false;
  console.log(this === button); // true;
  this.innerHTML = "Clicked btn";
});
```

**스트릭 모드의 this**

Strict Mode(엄격 모드)에서는 호출한 객체가 없을 경우 this의 기본값을 window가 아닌, undefined로 설정한다.

```js
"use strict";
function printThis() {
  console.log(this);
}
printThis(); // undefined
```

<br>

---

## API란?

Application Programming Interface (API)

> API는 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.

- Interface(인터페이스): 상호간에 소통을 위해 만들어진 접점
  (상호간에라는 뜻은 사람과 사람뿐만 아니라, 사람과 컴퓨터, 컴퓨터와 컴퓨터등 어떠한 서로 다른 2개 이상의 것들이 소통하기 위한 방법을 의미한다.)

![](https://velog.velcdn.com/images/ninto_2/post/3477d360-a954-4715-9ae8-02d5aeedbf11/image.png)

만약 달리는 자동차에서 문을 열고싶다면, 스마트 키의 열림 버튼을 눌러서 열게 만들 수 있다.
이처럼 스마트 키를 사용해서 문을 열었기 때문에 스마트 키는 사람과 자동차의 접점인 인터페이스라고 할 수 있다.

![](https://velog.velcdn.com/images/ninto_2/post/f0b4ebd9-6a52-403e-b9c9-1f30f43c2710/image.png)

컴퓨터와 사람간의 인터페이스도 마찬가지이다.
인터페이스에서 소통이라고 하는 것은 쉽게 말해 읽거나, 쓰는 것을 의미한다.

또 다른 예시로, 스마트폰 앱에 있는 모든 버튼, 모든 화면을 인터페이스라고 할 수 있다.
왜냐하면 App이라는 시스템은 이러한 화면을 통해 사용자의 소통의 역할을 하기 때문이다.
이처럼 사용자가 사용하는 인터페이스를 `User Interface` (UI)라고 부른다.
다만 스마트 키나 키보드, 모니터 같은 경우엔 물리적인 하드웨어 UI이고 APP이나 Web과 같은 것들은 소프트웨어 UI라고 볼 수 있다.

일반적으로 IT에서 UI라고 하면, 소프트웨어적인 UI를 의미한다.
이러한 UI가 Web을 통해 보여지면 Web UI, 모바일을 통해 보여지면 모바일 UI라고도 한다.

정리하자면, 인터페이스는 소통을 하기 위한 접점이며, UI는 사용자가 소통을 하기 위한 접점이라고 보면 된다.

![](https://velog.velcdn.com/images/ninto_2/post/d719110d-7c55-48b1-b04b-06b7df7c47f4/image.png)

API는 사용자가 아닌 응용 프로그램에서 소통하기 위한 인터페이스를 말한다.
여기서 말하는 응용 프로그램은 운영체제에서 실행되는 모든 소프트웨어를 의미한다. 다른 말로 애플리케이션이라고도 말한다.
즉, API는 애플리케이션에서 데이터를 읽거나 쓰기 위해 사용하는 인터페이스를 말하는 것이다.

예를들어, 우리 동네 날씨 정보를 보여주는 앱을 만들기 위해서는 우리 동네 날씨 정보가 먼저 있어야 한다.
이러한 날씨 정보는 보통 기상청에 있기 마련이다.

이 앱을 만들기 위해서는 기상청에 날씨 정보를 Request(요청)해서, 기상청에게 Response(응답)을 받은 후 화면에 날씨 정보를 보여주면 된다.
이때 날씨 정보 데이터를 가져오기 위해 기상청에서 제공하는 접점을 바로 API라고 한다.

API의 생김새는 주로 `http://api.data.go.kr/weather/list` 이런식으로 주소의 형태를 띄고있다.
이러한 API를 제공해주면, App에서는 `curl http://api.data.go.kr/weather/list` 이렇게 요청해서
`{'today': '2023-02-02', 'weather': '맑음'}`이러한 데이터를 응답을 받아, 사용자에게 보여줄 UI를 개발하면 된다.

정확히 얘기하자면 위와 같은 형식의 API를 `HTTP API`라고 한다.

공공 데이터 포털 사이트 `data.go.kr`에 들어가게 되면, 오픈API를 통해 API를 확인할 수 있다.

기상청에서는 동네 날씨 정보를 DB(데이터베이스)서버에 보관한다.
그리고 기상청에서는 날씨와 같은 API를 다른 애플리케이션에서 가져갈 수 있도록 서버에 다양한 API를 개발하고,
날씨정보앱에서는 이런 API를 조회하여 사용자에게 보여질 UI를 개발한다.

![](https://velog.velcdn.com/images/ninto_2/post/d64e0be3-3745-42cb-8361-fd58c018bc43/image.png)

이때 사용자에게 보여질 앞 단인 UI를 개발하는 쪽이 프론트엔드라고 하며, 데이터를 제공하는 뒷 단을 백엔드라고 지칭한다.
그리고 넓은 의미로는 프론트엔드를 클라이언트(요청자)라고 부르며, 백엔드를 서버(제공하는자)라고도 한다.

![](https://velog.velcdn.com/images/ninto_2/post/f4a6ea72-a83f-4071-8f62-3d34fb46eeb7/image.png)

애플리케이션을 개발하는 백엔드 팀에서는 데이터를 조회할 수 있도록 다양한 API를 개발해 놓았을 것이다.
그리고 프론트엔드 개발 팀에서는 이러한 API를 사용하여 사용자에게 보여질 UI를 개발한다.

이렇게 사용자는 UI를 통해 소통하며, 애플리케이션은 API를 사용하여 소통하는 것이다.

만약 특정 통계 기능을 개발해달라는 업무를 받게 되었다면, 백엔드에서는 해당 데이터에서 통계자료를 추출하여 프론트엔드 애플리케이션이 호출할 수 있도록 API를 개발한다. 그리고 프론트엔드에서 이 API를 사용하여 마케팅 팀에게 보여질 웹 UI를 개발하는 방식이다.

다시말해, API는 애플리케이션에서 데이터를 읽거나 쓰기 위해 사용하는 인터페이스 이다.
그리고 회사 자체 서비스를 만들기 위해 사내에서 개발하고 사용하는 API를 `Private API`라고 하며 이러한 `Private API`는 제3자에게 공개되지 않는다.
반면 기상청 API와 같이 누구나 사용할 수 있도록 개방해놓은 API를 `Public API` 또는 `Open API`라고 한다.
그리고 이런 오픈 API에는 공공 API, Youtube API, Instagram API, Facebook API, Naver API, Kakao API 등 많은 플랫폼에서 자체 데이터나 기능을 활용할 수 있도록 다양한 API를 제공한다.
그리고 이러한 API는 HTTP API를 말하며, `HTTP`는 주로 인터넷 상에서 데이터를 주고받을 때 사용하는 프로토콜이다.

> HTTP API = 프로토콜 = 소통방법 = 통신방법 = 통신규약

애플리케이션이 소통을 할 때도 상황에 따라 다양한 소통방법이 존재한다.

만약 미세먼지 측정기에서 미세먼지 농도 값을 읽어와서, 공기가 안좋으면 자동으로 창문을 개방하는 IOT 애플리케이션을 개발하고 싶다면,
미세먼지 측정기와 스마트 창문에 소통할 수 있는 API가 있는지 확인해야 한다.
이때 사용하는 소통 방법은 저사양, 저환경에 적합한 `MQTT, CoAP API` 프로토콜을 사용해야 할 것이다.

또, API는 통신 프로토콜 레벨이 아닌 `Class`나 `Function`와 같은 소스코드 레벨이 될 수 도 있다.
우리가 보통 자바스크립트로 콘솔에 소스코드를 찍을 때 `Console API`를 사용한다.
만약 자바를 사용해 개발을 한다면, Java의 클래스나 메서드를 사용해서 개발할 것 이다.

즉, API에는 용도에 맞는 다양한 API들이 존재하고 있다.

일반적으로 오픈 API와 같은 용어로 사용할 때에는 인터넷 상에서 데이터를 주고 받는 HTTP API를 말한다는 것을 인지하면 된다.

<br>

---

## 동기와 비동기란?
