## 2023.02.04.목

148p ~ 182p

<h2 id='1'>📌 메모리 계층 </h2>

메모리 계층은 `레지스터, 캐시, 메모리, 저장장치`로 구성되어 있습니다.

![](https://velog.velcdn.com/images/ninto_2/post/19154c49-2ea3-4391-8212-1b7039d852af/image.png)

- **레지스터 (CPU 메모리)**: CPU 안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 가장 적다.
- **캐시 (L1, L2)**: 휘발성, 속도 빠름, 기억 용량이 적다. (L3 캐시도 있음)
- **주 기억장치 (메모리 RAM)**: 휘발성, 속도 보통, 기억 용량이 보통
  (RAM에서 하드디스크로부터 일정량의 데이터를 복사 -> 임시 저장 -> 필요시 CPU에 빠르게 전달하는 역할)
- **보조 기억장치 (저장장치 HDD, SDD)**: 비휘발성, 속도 낮음, 기억 용량이 많다.

이러한 계층이 있는 이유는 **경제성** 때문입니다.
16GB RAM은 8만원이면 사는데, 16GB SSD는 훨씬 더 싼 가격에 살 수 있기 때문에,
계층적 구조를 두어 경제적인 효율을 챙기는 방법에서 유리합니다.

이러한 계층구조는 일상 생활에서 경험을 할 수 있는데, 대표적인 예시가 바로 게임 중 **로딩**입니다.
이는 하드디스크 또는 인터넷에서 데이터를 읽어 **RAM으로 전송하는 과정이 아직 끝나지 않음**을 의미합니다.
(정확히는 '덤프를 떠서 덤프 과정이 일어나지 않았다'라고 말하기도 합니다.)

<br>

---

<h2 id='2'>📌 메모리 관리</h2>

운영체제의 대표적인 할 일 중 하나는 **메모리 관리**입니다.
컴퓨터 내의 **한정된 메모리를 극한으로 활용**해야 하는 것이죠.

<h3 id='3'>🌱 가상 메모리 (virtulal memory) </h3>

> **가상 메모리**는 컴퓨터가 **실제로 이용 가능한 메모리 자원을 추상화**하여, 사용자들에게 매우 큰 메모리로 보이게 만드는 메모리 관리 기법 중 하나입니다.

![](https://velog.velcdn.com/images/ninto_2/post/c4dbebeb-d388-46d3-b680-45909b6c1897/image.png)

메모리나 디스크는 크기가 작지만, 가상 메모리는 크게 설정된 모습을 볼 수 있습니다.
이를 통해 물리적 메모리 부족을 보완하며, 실제 마치 큰 메모리를 기반으로 멀티태스킹(프로그래밍을 한다거나 여러가지 프로그램을 동시 실행할 수 있게끔 함)을 하게 할 수 있습니다.

이때 **가상적으로 주어진 주소**를 **가상 주소**(logical address 또는 virtual address)라고 하며, **실제 메모리 상에 있는 주소**를 **실제 주소**(physical address)라고 합니다.

**가상주소는 메모리 관리 장치(MMU)에 의해 실제 주소로 변환**되며,
이 덕분에 사용자는 실제 주소를 의식할 필요없이 프로그램을 구축할 수 있게 됩니다.

![](https://velog.velcdn.com/images/ninto_2/post/b9695175-8bb8-4858-9e5c-7986901674dc/image.png)

즉, 가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 **페이지 테이블**로 관리됩니다.
이때 속도 향상을 위해 **TLB**를 사용합니다.

- TLB(조그마한 페이지 테이블): 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시
  (페이지 테이블에 있는 리스트를 보관, CPU가 페이지 테이블까지 가지 않도록 만들어서 속도를 향상시키는 캐시 계층)

<br>

<h3 id='4'>🌱 스와핑 </h3>

실제 메모리에는 없는데, 가상 메모리가 너무 커서 페이지 폴트가 발생할 경우 일어나는 현상
(페이지폴트가 발생하지 않은 것처럼 만듬)

![](https://velog.velcdn.com/images/ninto_2/post/c6948781-8ae1-4961-b3bc-18df75c7aeda/image.png)

> 만약 가상 메모리에는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생합니다.
> 이때 **메모리의 당장 사용하지 않는 영역을 하드디스크로 옮기고, 하드디스크의 일부분을 `마치 메모리처럼`불러와 쓰는 `스와핑`을 통해 마치 페이지 폴트가 발생하지 않은 것처럼 만듭니다.**

- 페이지: 가상 메모리를 사용하는 최소 크기 단위
- 프레임: 실제 메모리를 사용하는 최소 크기 단위

<br>

<h3 id='5'>🌱 페이지 폴트(page fault) </h3>

> **페이지 폴트란, 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우에 발생하는 현상**을 의미합니다.
> 페이지 폴트 이후 스와핑이 작동하는데 자세한 과정은 아래와 같습니다.

1. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생해서 운영체제에 알립니다.
2. 운영체제는 CPU의 동작을 잠시 멈춥니다.
3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고,
   없으면 프로세스를 중단하고 현재 물리 메모리에 비어 있는 프레임이 있는지 찾습니다.
   물리 메모리에도 없다면 스와핑이 발동됩니다.
4. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화합니다.
5. 중단되었던 CPU를 다시 시작합니다.

<br>

<h3 id='6'>🌱 스레싱 (thrashing)</h3>

스레싱은 스와핑과 다른 개념이며, 페이지 폴트가 너무 많이 발생될 때를 스레싱이라고 합니다.

![](https://velog.velcdn.com/images/ninto_2/post/23926f13-d68e-4735-be2e-2cb7d980fc78/image.png)

> **스레싱은 메모리의 페이지 폴트율이 높은 것을 의미**하며, 이는 컴퓨터의 심각한 성능 저하를 초래합니다.

스레싱은 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나서 발생하는 것입니다.
페이지 폴트가 일어나면 **CPU 이용률이 낮아집니다.**
CPU 이용률이 낮아지게 되면 운영체제는 CPU의 가용성을 더 높이기 위해 **더 많은 프로세스를 메모리에 올리게 됩니다.**
이와 같은 악순환이 반복되며 스레싱이 일어나게 됩니다.

스레싱을 해결하기 위한 방법으로는
**메모리를 늘리거나, HDD를 사용한다면 HDD를 SDD로 바꾸는 방법**이 있습니다.
그 외에도, **운영체제에서 해결할 수 있는 방법은 작업 세트와 PFF**가 있습니다.

![](https://velog.velcdn.com/images/ninto_2/post/d08fd0d2-6f77-4c3d-b9e3-a0ebac810b8b/image.png)

- 작업 세트(working set): **프로세스의 과거 사용 이력인 지역성(locality)을 통해 결정된 페이지 집합**을 만들어서 **미리 메모리에 로드하는 것**입니다.
  (미리 메모리에 로드하면 탐색에 드는 비용을 줄일 수 있고, 스와핑 또한 줄일 수 있습니다.)

- PFF(page Fault Frequency): **페이지 폴트 빈도를 조절**하는 방법, **상한선(upper bound)과 하한선(lower bound)을 만드는 방법**입니다.
  (만약 상한선에 도달한다면 프레임을 늘리고, 하한선에 도달한다면 프레임을 줄입니다.)

<br>

---

<h2 id='7'>📌 프로그램과 프로세스, 스레드의 차이</h2>

**프로그램**은 HDD나 SDD에 올라가져 있는 상태를 의미합니다.
프로그램이 실행(프로그램이 메모리에 올라가진 상태)되면 **프로세스**가 됩니다.
(프로그램이 메모리에 올라가면 프로세스가 되는 **인스턴스화**가 일어나고, 이후 운영체제의 **CPU 스케줄러에 따라 CPU가 프로세스를 실행**합니다.)

프로세스(process): 컴퓨터에서 **실행되고 있는 프로그램**을 말하며,
**CPU 스케줄링의 대상이 되는 테스크(task 작업)라는 용어와 거의 같은 의미**로 쓰입니다.

![](https://velog.velcdn.com/images/ninto_2/post/13af1655-eece-4241-bc74-d76d8571b4a3/image.png)

- 싱글스레드 프로세스: 하나의 스레드만 가지고 있는 프로세스
- 멀티스레드 프로세스: 여러 개의 스레드를 가지고 있는 프로세스

스레드: **프로세스 내 작업의 흐름**을 지칭합니다. (실행 가능한 가장 작은 단위)

**프로세스와 스레드의 차이점**

![](https://velog.velcdn.com/images/ninto_2/post/e0465b44-0394-4dbe-b530-49f730705d73/image.png)

- **프로세스는 코드, 데이터, 스택, 힙 메모리 영역을 기반으로 작업**을 합니다.
- **스레드**는 프로세스 내의 **스택 메모리 영역을 제외한 다른 메모리 영역을 프로세스 내 다른 스레드들과 공유**합니다.

**프로세스**가 다른 프로세스와 통신을 하기 위해서는 **IPC를 사용**해야 합니다.
하지만 **스레드는 메모리를 공유(코드, 데이터, 힙을 공유)하기 때문에, 다른 스레드와의 정보 공유가 쉬운 점**이 있습니다.
(스레드의 경우 **동기화 문제 등의 단점**이 있다., 스택은 스레드마다 하나씩 가지고 있다.)

- IPC(Inter Process Communication): IPC는 통신의 비용이 상대적으로 많이 듭니다.

![](https://velog.velcdn.com/images/ninto_2/post/9b11ec09-ce0f-472a-b462-c063a67e7728/image.png)

**스레드를 사용하는 웹 서버**의 경우, 웹 요청을 처리할때 새 프로세스를 생성하는 대신 스레드를 사용하기 때문에 훨씬 더 작은 리소스를 소비하며,
한 스레드가 중단(blocked)되어도 다른 스레드는 실행(running)상태 일 수 있기 때문에 중단되지 않은 빠른 처리가 가능합니다.
또한, **동시성에도 큰 장점**이 있습니다.
(동시성: 서로 독립적인 작업들을 작은 단위로 나누고, 동시에 실행되는 것처럼 보여주는 것)

하지만 **한 스레드에 문제가 생기면** 다른 스레드에도 영향을 끼쳐(스레드는 메모리 영역을 공유하기 때문), **스레드로 이루어져 있는 프로세스에 영향을 줄 수 있는 단점**이 있습니다.

<br>

**프로세스와 컴파일 과정**

**프로세스**는 **프로그램으로부터 인스턴스화 된 것**을 말합니다.
예를들어, 구글 크롬 프로그램(chrome.exe)은 실행 파일이며 이를 두번 클릭하면 구글 크롬 프로세스가 시작되는 것입니다.

![](https://velog.velcdn.com/images/ninto_2/post/a7118ae1-8e1e-4265-b93b-45a795d93dd6/image.png)

프로그램은 컴파일러가 **컴파일 과정을 거쳐 컴퓨터가 이해할 수 있는 기계어로 번역되어 실행될 수 있는 파일이 되는 것**을 의미합니다.
참고로 여기서 말하는 프로그램이란 C언어 기반의 프로그램을 의미하며, 별도의 컴파일 과정없이 한번에 한줄씩 읽어들여서 실행하는 프로그램인
인터프리터 언어(파이썬, 자바스크립트 등)로 된 프로그램과는 다릅니다.

- 전처리: 소스 코드의 주석을 제거하고, `#include` 등 헤더 파일을 병합하여 메크로를 치환합니다.

- 컴파일러: 오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환합니다.

- 어셈블러: 어셈블리어는 목적 코드(object code)로 변환됩니다. 이때 확장자는 운영체제마다 다른데, 리눅스에서는 `.o`입니다.
  (ex. `파일.c`라는 파일을 만들었을때 `파일.o`라는 파일이 만들어지게 됩니다.)

- 링커: 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만듭니다.
  (실행 파일의 확장자는 `.exe 또는 .out`이라는 확장자를 갖습니다.)

<br>

**정적 라이브러리와 동적 라이브러리**

라이브러리는 정적 라이브러리와 동적 라이브러리로 나뉩니다.

![](https://velog.velcdn.com/images/ninto_2/post/b871acec-0c12-44b3-99b7-c42933ffe3ee/image.png)

- 정적 라이브러리: 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식
  (시스템 환경 등 외부 의존도가 낮고, 코드 중복 등 메모리 효율성이 떨어지는 단점)

- 동적 라이브러리: 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조하는 방식
  (메모리 효율성에서의 장점과 외부 의존도가 높아진다는 단점)

<br>

---

<h2 id='8'>📌 프로세스의 메모리 구조 </h2>

운영체제는 프로세스에 적절한 메모리를 할당하는데,
아래와 같은 구조를 기반으로 할당하게 됩니다.

![](https://velog.velcdn.com/images/ninto_2/post/878c7083-a7d6-4084-99e6-141073fb85dd/image.png)

스택은 위 주소부터 할당되고, 힙은 아래 주소부터 할당됩니다.

- 스택: 지역변수, 매개변수, 함수가 저장되고 컴파일 시에 크기가 결정됩니다. 그러나 함수가 함수를 호출 하는(재귀함수) 등에 따라 런타임시에도 크기가 변경됩니다. (동적인 특징)
- 힙: 힙은 동적 할당할 때 사용되며, 런타임 시 크기가 결정됩니다. (동적인 특징)
- 데이터 영역: BSS 영역과 Data 영역으로 나뉘고, 정적 할당에 관한 부분을 담당합니다. (정적인 특징)
- 코드 영역: 소스코드가 들어갑니다. (정적인 특징)

**정적 할당**

정적 할당은 **컴파일 단계에서 메모리를 할당하는 것**을 말합니다.
`BSS segment와 Data segment` / `text segment`로 나뉘어서 저장됩니다.

BSS segment: 전역 변수, static, const로 선언되어 있는 변수 중 0으로 초기화 또는 초기화가 어떠한 값으로도 되어 있지 않은 변수들이 이 메모리 영역에 할당됩니다.

Data segment: 전역 변수, static, const로 선언되어 있는 변수 중 0이 아닌 값으로 초기화된 변수가 이 메모리 영역에 할당됩니다.

code / text segment: 프로그램의 코드가 들어갑니다.

- C나 자바에 있는 static 변수 문법은 자바스크립트에서는 존재하지 않는다.
  (간접적으로 구현해서 정적 변수처럼 사용할 수 있다.)

```js
var b = 0;

// 무식하게 전역변수를 static변수로 이용하는 방법
function func() {
  b++;
  console.log(b);
}

func(); // 1
func(); // 2

// 클로저를 이용한 static 변수 구현
let staticValue = (function staticFunc(value) {
  let i = value;
  return function () {
    return ++i;
  };
})(0); // 정적 변수 시작을 0으로 초기화

function main() {
  let val = staticValue(); // 정적 변수 val을 선언, 함수 호출할 때 마다 변수값이 하나씩 오른다.
  console.log(val);
}

main(); // 1
main(); // 2
```

**동적 할당**

동적할당은 런타임 단계에서 메모리를 할당받는 것이며 스택과 힙으로 나눠집니다.

스택: 지역변수, 매개변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역입니다.
함수가 호출될 때마다 호출될 때의 환경 등 특정 정보가 스택에 계속해서 저장됩니다.

참고로 재귀함수가 호출 된다고 했을때, 새로운 스택 프레임이 매번 사용되기 때문에 함수 내의 변수 집합이 해당 함수의 다른 인스턴스 변수를 방해하지 않습니다.

힙: 동적으로 할당되는 변수들을 담습니다.
`malloc(), free()`함수를 통해 관리할 수 있으며, 동적으로 관리되는 자료구조의 경우 힙영역을 사용합니다.
(예를들어 vector는 내부적으로 heap 영역을 사용합니다.)

<br>

---

<h2 id='11'>📌 PCB와 컨텍스트 스위칭 </h2>

<br>

---

<h2 id=''>📌 메모리 할당</h2>

- 연속 할당

  - 고정 분할 방식
  - 가변 분할 방식

- 불연속 할당
  - 페이징
  - 세그멘테이션
  - 페이지드 세그멘테이션

### 페이지 교체 알고리즘

- 오프라인 알고리즘
- FIFO
- LRU
- NUR
- LFU

<br>

---

### 프로세스의 상태

- 생성 상태
  - `fork()`
  - `exec()`
- 대기 상태
- 대기 중단 상태
- 실행 상태
- 중단 상태
- 일시 중단 상태
- 종료 상태

### PCB

- PCB의 구조
- 컨텍스트 스위칭
  - 비용: 캐시미스
  - 스레드에서의 컨텍스트 스위칭

### 멀티프로세싱

- 웹 브라우저
- IPC
  - 공유 메모리
  - 파일
  - 소켓
  - 익명 파이프
  - 명명된 파이프
  - 메시지 큐

### 스레드와 멀티스레딩

- 스레드
- 멀티스레딩

### 공유 자원과 임계 영역

- 공유 자원
- 임계 영역
  - 뮤텍스
  - 세마포어
  - 바이너리 세마포어
  - 카운팅 세마포어
- 모니터

### 교착 상태

- 교착 상태의 원인
- 교착 상태의 해결 방법

## CPU 스케줄링 알고리즘

### 비선점형 방식

- FCFS
- SJF
- 우선순위

### 선점형 방식

- 라운드 로빈 (RR)
- SRF
- 다단계 큐
