## 선언과 구현의 차이

```js
// 1. 함수를 선언
fuction func() {
 // 2. 함수를 구현
}

// 3. 함수를 사용
func();
```

타입스크립트에서 함수는 어디에서 쓰일까?

- 필수 요구사항
  - 필요한 데이터를 모두 모델링한다.
  - 사용되는 모든 함수를 선언부만 만든다.

오늘의 핵심은 선언과 구현의 차이 이해하기이다.
이를 이해하면 선언부를 활용하여 설계하기, JSDoc을 활용한 코드 문서화

2회차에선 인터페이스를 다룬 타입스크립트
리액트에 타입을 달 때 props타입을 단다.
인터페이스 vs 타입 알리아스 여기서 사고관이 갇힌다.

인터페이스라는 것을 컴퓨팅 관점에서 바라보고 리액트와 타입스크립트와 생각을 연결지어야 한다.

- 객체의 원형 (typescript shape of object)
- 모델링
- 타입 인터페이스 선언

객체의 원형을 이해하니 감이 잡힐 것이다. (모양, 생김새를 뜻함)
물체의 모양이라고 볼 수도 있다. 결국엔 형태, 원형으로 해석이 됨
즉, 객체의 생김새를 묘사해주는 녀석이다.
실질적으로 리액트에 props 타이핑부터 해보니까 프로그래밍 관점에서 바라보는 시각을 가지지 못한것이다.

3회차에선 안전한 웹을 위한 타입스크립트

**Type 가드**

- 타입좁히기
- 타입 가드
- 런타임 vs 컴파일

면접에서 타입스크립트 왜쓰냐고 물어보면 거의 90퍼는 안전한 웹을 위해 타입스크립트를 도입했습니다.
내가 왜 타입스크립트를 런타임에서 왜 안전하게 쓰지 못하고 있지라고 생각을 해야된다.

4회차에선 타입스크립트의 타입 시스템

장포코씨는 러닝 타입스크립트라는 책을 사고 다루고 있다.

타입스크립트 소개

과거엔 타입스크립트는 자바스크립트의 super set이다 라는 말이다라고 써있었지만, 지금은 아니다.
공식문서에서는 이제는 타입스크립트는 자바스크립트와
타입스크립트는 유형에 대한 구문이 있는 자바스크립트 입니다. 라고 써있다.

유형을 타입으로 생각해서 타입에 구문이 있다고 생각하면 된다.
구문이란? 문법? syntax 이다.

타입스크립트는 자바스크립트에 타입이라는 문법이 붙어있는 것이다.

```
TS = JS + TS Syntax
```

타입스크립트는 자바스크립트와 타입 신텍스가 더해진 것이라고 했다 그렇다면 타입 신텍스는 무엇일까?

콜론 뒤에 붙는것(이건 무슨 타입이야)

현대의 타입스크립트는 타입 구문이 있는 자바스크립트
자바스크립트에 추가 구문을 제공해주는 것이다.
IDE와 통합하여 캐치한다. (공식문서에 가면 다 있다.)

리액트에 가보면 선언형, 컴포넌트 기반, 한번 배워서 어디서나 사용하기 3개로 구분해놨는데 그 이유는 무엇일까?

사실 나를 써달라고 어필하는 것이다.

마치 쇼핑몰의 상세페이지와 같다.

그렇다면 자바스크립트에 추가구문을 넣어서 안정성있게 한다고 했는데 그렇다면 IDE와 통합해서 오류 캐치한다는 것은 무엇일까?

타입스크립트와 vscode도 마이크로소프트에서 만들었다.
타입스크립트를 전파하고 싶어서 그것까지 준 것이다.
vscode는 뭘로 만들었을까 타입스크립트와 일렉트론으로 같이 만든 것이다.
vscode는 자바스크립트 타입스크립트로 만들었어 이런것이다.

결국 마이크로소프트는 타입스크립트를 대중화하고 싶었고, 거기서 IDE를 자사 서비스 타입스크립트로 만들어서 배포까지 한 것이다.

이게 타입스크립트의 엣지 중 하나임

타입스크립트를 쓰면 신뢰할 수 있는 결과가 나올 수 있다고 한다.
이부분에서 자바스크립트로 변환은 무엇일까?
자바스크립트가 지원되는 모든곳에서 실행 (브라우저, 노드,deno 등)

그들의 입장에서 생각해보면 이런 이유가 무엇일까?
호환이 안되면 기존거에서 안벗어날 테니까

자바스크립트가 먼저 나왔고, 그다음 타입스크립트를 만들었는데 본인들이 사용하는 서비스에서 계속 사용할 수 있도록 타입스크립트는 아무런 피해도 주지않아 그래서 나를 믿고 써 이런 관점

대규모 안전
자바스크립트를 이해하는 타입추론을 사용한다.
추가적인 코드 없이도 훌륭한 도구를 제공

결국은 타입스크립트를 쓸때 불필요한것은 필요없다.
그리고 타입추론이 있기에 확장 가능성이 있다는 말

npm 트랜드를 보면 타입스크립트를 쓰는 곳은 점점 많이 늘어나고 있다.
어쩔수 없이 사용되고 있음

스택오브플로우
Rust가 점점 올라오고있는데, 타입스크립트가 숨쉬듯 편해진다면 그때 Rust를 시작해도 좋다.

점점 Rust도 많이 쓰임 ㅇㅇ

npm, 깃허브, 마이크로소프트에서 인수하고 타입스크립트에서 마이크로소프트에서 만들었다.

타입스크립트 효과

- 객체와 함수의 생김새를 정의
- 데이터를 코드로 설명할 수 있는 데이터 기술서
- 편집기에서 문서 및 버그를 검출 할 수 있다.

```ts
interface Person {
  name: string;
  age: number;
  gender: "M" | "F";
}
```

우리가 못할때로 돌아가서 이 코드로 생각을 해보자.
name은 문자고, age는 숫자, gender는 남자거나 여자

면접때 객체지향에 대해 설명하세요

객체지향은 코드로 복잡한 시스템을 표현할 수 있는 방법이다

리액트에서 갇히는게 뭐냐면
interface 문법은

```jsx
// 인터페이스는 대놓고 객체를 쓴다.
interface Name {

}
// 타입 알리아스 - 변수처럼 할당하고있고
type Name =
```

결국 인터페이스는 객체의 생김새를 쓰고있다.
타입알리아스와 인터페이스에 대해 설명하세요 이러면 타입스크립트와 마이크로소프트에서 왜 이렇게 만들었는지에대해 생각해서 말하면 된다.

그래서 이 부분은 객체와 함수의 생김새를 정의해야 하는 부분이고.

자바스크립트 파일인데

```js
function compact(arr) {
  if (orr.length > 10) return arr.trim(0, 10);
  return arr;
}
```

이 함수가 오류가 나는 이유는 orr, trim

자바스크립트 런타임 시점 오류 검출 `@ts-check` 이것을 자바스크립트 파일에 추가하면 편집기에 오류가 표시됩니다.

타입스크립트가 봤을때 오류를 미리 알려주기는 한다.

```ts
function compact(arr: string[]) {
  if (arr.length > 10) return arr.slice(0, 10);
  return arr;
}
```

타입구문이 존재하는 자바스크립트 즉 타입스크립트이며 타입스크립트가 컴파일되면 자바스크립트로 변환된다.

타입스크립트를 다른 곳에서 강의할 때도 그렇고 타입스크립트 플레이그라운드 검색을하면 이 툴이 나온다.

이 툴은 vscode 단축키가 다 먹는다.
타입스크립트를 공부해서 타입이 어렵고 내가 하는게 어려운 분들은 내가 작성한 코드를 남들한테 쉽게 물어보고 이런방법으로 쉽게 공부할 수 있다.

정말 좋은게 .JS 와 .D.TS를 제공한다.
왼쪽 입력창에서 입력하면 오른쪽에서 변환되는 것이다.

![](https://velog.velcdn.com/images/ninto_2/post/8946ad8e-b957-421d-b01c-21c82d059603/image.png)

.JS는 자바스크립트 그 자체이다.
.D.TS는 타입이 남는다.

```ts
declare function func(wan: "wan", ted: "ted"): string;
```

프로그래밍 문법에서 빠진 무언가가 있다. (구현부가 빠졌다.)
선언부만 선언하고 구현하지 않는 것

결국 이 부분을 JSDOC으로 할 수 있다.

```
class todo {}
function createTodo() {}
function readTodo() {}
funtion updateTodo() {}
function isEmptyTodo() {}
function deleteTodo() {}
function alertRule() {}
```

코드를 선언만 하는 연습을 해야한다.
대부분의 타입스크립트를 공부하는 분들이 놓치는 훈련이다.
코드를 먼저 구현한다. 그다음 타입을 단다 대부분
가장 중요한건 타입스크립트를 초반에 배울때는 왠만해서 힘들어도 타입부터 상상해서 만들고 타입부터
선 타입 후 구현임 이걸 연습해서 실력을 많이 향상시키자.

![](https://velog.velcdn.com/images/ninto_2/post/32d012ee-eea9-4a23-9d50-fbdcc0680071/image.png)

이런게 타입 추론이다.

내가 타입추론에 서툴다면 타입스크립트가 어려울 수 있다. 이유는 타입스크립트 컴파일러가 내가 만드는 코드를 추론하지 못하기 때문이다.

함수 표현식 타이핑이랑 함수 선언의 타입이 다를 수 있다.

```
// 이런게 함수 표현식
const func = function () {

}

const func = () => {}
```

왠만하면 프로퍼티로 넣는것 보단

![](https://velog.velcdn.com/images/ninto_2/post/4376ad27-6151-4750-8340-bb0c55486437/image.png)

이렇게 쓰는게 좋다.

타입에서 void 리턴없음, 반환하지않음 임

void는 타입스크립트 문법일까 자바스크립트 문법일까?

```js
// 1. void는 ts문법일까 js문법일까
// 2. void는 js에도 있을까?
```

자바스크립트에는 void가 있다. 하지만 타입스크립트의 void와는 다르다.

```js
// 이 void는 자바스크립트 문법
void function iife() {
  console.log("iife is executed");
};

// 이건 타입스크립트 문법
function func(): void {}

// .D.TS
declare function func(): void;
```

이런게 초점이다.

이 문법은 자바스크립트인가 이 문법은 타입스크립트인가 생각을 해야된다.
둘다 있어서 짜증나는게 있다. 이 문법은 무엇일까

`typeof`, `in`, 일단 타입가드 관련된건 다 맞다.

프라이빗 필드

```js
// 자바스크립트 공식문법
class ClassWithPrivateField {
  #privateField;
}

// 타입스크립트 공식문법
class ClassWithPrivateField {
  private;
}
```

두 필드는 정확히 같다. 이건 자바스크립트 공식 문법이고, 아래는 타입스크립트 공식문법이다.
이렇게 비슷한 이유는 무엇일까?
Js 에 없어서 ts에서 구현한 걸 나중에 js 에서 들어와서

타입스크립트에서 먼저 프라이빗 필드를 만들어버리고, js에 들여보냄

크로스브라우징 ,
웹 표준을 왜 지켜야할까?

- 우리가 html , css 자바스크립트로 코드를 작성하는데 브라우저는 4개다. 이게 다 다르기 때문

우리가 만든 html,css,자바스크립트는 사파리,오페라,크롬 다 다르게 동작되는 부분들이 있다.

![](https://velog.velcdn.com/images/ninto_2/post/9dba6ee3-ac03-4025-b658-d01cb6529ed4/image.png)

참고로 이모지는 다 똑같은 이모지이다.

하나의 css,html,자바스크립트를 만들면 사용자들에게 동일한 경험을 주려고 브라우저와 개발자도 웹표준을 지키려고 노력하는 것이다.

ECMAScript 보면 스테이지 제로부터 4까지 올라가는 구조
스테이지가 높아지면 년도 스팩에 반영되는 식으로 프로세스에 반영됨

자바스크립트가 성장하는 속도랑 타입스크립트랑 성장 속도가 다르다.
그렇기 때문에 공부할 때 이런 차이도 유념해야 한다.

타입스크립트도 프라이빗 필드가 있다.

특히 타입가드에 있는 문법들은 타입스크립트에도 있다.

프라이빗을 안쓰는 경우는 클래스를 안쓸때
프라이빗 필드라는 건 클래스에 종속이 있기때문에
관점이 다르다. 계층이 엄청 많이 나뉠때는 프라이빗을 사용하는 경우가 많다.

```js
class Animal {}

class Person extends Animal {}

class Developer extends Person {}
```

이런 경우에 많이 사용.

인터페이스같은 경우 객체를 묘사하고 원형을 설계하는 모델링 관점인데,
type alias 같은 경우 인터페이스가 하는 것들을 그럴싸하게 한다.

타입알리아스(타입에 별명을 다는거)이랑 인터페이스(객체)

결국 타입스크립트에서도 객체를 묘사하는 인터페이스를 제공하는거고,
자바스크립트 언어가 할당을 다 할 수 있는데, 다른언어로 먼저 공부한 사람들은 힘들어한다.

타입 알리아스는 다 때려넣을수있는 타입을 다는 변수로 생각하면 도움됨

타입스크립트를 쓰면 oop 얘기를 많이듣게되는데 리액트에서 클래스를 사용해서 개발하는 경우? 요즘 별로 없다. 에러 바운더리, 정말 상세한 라이프 사이클 다룰때, 이미 회사에 클래스 컴포넌트가 가득해서인 경우 제외하고 거의 없음

타입스크립트는 힘들어도 인터페이스와 클래스 먼저 공부하는게 낫다.

enum은 객체를 호출할 수 있다. 사용하면 편리한 기능들이 있다.

```ts
interface Person {
  name: string;
  age: number;
}

enum Car {}
console.log(Person); // 에러
console.log(Car); // 실제 자바스크립트 코드로 사용가능하다.
```

enum이 무조건 좋다 나쁘다 보다는 enum만의 장점을 생각해보자.

![](https://velog.velcdn.com/images/ninto_2/post/93ff6694-b07e-465c-a3d7-4d7bb39f5d88/image.png)

잘 찾고, 제안할 줄 알아야 한다.

신입 기대치는 회사마다 다른게 맞다.
이력서가 아니라 JD(잡 디스크립션)- 채용 공고 기준으로 지원자격 필수사항 정도가 기대치이다.
기대치는 매년 올라간다.

YAGNI, 클린코드 이런 얘기
내가 만든 서비스가 폐지되는걸 보며, 역량이 어떤 회사에서 빨리 만들어야될때도 있고 하는데 성급한 최적화하지말자, 비현실적인 리팩토링이나 클린코드에 몰두하지 말자라는 얘기가 많은데
간신히 일정을 지키는데 나보다 더 잘하는 사람들은 일정도 지키고 웹표준, 웹 접근, 최적화, 클린코드 작성 다 챙김 - 가장 현타많이옴
나보다 늦게 시작했는데 더 잘하는 사람보면 현타옴
(금방 나를 추월할때)

개발자 자유형식 자소서 어떻게 쓸까
자유는 없는 것 같다. 겨울에 롱패딩 입듯이 요즘 어차피 다 똑같다.
신입 프론트엔드 개발자 이력서, 좋은 개발자 이력서 검색해서 많은 레퍼런스 참고하고 내 입맛에 맞게 바꿔가면서 고쳐나가는걸 추천함
나라는 개발자를 표현할 수 있는 것이면 충분하다.
(자유롭게 나라는 사람을 표현하자)

3년차 프론트엔드에게 원하는 cs지식은 어느정도일까?
회사마다 다르지만, 네트워크는 빠삭하게 아는게 좋고 fe가 알아야하는 부분은 잘 이해해야한다.
그리고 OS와 JS가 엮이는 부분도 이제 캐치해야 한다.
이벤트루프에서 OS개념 뭐가 들어갈까? 브라우저나
이정도는 대답할 수 있어야 한다.

- 쓰레드, 프로세스, 동시성, 정도는 파악해야됨
- 이벤트루프를 논블로킹, IO 이런걸로 파악할 수 있어야함

내 가치가 회사를 다니든 독학을 하든 허들이 높아지는 속도보다 느리다면 빅테는 가기 어렵다. 경력이 쌓여도.

사이드 프로젝트보다 당연히 회사 코드이다.

- 회사코드는 전쟁터, 사이드 프로젝트는 예비군, 놀이터 정도
  대표적인 사이드 프로젝트 성공 사례
- velog
- qwer.gg
- 내 트리를 꾸며줘
- 내 가슴속 3천원

어려운 상황에서도 내가 할 수 있는 것을 찾고, 일을 만들어내서 정의하고 그것을 창출하는 사람으로 진화하도록 노력해야한다. 안그러면 계속 회피형 개발자가 된다. 문제가 생길때마다 이직하는 회피형 해결 스킬을 가지다보면 성장할 수 없다.

신입 포트폴리오의 기준 CRUD를 구현할 수 있는 정도?
나는 창의적이라 생각해도 면접관은 이미 어제 본 것 이다.
창의적인거에 너무 신경쓰지 말고, 좋은 서비스 혹은 좋은 프로덕트를 만든다고 생각하자.
만약 정말 창의적이면 그걸로 회사를 차리자. 투자도 받을 수 있지 않을까?
똑같은 포트폴리오 한 팀원들이 다 넣는다. 변별력도 없다.
창의적인 고통은 가지지말고 내 실력에 투자하자.
신입이라면 Realworld 만들기 추천 API도 좋음(무료 API까지 있음)
CRUD, 게시판, 페이지네이션, 댓글, 대댓글 다 되고
이상한 외국 개발자들이 자꾸 API에 스크립팅하는 못된 사례도 있어서 할만하다.
포코장의 추천.

SI회사에서 하는일, LG회사에서 만들다가 나온 오류들 떨거지들 고치는게 업무였음
스스로 객관화부터 하자.
4년동안 월간 어떤 개발했는지 12 \* 4로 작성해보자.
이력서 재작성
그 다음 회사 지원하면서 최소 30개정도 지원하면서 시장에서 얼마나 팔리는지 추가 객관화 해보자.

자소서는 어떤 포인트에 맞추어 작성하는 편이 좋을까
회사에서 요즘 선호하는 트랜드 단어같은 것이 있을까?

- 트랜드는 없고 지겨운 것은 있다.
- 겹치는 내용이 워낙 많다.
- 나는 어떤 개발자입니다. 나는 어떤 것을 선호하는 개발자입니다.
- 나는 어떤 것을 잘하는 개발자입니다.
- 나는 어떤 것을 경험해본 개발자입니다.
  이정도 키워드만 있으면 좋다.
- 나는 신입 개발자입니다는 적지 않았으면 좋겠다.
- Realworld는 웹페이지 이다.

우형같은경우 css 필수다.
잘해야된다.
네이버,라인 -> NTS
다음,카카오 -> DK테크인

t자형 인재에 대해 많이 알아보고, 나만의 모서리를 만들자.
정 답을 못찾겠다면 이미 가장 잘하거나 자신있는 것 vs 앞으로 잘하고 싶은 것 이런방향으로 골라보자.

질문리스트 달달 외워서만 가도 괜찮을까?

- 달달 외운 티가 나면 당연히 탈락
- 내재화해서 사례를 잘 엮어서 이해해서 내것으로 나만의 표현 방법으로 대답하자

기업 과제 많이 모으세요. 어차피 포폴 아무리 훌륭해도 코테에서 기업 과제에서 낙마한다. 기업과제 맨날 이거 시키네 모아서 포폴에 녹이자.

- 또 장바구니, 또 무한 스크롤 이런게 보임 이런것들을 내 포폴에 녹이자.

신입 포폴 다 거기서 거기인 수준으로 다들 잘하는 시기이기 때문에 왜, 어떻게 만들었는지, dicussion -> issue -> PR -> 코드리뷰 -> 시멘틱버저닝 -> Release
요 흐름 다 지키면서 개발하자.
그러면 많은걸 배우고 좋은 평가를 받을 수 있다.

어차피 채용공고 분석해보면 답이 나와있다. 뷰와 리액트 장인은 도구탓을 하지않는다.

타입스크립트 입문자 어렵게 이해한것이 오래가기 마련이다.

css의 기준은 프론트엔드 개발자로 먹고 살려면 회사에서 시키는 것을 어떻게든 기간안에 구현은 해야한다.
그리고 최소, flex box, 그리드 layout으로 뚝딱 구현할 수 있는 정도는 되어야 한다.

강점 찾기부터 먼저하자. 다양한 경험보다는 깊이 있는 실력이 더 중요하다.
일단 이력서부터 쓰자.
비슷한 연차의 분들과 네트워킹 하자.
잔디의 수보다 잔디의 내용이 중요하다.

개발자 되기 전의 커리어 공백은 굳이 중요하지 않다.
역량 많이 쌓고, 성장하는 시기였다.

- 삼성, 엘지는 이런거 따지기는 한다. 퇴사 사유 등
  이런데만 아니면 상관없다. 실력으로 갈 수 있는 회사를 가자.

퇴사사유, 공백기는 최대한 지원동기, 입사하고 싶은 이유로 전환하거나 치환하는 답변으로 스리슬쩍 넘어가야한다. 안그러면 계속 꼬리물고 계속 공격당하고 계속 답정너로 확신을 요구당한다.

내가 한 선택에 책임을 지기위해 공부하면 좋은 회사간다.

코드를 작성할때 어디정도까지 모듈화 세분화 진행해야할까

- 일단 확장을 얼마나 열어둘까부터 정하자
- 회사에서 그리고 개발팀에서 얼마나 확장 가능해야한지가 우선순위이다.
- 재활용할 일도 없는데 굳이 일벌리는 것보다는 다른 일을 해서 생산성을 늘리고 회사의 비즈니스 가치를 늘려서 나와함께 일한 동료의 TO가 늘어나도록 하는게 이득이고 그 다음에 그 동료랑 그 확장성을 위한 일을 하는게 좋다.
  어디까지하냐에 답은 없다.

가장 중요한 것은 그 답을 찾아가는 논리와 그리고 가설 그리고 최종적으로 검증이고 그 훈련을 자주해야한다.
우리회사에서 얼마나 어디까지 모듈화를 하고 세분화 하는게 회사에 그리고 비즈니스에 도움이 될까 꾸준히 가설을 세우고 수립하고 검증하고 실천해야 좋은 회사를 가고 면접때 엄청난 대답을 할 수 있다.

리액트 쿼리 왜쓰셨어요? 물어보면 공식문서에 써있는거 대답하는데
사실 우리 회사에서 프로젝트에 이런 문제가 있었고, 이런거 비교해서 이런 장점이 있었고 이런 선택을 해서 어떤 이득을 봤습니다. 이런 대답이 가능해야 한다.

문서에 있는거 답변만 하는게 물경력임
스스로 프로젝트 3-4개 들고가는데 수동적인 답변은 하지 말아야한다.

TS책은 러닝 타입스크립트, 타입스크립트 프로그래밍, 이펙티브 타입스크립트(이건 제발 마지막에 읽자)
이펙티브 책 정말 좋은데 지금 읽는 것보다 나중에 읽는것이 이득이기 때문이다.
