### React는 왜 필요한걸까?

먼저, 리액트를 사용하기 전에 리액트가 왜 필요한 것 인지에 대해 태연하게 답을 할 수 있어야 한다.
어떤 기술도 이유 없이 만들어지진 않는다.
모든 기술은 현재 세상에 불편한 점을 해결하기 위해 만들어졌고, 발전 해왔다.
그래서 어떤 기술을 배운다는 것은 단순히 사용법만 배우는 것을 의미하지 않는다.
단순 사용법만 배우게 되면 기술에 대한 시야가 좁아지게 된다.
기술에 대한 시야가 좁아진다는 것은 문제 해결 능력이 부족해 진다고 볼 수 있다.
이런 상태가 되면 내가 배운 것이 아니라면 또는 내가 겪어본 일이 아니라면 해결할 수 없게 되고, 심하면 해결 할 의지 조차 갖지 못하게 된다.
그리고 이런 개발자를 원하는 세상은 결국엔 없다.

따라서 리액트라는 기술이 왜 필요했고, 훌륭한 기술로 인정 받는지 그 이유에 대해 알 필요가 있다.
리액트가 자주 사용되는 이유는 많지만, 리액트의 대표적인 3가지 장점을 위주로 생각해보자.

1. **리액트는 Component 기반의 UI 라이브러리 이기 때문에 재사용, 유지보수 측면에서 유리하다.**

```html
<!-- index.html -->
<body>
  <header>
    <h1>안녕하세요.</h1>
  </header>
  <nav>
    <ul>
      <a href="./index.html"><li>Home</li></a>
      <a href="./about.html"><li>About</li></a>
    </ul>
  </nav>
  <article>
    <h3 style="color: blue">여기는 Home 입니다.</h3>
  </article>
  <footer>
    <p>방문해주셔서 감사합니다.</p>
  </footer>
</body>
```

위 4가지 섹션(header, nav, article, footer)을 가지고 있는 `index.html` 처럼 순수한 HTML 웹 파일에서 article에 표시되는 `Home`이라는 글자만 About 링크를 클릭했을때 `About`으로 바꾸고 싶다면 어떻게 해야 할까?

```html
<!-- about.html -->
<body>
  <header>
    <h1>안녕하세요.</h1>
  </header>
  <nav>
    <ul>
      <a href="./index.html"><li>Home</li></a>
      <a href="./about.html"><li>About</li></a>
    </ul>
  </nav>
  <article>
    <h3 style="color: red">여기는 About 입니다.</h3>
  </article>
  <footer>
    <p>방문해주셔서 감사합니다.</p>
  </footer>
</body>
```

원초적인 HTML 파일 하나 만들어서 동일한 코드를 복사 후 에 `<h3>`의 텍스트 부분을 About으로 수정하면 해결 할 수 있다. 결론적으로 두 파일은 article 섹션만 다르고, 나머지 섹션(header, nav, footer)은 비슷한 정도가 아니라 아예 똑같다.

모두 다 똑같은 구성요소, 똑같은 코드로 이루어져 있다는 것을 확인할 수 있고 너무나도 많은 중복되는 부분들이 존재한다는 문제점을 가지게 된다.
만약 이런 상황에서 100개의 파일에서 동일한 header 섹션 내의 내용을 또 바꿔야 한다면, 모든 페이지에 중복으로 들어가 있는 header를 100번 수정해야 되는 불편함을 가지게 된다.

이렇듯, 중복 코드로 인해서 또는 중복 코드들의 변경사항으로 인해 중복 코드들이 포함되어 있는 모든 페이지를 다 수정해야 되는 이런 상황을 Shotgun Surgery(산탄총 수술)이라고 한다.

즉, 유지보수 상황에서 엄청나게 큰 문제가 생기게 된다.

하지만 우리가 사용하는 페이지들은 페이지 별로 이런 공통적인 요소들이 존재하고 있다.
결론적으로 이런 공통 요소들을 안 쓸 수는 없다. 그렇다고 수정 사항이 생길 때마다 산탄총 수술을 할 수도 없다.

다시말해 공통 요소를 쓰지만, 산탄총 수술을 안해도 되는 코드를 사용해야 한다.

```jsx
<body>
  <MyHeader />
  <MyNav />
  <MyFooter />
</body>
```

그래서 만약 중복 될 것이라고 예상되는 공통적으로 사용되는 요소들(header, nav, footer)을 별도의 파일이나 모듈로
제작해 놓은 뒤에 컴포넌트 별로 구분지은 뒤, 각각 필요한 파일 혹은 페이지마다 그 컴포넌트의 이름으로 불러다 쓰는 방식으로 코딩을 하면 된다.

![](https://velog.velcdn.com/images/ninto_2/post/6e264e0d-98de-44ae-90bb-53346ee12b0b/image.png)

1차원적으로만 봤을 때의 이점은 확실히 페이지를 추가적으로 만들어야 할 때, 타이핑해야되는 코드의 양이 줄어든다.
이렇게 재사용되어야 하는 요소들(공통적으로 다른 페이지에도 사용되야할 요소)을 컴포넌트로 만들어서 사용하는 방식을 컴포넌트화 방식이라고 한다.

컴포넌트화 방식은 그 컴포넌트가 정의되있는 파일만 수정하면, 그 파일을 불러다가 쓰는 다른 페이지들은 자동으로 수정되게 된다.(산탄총 수술을 할 필요가 없어진다.)

이런식으로 컴포넌트화 방식을 사용해서 코드를 작성하게 되면 유지보수 측면에서 훨씬 쉬워진다.
따라서 이런 컴포넌트화 방식을 사용할 수 있도록 도와주는 리액트를 사용해야 된다.

> **리액트는 Component 기반의 UI 라이브러리 이다.**

이런 html 요소들을 다 컴포넌트로 만들어서 재사용할 수 있는 아주 훌륭한 기술을 가지고 있다.
마치 리액트로 웹을 개발하다 보면 레고를 만들어서 조립하는 것 같은 느낌으로 개발할 수 있어서 굉장히 편리하다.

2.

```html
<head>
<script>
  function plus() {
    const result = document.getElementById('result');
    const current = parseInt(result.innerText, 10);
    result.innerHTML = current + 1;
  }
  function minus() {
    const result = document.getElementById('result');
    const current = paresInt(result.innerText, 10);
    result.innerHTML = current - 1;
  }
</script>
</head>
</body>
<p>Simple Counter</p>
<h2 id='result'>0</h2>
<div>
  <button onclick='minus()'>Minus</button>
  <button onclick='plus()'>Plus</button>
</div>
<script src='src/index.js'></script>
<body>
```

위 코드는 html과 바닐라 자바스크립트를 이용해서 간단한 카운터 기능을 하는 코드이다.
이 카운터는 Minus를 누르면, 숫자가 1씩 감소하고 Plus를 누르면, 숫자가 1씩 증가한다.
각각 버튼을 눌렀을때 어떤 동작을 할 것인지는 plus와 minus 함수에 구현이 되어있다.

위 코드를 자세히 살펴보면, 아래와 같은 순서의 로직을 가지고 있는 것을 확인할 수 있다.

1. 결과를 표시할 요소를 가져온다. (id = result)
2. 현재 결과값을 10진수 기준, 숫자형으로 변환해서 current라는 상수에 저장한다.
3. current 상수에 저장된 값을 결과를 표시할 요소의 값에 plus라면 +1, minus라면 -1을 해서 넣어준다.

위와 같은 프로그래밍은 명령형 프로그래밍이라고 하며, 절차를 하나하나 다 나열 해야한다는 특징을 가지고 있다.

명령형 프로그래밍: jQuery < 선언형 프로그래밍: React

Browser DOM(Document Object Model) < Virtual DOM

### React App 만드는 방법

- React : Node 기반의 Javascript UI 라이브러리
- 추가적인 라이브러리가 필요하다 (Webpack, Babel)
  - Webpack: 다수의 자바스크립트 파일을 하나의 파일로 합쳐주는 모듈 번들 라이브러리
  - Babel(자바스크립트 컴파일러): JSX등의 쉽고 직관적인 자바스크립트 문법을 사용할 수 있도록 해주는 라이브러리
  - 하나하나 다 설정할 필요없이 Boiler Plate 사용해도 가능함

### JSX

### State(상태)

- 계속해서 변화하는 특정 상태
- 상태에 따라 각각 다른 동작을 함

### Props

### 컴포넌트 & 데이터 구조 생각하기

- 컴포넌트 트리
- 단방향 데이터 흐름
- EVENT(역방향) , DATA(단방향)

### Lifecycle 제어하기

- Lifecycle : 생애주기
  (Mount -> Update(리랜더) -> UnMount)
  (초기화 -> 예외처리 -> 메모리정리)
- ComponentDidMount -> ComponentDidUpdate -> ComponentWillUnmount
  (Class React Component Only)

### React Hooks (2019.6 정식출시된 기능)

- useState, useEffect, useRef
  (함수형 컴포넌트에서 클래스형 컴포넌트 기능을 낚아채듯 사용가능)
- useEffect : Lifecycle 메서드 훔쳐올 수 있음
- 클래스형 컴포넌트 단점: 길어지는 코드 길이문제, 중복 코드, 가독성 문제 ...
- 클래스형 컴포넌트 < 함수형 컴포넌트 사용하는 추세

```jsx
import React, { useEffect } from "react";

// 첫번째 파라미터론 콜백함수 전달, 두번째 파라미터는 Dependency Array(의존성 배열) 전달
useEffect(() => {
  // ...
}, []);
```

- 의존성 배열(뎁스): 이 배열 내에 들어있는 값이 변화하면 콜백함수가 실행됨

### React API 호출

- JSONPlaceholder 사이트 -> Resources

### React Developer Tools

- Chrome Web Store -> React Developer Tools ->

### Memoization (연산 결과 재사용하기)

- 이미 계산해본 연산 결과를 기억해 두었다가 동일한 계산을 시키면,
  다시 연산하지 않고 기억해 두었던 데이터를 반환 시키게 하는 방법

- 연산 최적화 하기(답을 기억해둔다. -> 기억해 두었던 답을 다시 적는다.)
- useMemo
