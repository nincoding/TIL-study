

- 배열이란?

배열은 값의 순서 있는 집합입니다.
각 값을 요소라고 부르며 각 요소에는 배열에서 차지하는 위치를 나타내는 숫자인 인덱스가 있습니다.

자바스크립트 배열에는 타입이 없습니다.
배열 요소는 어떤 타입이든 상관없고, 배열 하나에 여러 타입이 섞여 있어도 괜찮습니다.
배열 요소에 객체나 다른 배열을 써도 상관없으므로 객체로 이루어진 배열이나 배열로 이루어진 배열 같은 복잡한 데이터 구조를 만들 수 있습니다.

자바스크립트 배열은 0으로 시작하는 32비트 인덱스를 사용합니다.
첫번째 요소의 인덱스는 0이고 인덱스는 커질 수 있는 최댓값(대략 42억)이 정해져 있으므로, 요소의 수도 마찬가지입니다.

자바스크립트 배열은 동적입니다.
필요한 만큼 커지거나 작아질 수 있고, 배열을 생성할 때 고정된 크기를 선언하거나 크기가 변할 때 배열을 재할당할 필요가 없습니다.

자바스크립트는 성긴(sparse) 배열을 허용합니다.
요소의 인덱스가 꼭 이어질 필요가 없고 그 사이에 갭이 있어도 됩니다.

자바스크립트 배열에는 모두 length 프로퍼티가 있습니다.
- 성기지 않은 배열에서 이 프로퍼티는 배열에 포함된 요소 숫자입니다.
- 성긴 배열에서 이 프로퍼티는 배열 내 가장 큰 인덱스보다 큽니다.

자바스크립트 배열은 객체의 특별한 형태입니다.
배열 인덱스는 프로퍼티 이름이 정수인 것과 별로 다르지 않습니다.
배열이 특별한 이유는 뒤에서 자세히 살펴봅시다.

자바스크립트 실행환경은 일반적으로 배열을 최적화하므로 숫자로 인덱스된 배열 요소는 일반적인 객체 프로퍼티보다 상당히 빠르게 접근할 수 있습니다.

배열은 `Array.prototype`에서 프로퍼티를 상속합니다.
이 프로토타입에는 배열 조작 메서드가 많이 포함되어 있습니다.
이런 메서드는 대부분 배열 뿐만 아니라 배열 비슷한 객체에서도 정확히 동작하는 범용 메서드입니다.
배열 비슷한 객체는 뒤에서 자세히 살펴봅시다.

자바스크립트 문자열은 문자로 구성된 배열처럼 동작합니다.
배열은 문자열도 뒤에서 자세히 살펴봅시다.

ES6에서 형식화 배열(typed array)이라 부르는 새로운 배열 클래스를 몇 가지 도입했습니다.
형식화 배열은 이번 장에서 다루진 않지만, 간단히 살펴보자면 일반적인 배열과 달리 길이가 고정적이며 요소 타입도 숫자로 고정되어 있습니다.
형식화 배열은 아주 빠르고 이진 데이터에 바이트 수준으로 접근 할 수도 있습니다.

- 배열을 만드는 방법

배열을 만드는 방법은 여러가지 입니다.
1. 배열 리터럴
2. 이터러블 객체에 분해 연산자 ... 적용
3. `Array()` 생성자
4. `Array.of()`와 `Array.from()` 팩토리 메서드

@ 팩토리 메서드는 부모 클래스에서 객체들을 생성할 수 있는 인터페이스를 제공하지만, 자식 클래스들이 생성될 객체들의 유형을 변경할 수 있도록 하는 생성 패턴입니다.

## 배열 리터럴

배열 리터럴은 배열 요소를 대괄호 안에 콤마로 구분한 리스트 형태입니다.
배열 리터럴에 상수를 쓸 필요없이 임의의 표혁식을 써도 됩니다.
배열 리터럴 안에 개체 리터럴이나 다른 배열 리터럴을 써도 됩니다.
배열 리터럴에 콤마를 연속해서 썼는데 그 사이에 값이 없으면 성긴배열이 만들어집니다.
값을 생략한 위치에 실제로 배열 요소가 존재하지는 않지만, undefined가 반환됩니다.
배열 리터럴 문법은 마지막에 콤마를 허용합니다.

## 분해 연산자

ES6 이후에는 분해 연산자 ...를 써서 배열 리터럴 안에 다른 배열 요소를 넣을 수 있습니다.
분해 연산자는 배열을 얕게(shallow)복사 할 때도 유용합니다. (의문점- 얕은복사는 원본건드리는데 예제엔 안변함 183p)
분해 연산자는 모든 이터러블 객체에 동작합니다.
이터러블 객체는 for/of 루프의 대상이 될 수 있는 객체입니다.
문자열 역시 이터러블이므로 분해 연산자를 적용해 글자 하나하나의 배열로 바꿀 수 있습니다.
Set 역시 이터러블 입니다.
배열에서 중복된 요소를 제거하고 싶을땐, 배열을 Set으로 변환 후 즉시 분해 연산자를 써서 배열로 되돌릴 수 있습니다.
@ 배열의 1차원, 2차원에서의 spread deep, shallow copy
@ 이터러블

## `Array()`생성자

1. 인자 없이 호출
  - 요소 없는 빈 배열을 생성하며 배열 리터럴 `[]`과 동등합니다.
2. 배열 길이를 나타내는 숫자 인자 하나로 호출
  - 지정된 길이를 가진 배열을 생성합니다.
  - 아직 배열에 값을 지정하지 않았고 배열 인덱스도 정의하지 않았습니다. (empty, undefined)
3. 배열 요소를 두개 이상 쓰거나 숫자가 아닌 요소를 하나만 넘겨 호출
  - 생성자의 인자가 새 배열의 요소가 됩니다. (이렇게 쓸 바에 배열리터럴이 더 단순하다.)

`Array()` 생성자는 숫자 요소가 하나만 있는 배열은 생성 할 수 없다.

## `Array.of()`

ES6의 `Array.of()`함수는 위 문제를 해결합니다.
인자의 개수를 따지지 않고 각 인자를 새 배열의 요소로 사용합니다.

## `Array.from()`

ES6에서 도입한 팩토리 메서드 입니다.
@ 팩토리 메서드
첫 번째 인자로 이터러블 객체나 배열 비슷한 객체를 받으며, 해당 객체의 요소로 새 배열을 만들어 반홥합니다.
분해 연산자를 사용한 `[...iterable]`과 동등합니다.
이 메서드가 중요한 이유는 배열 비슷한 객체를 진정한 배열로 바꾸는 방법이기 때문입니다.
- 배열 비슷한 객체란(유사 배열 객체)? 숫자인 length 프로퍼티가 있고, 이름이 정수인 프로퍼티에 값이 저장된 객체를 말합니다.

`Array.from()`은 선택 사항으로 두 번째 인자를 받습니다.
두 번째 인자로 함수를 전달하면, 새 배열을 생성할 때 소스 객체의 각 요소를 이 함수에 전달하고 반환 값을 배열에 저장합니다.
이 동작은 map과 아주 비슷하지만, `Array.from()`으로 배열로 만든 다음 다시 map을 써서 변환하기 보다는 처음부터 콜백 함수를 써서 변환하는 것이 더 효율적입니다.


- 배열을 조작하는 방법

## 배열 요소 읽기와 쓰기

배열 요소에 접근할 때는 `[]`연산자를 사용합니다.
대괄호 왼쪽에는 배열 참조가 있어야 하며, 대괄호 안에는 양의 정수로 평가되는 표현식이 있어야 합니다.
이 대괄호는 객체 프로퍼티에 접근할 때 사용하는 대괄호와 마찬가지로 동작합니다.
자바스크립트는 숫자인 배열 인덱스를 문자열로 변환합니다.
배열 인덱스에는 음수도, 정수 아닌 숫자도 쓸 수 있습니다. (문자열로 변환해서 프로퍼티 이름으로 사용하기 때문)
양의 정수로 평가되는 문자열을 인덱스로 사용하면 배열의 인덱스로 취급하고, 그 외는 객체 프로퍼티로 취급합니다.
그렇기에 자바스크립트 배열에는 경계초과 에러는 일어나지 않고 undefined를 반홥합니다.


- 성긴 배열 

## 성긴 배열 (희소 배열 Sparse Array)



- 배열 비슷한 객체
- 배열인 문자열



## 배열 생성
### 배열 리터럴
### 분해 연산자
### `Array()`생성자
### `Array.of()`
### `Array.from()`

## 배열 요소 읽기와 쓰기

## 성긴 배열

## 배열 길이

## 배열 요소 추가와 삭제

## 배열 순회

## 다차원 배열

## 배열 메서드
### 배열 이터레이터 메서드
- `forEach()`
- `map()`
- `filter()`
- `find()와 findIndex()`
- `every()와 some()`
- `reduce()와 reduceRight()`

### `flat()`과 `flatMap()`을 사용한 배열 평탄화
### `concat()`으로 배열 병합
### 스택과 큐 메서드
### 하위 배열
- `slice()`
- `splice()`
- `fill()`
- `copyWithin()`

### 배열 검색과 정렬 메서드
- `indexOf()`와 `lastIndexOf()`
- `includes()`
- `sort()`
- `reverse()`

### 배열을 문자열로 변환

### 정적 배열 함수

## 배열 비슷한 객체

## 배열인 문자열

![](https://velog.velcdn.com/images/ninto_2/post/7ab0f51b-ec62-4487-a194-ab70e5fab4f1/image.png)

<h2 id='1'>📌 목차</h2>

- **🌱 배열과 특징**

	
    - **자바스크립트의 배열 (Array)**
	
    - **희소 배열 Sparse Array (= 성긴 배열)**
    
    - **문자 배열 (= 배열인 문자열)**
    
    - **다차원 배열**
    
    - **유사 배열 객체 (= 배열 비슷한 객체)**
	
    - **Iterable (이터러블)** 
    
- **🌱 배열 조작과 메서드**

	
    - **배열 생성하기**
	
    - **요소 추가/삭제하기**
    
    - **배열 대체/복사하기**
    
    - **배열 평탄화/병합하기**
    
    - **배열 순회/탐색/정렬하기**

<br>

***

<h3 id='2'>📌 자바스크립트 배열</h3>

> **배열이 배열이 아니라고? 😨**

`'자바스크립트의 배열은 배열이 아니다.'` 라던가 `'자바스크립트의 배열에는 타입이 없다.'` 라는 말을 들어본 적이 있을 것 입니다.

실제로 아래와 같이 console에 배열의 타입을 찍어보면 'array'가 아닌 'object'가 나옵니다.

```js
typeof Array() // 'object'
```

그 이유를 알기 위해선 먼저, **자료구조에서 말하는 배열**에 대해 알 필요가 있습니다.

배열은 어느 프로그래밍 언어에나 존재하는 자료구조 입니다.
기본적으로 값의 순서있는 집합이며, 안의 값을 요소(element)라고 합니다.

> **배열은 프로토타입으로 탐색과 변형 작업을 수행하는 메서드를 갖는, 리스트와 비슷한 객체(list-like objects)입니다.** -MDN

여기서 말하는 리스트는 자료구조에서 말하는 배열과 비슷합니다.
자료구조에서 말하는 배열(Array)은 **동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조**를 의미합니다.

![](https://velog.velcdn.com/images/ninto_2/post/10bbaca5-2c15-4489-92ea-6d2ae626975d/image.png)


위의 그림과 같이 각 요소가 동일한 데이터 크기를 가지며, 빈틈없이 연속적으로 이어져 있습니다. 이러한 배열을 **밀집 배열(Dense Array)**이라고 하며, 인덱스를 통해 단 한 번의 연산으로 임의의 요소에 접근이 가능합니다.

하지만, **자바스크립트의 배열은 요소가 동일한 크기의 메모리 공간을 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수 도 있습니다.** 

또한, `원시값, 객체, 함수, 배열 등 어떤 타입의 값`이라도 요소가 될 수 있습니다.

```js
const arr = [
  1, 'a', true, null, undefined, , [], {}, function(){}, Symbol(),
    ];
```
![](https://velog.velcdn.com/images/ninto_2/post/6db96731-432f-4a0c-a476-748fbd6271ee/image.png)

위 구조를 보면, 배열은 **인덱스와 요소, 길이를 나타내는 length 프로퍼티**를 가지고 있는 것을 확인할 수 있습니다. 
그런데 얼핏보면, 인덱스를 키로 가지고 요소를 값으로 가지고 있는 객체와 유사해 보입니다. 
또한 자세히 살펴보면, 길이는 10으로 찍히지만 5번째 요소는 비어있음으로 찍히며 포함되어 있지 않은 것을 볼 수 있습니다.

그 이유는 자바스크립트의 배열이 일반적인 배열의 동작을 흉내 낸 **특수한 객체**이기 때문입니다.

```js
console.log(Array.isArray(arr)); // true
console.log(arr.constructor === Array); // true
console.log(Object.getPrototypeOf(arr) === Array.prototype); //true
```
이 코드만 살펴보아도 자바스크립트의 배열이 객체라는 것을 알 수 있습니다. 하지만 일반적인 객체와는 차이점이 있는 특수한 객체라는 점을 살펴보아야 합니다.

```js
console.log(Object.getOwnPropertyDescriptors(arr));
```
![](https://velog.velcdn.com/images/ninto_2/post/d8306ade-5676-49bc-bda5-847699cda8f3/image.png)

자바스크립트 배열의 내부를 살펴보면, 이러한 **해쉬테이블로 구현**되있는 것을 확인할 수 있습니다.


> 자바스크립트의 배열은 사실 **인덱스를 나타내는 문자열을 프로퍼티 key로 가지며, value 값으로 배열의 요소를 갖고, length 라는 프로퍼티를 갖는 특수한 객체**입니다.

인덱스를 문자열 프로퍼티 key로 가지기 때문에, 배열의 요소에 접근할때 대괄호안에 인덱스를 넣는 것 만으로도 해당 요소의 값을 가져 올 수 있습니다.

```js
arr[0]; // 1
arr[1]; // 'a'
arr['1']; // 'a'
arr[1] === arr['1'] // true
```

일반적으로 배열 인덱스는 0이상 2의 23승 - 2(약 42억) 이하의 정수를 가지며, 그 외의 경우는 객체의 프로퍼티로 취급합니다.

```js
arr[-9999]; // undefined
arr[9999]; // undefined
arr['a'] // undefined
```

그렇기 때문에 존재하지 않는 인덱스로 요소에 접근해도 에러없이 undefined를 반환할 뿐입니다.



<br>

***

<h3 id='3'>📌 희소 배열 Sparse Array</h3>

본 책에서는 성긴 배열이라고 기재되었지만, 희소 배열과 같은 말입니다.

> **희소배열은 요소들의 인덱스가 연속적이지 않은 배열입니다.**

![](https://velog.velcdn.com/images/ninto_2/post/445d2d55-4bd5-412f-960c-bb201da589d3/image.png)


**자바스크립트의 배열**이 자료구조에서 말하는 밀집 배열(Dense Array)과 다른 점은 이러한 **희소 배열(Sparse Array)을 허용**하기 때문입니다.

자바스크립트 배열은 내부적으로 해쉬 테이블로 구현되어 있기 때문에 메모리 주소가 연속적으로 나열되지 않습니다.
또한 배열의 요소가 동일한 메모리 크기를 갖지 않아도 되기에 여러가지의 타입을 하나의 배열 안에 넣을 수 있습니다.

> **그렇다면, 자바스크립트는 왜 밀집배열이 아닌 희소배열을 택했을까? 🤔**

||일반적인 배열|자바스크립트 배열|
|:----|:----:|:----:|
|인덱스로 요소 접근|O(1)|O(n)|
|요소 탐색,추가,삭제|평균의 경우 O(n)|평균의 경우 O(1)|

<br>

일반적인 배열의 경우 인덱스로 요소에 빠르게 접근이 가능하지만, 자바스크립트의 배열은 해시 테이블로 구현된 객체이므로 **일반적인 배열보다 성능적으로 느립니다.**

만약 인덱스로 주어진다면 해당 인덱스와 같은 키값을 찾으려고 O(n)의 시간복잡도를 가지는 순차검색을 해야하기 때문입니다.


하지만 **탐색, 추가, 삭제에서의 성능**은 자바스크립트의 배열이 일반적인 배열에서의 시간 복잡도보다 **더 빠른 성능**을 가지게 됩니다.

이런식으로 자바스크립트는 탐색, 추가, 삭제에 의한 장점이 더 크다고 판단해 희소 배열인 해쉬 테이블로 배열을 구현한 것입니다.

>**자바스크립트 배열과 일반 객체의 성능비교**

```js
// 배열에서의 인덱스로 요소접근 약 340ms
const arr = [];
for (let i = 0; i < 10_000_000; i++) {
	arr[i] = i;
}

// 일반객체에서의 인덱스로 요소접근 약 600ms
const obj = {};
for (let i = 0; i < 10_000_000; i++) {
	obj[i] = i;
}
```

모던 자바스크립트 엔진은 인덱스로 요소에 접근할 때의 단점을 보완하기 위해 배열을 **일반 객체와 구별하여 좀 더 배열처럼 동작하도록 최적화하여 구현**했습니다.

<br>

> **희소배열을 만드는 방법**

희소배열을 만드는 방법은 여러가지가 있습니다.

```js
// 길이가 3인 희소배열 만들기

const arr1 = new Array(3);

const arr2 = [,,,];

const arr3 = [];
arr3.length = 3;

const arr4 = [];
arr4[2] = 0;

const arr5 = [1,2,3];
delete arr5[2];
```

**희소배열은 이렇듯 실제 요소의 개수보다 length가 큽니다.**


> **Q. 아래 배열 arr에 남아있는 요소와 길이는 몇 일까요? 🤔 ** 

```js
const arr = [,];

arr[2] = 'a';
arr.shift();
arr.push('b');
delete arr[2];

arr.length;
```

왜 이런 결과가 나오는지는 배열의 **length프로퍼티가 가지고 있는 특징**을 함께 살펴보면 이해하기 쉽습니다.

> **Array.prototype.length**

![](https://velog.velcdn.com/images/ninto_2/post/b480b834-ec8c-4028-b37e-102cc371cc85/image.png)
