- 컨텍스트(실행 컨텍스트와 호출 컨텍스트)
- 화살표 함수
- 클로저
- 스코프
  - 블록 레벨 스코프, 함수 호이스팅
- 재귀함수와 콜백함수
- 생성자, 프로퍼티, 메서드
- 이터레이터, 제너레이터
- 비동기 함수
- 자바스크립트 인터프리터

# 함수

- 자바스크립트의 기본적인 구성 요소
- 프로그래밍 언어의 공통 기능
- 서브루틴, 프로시저
- 함수: 한번 정의하면 몇 번이고 호출할 수 있는 자바스크립트 코드 블록
- 자바스크립트의 함수: 매개변수(식별자 리스트)화
- 함수 정의: 매개변수 -> 함수바디 안에서 지역 변수처럼 동작
- 함수 호출: 매개변수에 값(인자) 전달 -> 인자를 사용해 반환 값 도출(함수 호출 표현식의 값)
- 호출 컨텍스트(this 키워드의 값)
- 객체 메서드: 객체 프로퍼티로 할당된 함수
- 객체를 통해 함수 호출 -> 그 객체가 호출 컨텍스트, 함수의 this값이 됨
- 생성자 함수: 객체를 새로 만들 목적으로 설계한 함수
- 함수는 객체다 (프로그램에서 조작 가능)
  - 함수형 프로그래밍
  - 함수를 변수에 할당 -> 다른 함수에 전달 가능
  - 프로퍼티 정의 가능
  - 함수의 메서드 호출 가능
- 자바스크립트의 함수는 다른 함수 안에서 정의 가능
- 이렇게 정의된 함수는 자신이 정의된 스코프의 변수에 접근 가능
- 자바스크립의 함수는 클로저다.
  - 클로저를 잘 다루면 강력한 프로그래밍 기법을 사용할 수 있다.

<br>

---

## 함수 정의

`function 선언, 함수 표현식, 화살표 함수`

### 📌 함수 선언

- `function` 키워드: 함수를 정의하는 가장 단순한 방법
- 선언으로든, 표현식으로든 사용이 가능하다.
- 식별자: 함수 선언에서 뺄 수 없는 부분(변수 이름으로 사용되며, 정의한 함수가 할당됨)
- 식별자 리스트: 괄호안의 0개 이상의 콤마로 구분한 식별자 리스트, 매개변수의 이름, 함수 바디안에서 지역 변수로 동작함
- 함수 바디: 중괄호로 감싼 0개 이상의 자바스크립트의 문, 함수를 호출할 때마다 실행됨

```js
function identifier (_, _, _) {
  ...
}
```

- 함수의 이름은 변수다.
- 함수는 값 자체다.
- 함수 선언문은 호이스팅이 발생한다. (자신을 포함하는 스크립트, 함수, 블록)맨 위로 끌어올려짐
- 함수 선언문으로 정의한 함수는 정의하기 전에도 호출이 가능하다.

```js
const num = 10;
identifier(num); // 100

// 함수 선언문이 밑에 있어도 호이스팅으로 사용가능
function identifier(num) {
  return num * num;
}
```

```js
console.log(func1()); // 100
console.log(func2()); // ReferenceError: func2 is not defined

function func1() {
  const num = 10;
  return func2(num);

  // func2는 func1의 블록안에 존재함
  function func2(num) {
    return num * 10;
  }
}
```

- 블록 안에서 선언된 함수는 모두 그 블록 전체에 존재하며, 자바스크립트 인터프리터가 해당 블록의 코드를 실행하기 전에 함수를 먼저 정의하게 된다.
  (선언된 함수가 존재하면, 함수가 먼저 정의되고 실행이 이루어진다.)

```js
function func1() {
  console.log(func2()); // undefined

  function func2() {
    return;
  }
}
func1();
```

- return문: 함수 실행을 멈추고 바로 다음에 있는 표현식의 값을 호출자에게 반환
  (return문 다음에 표현식이 없다면 undefined를 반환한다.)
- 함수의 목적에 따라 return문이 없어도 된다.
  (함수에 return문이 없으면 함수 바디의 문을 끝까지 실행하고 호출자에게 값을 반환함)

ES5이전에는 최상위 레벨에서만 함수를 선언할 수 있었음
루프나 조건문, 기타 블록문 안에서 함수를 정의하는 것은 위 사항을 어기는 일이였음
하지만 ES6 스트릭트 모드에서는 블록 안에서 함수를 선언할 수 있게 되었다.
블록 안에서 정의한 함수는 해당 블록 안에서만 존재하며 외부 블록에선 볼 수 없다.

### 함수 표현식

```js
const func = function () {
  ...
}

```

- 변수를 선언하여 그 변수에 함수 객체를 할당한다.
- 함수는 이름으로 자기 자신을 참조할 수 있다.
- 함수 표현식에 이름이 있는 경우, 로컬 함수 스코프에서 그 이름으로 함수 객체를 참조한다.
  (함수 이름은 함수 안에서 로컬 변수가 된다.)
- 표현식으로 정의한 함수는 대부분 이름이 필요없으므로 정의가 더 간결하지만, 화살표 함수보단 간결하지 않다.
- 함수를 정의하는 표현식이 실제로 평가되기 전에는 함수가 존재하지 않는다.
- 표현식으로 정의된 함수는 변수에 할당하기 전에는 참조, 호출 할 수 없다.

### 📌 화살표 함수

```js
const func = () => {
  return 10;
};
const func1 = (x) => x + 10;
const func2 = (x, y) => x + y;
const func3 = (x, y) => {
  return { x: y };
};
```

- 화살표 함수: ES6에서 도입, `function` 키워드 없이 함수를 정의하는 새로운 방법
- 아주 간결한 장점, 다른 함수에 인자로 전달(콜백함수로 사용될 때)할 때 특히 유용하다.
- 화살표를 사용해 함수 매개변수와 함수 바디로 구분한다.
- 화살표 함수는 문이 아니라 표현식이므로 `function`키워드와 함수이름이 필요없다.
- 화살표 함수는 상황에 따라 괄호와 중괄호 return이 생략 가능하다.
- 화살표 함수는 문법이 간결하여 함수자체를 다른 함수에 전달할때 자주 사용된다. (콜백함수로 자주 사용됨)
- 다른 방법으로 정의된 함수는 자신만의 호출 컨텍스트를 정의하지만,
  화살표 함수는 자신이 정의된 환경의 this 키워드 값을 상속한다. (함수선언과 화살표 함수의 차이점)
- 화살표 함수는 prototype 프로퍼티가 없으므로 새로운 클래스의 생성자 함수로 사용할 수 없다.

### 중첩된 함수

```js
function init() {
  var name = "Mozilla"; // name은 init에 의해 생성된 지역 변수이다.
  function displayName() {
    // displayName() 은 내부 함수이며, 클로저다.
    console.log(name); // 부모 함수에서 선언된 변수를 사용한다.
  }
  displayName();
}
init();
```

자바스크립트에서는 다른 함수 안에 함수를 중첩할 수 있다.
중첩된 함수에서 흥미로운 것은 변수 스코프 규칙인데, 중첩된 함수는 자신을 포함하는 함수의 매개변수와 변수에 접근할 수 있다.
중첩된 함수에서 이러한 스코프 규칙은 아주 중요하며 자바스크립트의 클로저와 연결되는 개념이다.

<br>

---

## 함수 호출

함수 바디를 구성하는 자바스크립트 코드는 함수를 정의할 때가 아니라, 함수를 호출할때 실행된다.
자바스크립트 함수는 아래와 같이 5가지 방법으로 호출이 가능하다.

- 함수로 호출, 메서드로 호출, 생성자로 호출, `call()`과 `apply()` 메서드를 통해 간접호출, 묵시적 호출

각각의 호출 방법에 따라 어떤 차이점과 특징을 가지고 있는지 살펴보자.

### 함수로 호출

```js
function func(num) {
  return num * num;
}

const total = func(5) + func(10); //함수 호출 125
```

함수는 호출 표현식을 통해 함수 또는 메서드로 호출된다.
괄호 안에 들어 있는 각 인자 표현식을 호출 시점에서 평가한 값이 인자가 됩니다.
함수 바디에서는 각 매개변수가 이에 대응하는 인자로 평가됩니다.
일반적인 함수 호출에서는 함수의 반환 값이 호출 표현식의 값입니다.

```js
function func(x) {
  const num = 5;
  const result = x * num; //25
}
const num = func(5); //undefined
```

함수 바디안에 return을 만나지 않은채 인터프리터가 함수의 끝에 도달하면 반환 값은 undefined가 됩니다.
일반 모드에서 함수의 호출 컨덱스트(this)는 전역 객체입니다.
스트릭트 모드이 호출 컨덱스트는 undefined입니다.

```js
const obj = {
  x: 5,
  y: 10,
  func() {
    const func2 = () => {
      return this.x + this.y; //5 + 10
    };
    return func2() + func2(); // 15 + 15
  },
};

obj.func(); // 30
```

단, 화살표 문법으로 정의한 함수는 항상 자신이 정의된 곳의 this값을 상속합니다.
메서드가 아니라 함수로 호출되도록 설계된 함수는 일반적으로 this 키워드를 전혀 사용하지 않습니다.

```js
// 스트릭트 모드에 있는지 판단하는 함수
const strict = (function () {
  return !this;
})();
```

하지만 this 키워드를 사용해서 스트릭트 모드에 있는지 확인하는 것은 가능합니다.

#### 📌 조건부 호출

함수를 호출했을때 null이나 undefined인 상황을 방지하기 위해 조건부 호출을 사용할 수 있습니다.

```js
function func(x) {
  const num = 5;
  return x * num;
}

func !== null && func !== undefined ? func(x) : undefind;
```

ES2020에서는 함수 표현식과 여는 괄호 사이에 `?.`을 넣어서 함수가 null이나 undefined가 아닌 경우에만 호출하게 할 수 있습니다.

#### 📌 재귀 함수와 스택

```js
// 무한 호출되는 재귀함수
// RangeError: Maximum call stack size exceeded
function func() {
  func();
}
```

재귀함수는 자기 자신을 호출합니다.
트리기반 데이터 구조 같은 일부 알고리즘은 재귀 함수를 사용해 아주 명쾌하게 구현할 수 있습니다.
하지만 재귀함수를 만들때는 메모리를 고려하는 것이 중요합니다.

### 메서드로 호출

#### 📌 메서드 체인

### 생성자로 호출

### 간접적 호출

### 묵시적 함수 호출

<br>

---

## 함수 매개변수

### 선택 사항인 매개변수와 기본 값

### 나머지 매개변수와 가변 길이 인자 리스트

### Argument 객체

### 함수 호출과 분해 연산자

### 함수 인자를 매개변수로 분해

### 인자 타입

## 값인 함수

### 함수 프로퍼티 직접 정의

## 네임스페이스인 함수

## 📌 클로저

## 함수 프로퍼티,메서드,생성자

### length 프로퍼티

### name 프로퍼티

### prototype 프로퍼티

### call()과 apply()메서드

### bind()메서드

### toString()메서드

### Function()생성자

## 📌 함수형 프로그래밍

### 함수로 배열 처리

### 고계 함수

### 함수의 부분 적용

### 📌 메모이제이션

## 요약

- function 키워드, 화살표 함수 정의 차이점
- 메서드, 생성자
- 함수 매개변수에 기본 값을 할당하는 기능
- 나머지 매개변수를 사용해 인자 여럿을 배열에 모으는 기능
- 객체와 배열을 분해해 함수 매개변수로 사용하는 기능
- 분해연산자를 사용해 배열이나 이터러블 객체의 요소를 함수 인자로 전달해 호출
- 클로저 : 외부 함수 안에서 정의되고 반환된 함수는 외부 함수의 어휘적 스코프에 대한 접근을 유지
  (외부 함수에서 정의한 변수에 접근가능)
- 함수는 자바스크립트에서 조작 가능한 객체
  (함수형 프로그래밍 가능)
