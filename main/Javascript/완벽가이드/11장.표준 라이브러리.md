![](https://velog.velcdn.com/images/ninto_2/post/13375636-578d-493e-a046-4b42b868a4d3/image.png)

<h2 id = '1'>📌 목차 </h2>

- 🌱 **API와 Library, Framework**
  - **API**
  - **Library**
  - **Framework**

<br>

- 🌱 **Set과 Map**
  - **Set**
  - **Map**

<br>

- 🌱 **RegExp과 Ajax**
  - **정규 표현식과 패턴 매칭**
  - **JSON 직렬화와 분석**

<br>

- 🌱 **Date와 타이머**
  - **날짜와 시간**
  - **타이머**

<br>

- 🌱 **API**
  - **콘솔 API**
  - **URL API**
  - **국제화 API**
  - **Error 클래스**

<br>

- 🌱 **형식화 배열과 이진 데이터**

<br>

---

<h2 id='2'>📌 API와 라이브러리, 프레임워크 </h2>

![](https://velog.velcdn.com/images/ninto_2/post/9e7acf59-e4b1-4205-b9b8-0692af768ff1/image.png)

프로그래밍 언어를 배우는 것은 문법을 마스터한다고 끝나는 일이 아닙니다.
언어에 포함된 도구 전체에 익숙해질 수 있도록 **표준 라이브러리**를 공부하는 것도 마찬가지로 중요합니다.

그렇다면, 기본적으로 먼저 API와 라이브러리 그리고 프레임워크의 개념에 대해 살펴보고,
**자바스크립트의 표준 라이브러리**와 자주 사용되는 **API**에 대해 알아보는 것이 필요합니다.

<h3 id='2.1'>🔗 API </h3>

API란 무엇일까요? 🤔

> **API (Application Programming Interface)란, 응용 프로그램에서 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스입니다.**

![](https://velog.velcdn.com/images/ninto_2/post/9d5c21a2-b03f-4374-a6d0-0f55c380a4e6/image.png)

조금 더 쉽게 말하자면, 프로그램 사이의 연결을 시켜주는 다리라고 생각할 수 있습니다.

- 구현과 독립적으로 사양만 정의되어 있습니다.
- API에 따라서 접근 권한이 필요할 수 있습니다.
- 예시로 Java API, 여러 기업들의 오픈 API가 있습니다.

<br>

<h3 id='2.2'>🔗 Library </h3>

![](https://velog.velcdn.com/images/ninto_2/post/9110c88d-1a76-4ef6-87b0-41d274455281/image.png)

단어적으로만 보았을 때, Library는 도서관을 떠올리기 쉽습니다. 책들을 카테고리별로 모아놓은 것이 책장이라면, 도서관은 그런 책장들이 굉장히 많이 있는 것을 생각할 수 있습니다.

라이브러리란 무엇일까요? 🤔

> **Library란, 응용 프로그램 개발을 위해 필요한 기능(함수)을 모아 놓은 소프트웨어입니다.**

- 독립성을 가집니다. (해당 라이브러리는 다른 라이브러리를 의존하지 않는걸 의미합니다.)
- 응용 프로그램이 능동적으로 라이브러리를 사용합니다.
- Apache Commons, Guava, Lombok, jQuery 등이 있습니다.

<br>

<h3 id='2.2'>🔗 Framework </h3>

단어적으로만 보았을 때, `Frame(틀) + work(일하다)`로 어떠한 틀 안에서 일을 한다고 볼 수 있습니다.

프레임워크란 무엇일까요? 🤔

> **Framework란, 응용 프로그램이나 소프트웨어의 솔루션 개발을 수월하게 하기 위해 제공된 소프트웨어 환경입니다.**

- 상호협력하는 클래스와 인터페이스의 집합입니다.
- 응용 프로그램이 수동적으로 프레임워크에 의해 사용됩니다.
- Spring Framework, Junit, Ruby on Rails 등이 있습니다.

<br>

<h3 id='2.3'>🔗 차이점 </h3>

- API와 라이브러리의 차이점은 구현 로직의 유무
- 라이브러리와 프레임워크의 차이점은 응용 프로그램의 흐름 주도권

|          | 라이브러리                    | 프레임워크         |
| :------- | :---------------------------- | :----------------- |
| 공통점   | 재사용과 관련이 있다.         |
| 목적     | 설계 재사용(일부 코드 재사용) | 코드 재사용        |
| 제어흐름 | 프레임워크 -> 코드            | 코드 -> 라이브러리 |
| 쓰임새   | 범용적                        | 특정 영역에서 강력 |

<br>

---

<h2 id = '10'>📌 참고 자료 </h2>

https://www.redhat.com/en/topics/api/what-are-application-programming-interfaces

https://www.youtube.com/watch?v=We8JKbNQeLo

https://www.youtube.com/watch?v=_eEZqTx5N7s&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=53

---

- 30 Date, 31 RegExp, 37 Set, Map, 41 타이머, 43 Ajax,

## Set과 Map

자바스크립트의 Object 타입은 프로퍼티 이름인 문자열과 임의의 값을 연결하는 다재다능한 데이터 구조입니다.
그리고 연결되는 값이 true처럼 고정된 값이면 그 개체는 문자열 세트나 마찬가지입니다.

자바스크립트 프로그래밍에서는 객체를 실제로 맵과 세트처럼 사용하는 일이 흔하지만
키가 문자열이어야 한다는 제약이 있고, 객체에서 일반적으로 상속하는 to String 같은 프로퍼티를 실제 맵과 세트에서 사용하는 경우는 드물기 때문에 과도하게 복잡해지기도 합니다.
ES6에서 이 문제를 해결하고자 진정한 Set와 Map 클래스를 도입했습니다.

### Set

Set은 배열과 마찬가지로 값의 집합입니다.
하지만 배열과 달리 Set은 순서가 없고 인덱스도 없으며, 중복을 허용하지 않습니다.
값은 세트의 요소이거나 요소가 아닐 뿐, 그 값이 세트에 몇 개 있는지 알 수 없습니다.

Set 객체는 `Set()` 생성자로 만듭니다.

```js
let s = new Set();
let t = new Set([1, s]);

let t = new Set(s);
let unique = new Set("Mississippi"); // 'M', 'i', 's', 'p'
unique.size; // 4
```

`Set()`생성자의 인자로는 배열과 Set 객체를 포함한 이터러블 객체 모두 허용됩니다.
Set의 size 프로퍼티는 배열의 length 프로퍼티와 마찬가지로 Set에 포함된 값의 개수를 반환합니다.

Set을 생성하면서 동시에 초기화할 필요는 없습니다.
언제든 `add(), deleare(), clear()`로 요소를 추가하거나 제거할 수 있습니다.
Set은 중복을 허용하지 않으므로 이미 Set에 존재하는 값을 추가해도 아무 효과가 없습니다.

```js
let s = new Set();
s.add(1); // 1
console.log(s);
s.add(1); // 1
console.log(s);
s.add([1]);
console.log(s);
```

`add()`메서드는 인자를 하나 받습니다.
배열을 전달하면 개별 배열 요소가 아니라 배열 자체를 추가합니다.
`add()`는 항상 자신을 호출한 Set를 반환하므로 Set에 여러 가지 값을 추가할 때는 `s.add('a').add('b').add('c')`처럼 메서드를 체인으로 연결할 수 있습니다.

```js
let s = new Set("abc");
s.delete(1); // false
s.delete("a"); // true
console.log(s); // { 'b', 'c' }
```

`delete()`메서드는 세트 요소를 한 번에 하나씩 삭제합니다. 불 값을 반환하며, 지정한 값이 실제로 세트의 요소라면 그 요소를 제거하고 true를 반환합니다.
그렇지 않다면 아무 일도 하지 않고 false를 반환합니다.

Set는 일치 여부를 판할 때 `===`연산자처럼 엄격하게 체크합니다.
Set는 숫자 1과 문자열 '1'을 별개의 값으로 간주하므로 세트 요소로 이 둘을 모두 포함할 수 있습니다.
값이 객체, 배열, 함수일 경우에도 `===`로 비교합니다.

```js
let s = new Set();
s.add([1, 2, 3]);
s.delete([1, 2, 3]); // false
```

Set의 배열을 삭제할 수 없었던 이유가 이 때문입니다. 배열을 세트에 추가한 다음 `delete()`메서드에 요소는 같지만 다른 배열을 전달해 제거하려고 시도해서 실패했습니다. 삭제에 성공하려면 정확히 같은 배열을 가리키는 참조를 전달해야 합니다.

```js
const arr = [1, 2, 3];
const s = new Set();
s.add(arr);
s.delete(arr); // true
```

현실에서 Set로 할 수 있는 가장 중요한 일은 요소를 추가하거나 제거하는 일이 아니라 지정된 값이 Set의 요소인지 체크하는 일입니다.
`has()`메서드가 바로 그 일을 담당합니다.

```js
let s = new Set([2, 3, 5, 7]);
s.has(2); // true
s.has(4); // false
s.has("3"); // false
```

Set에 광해 이해해야 할 가장 중요한 점은 Set가 요소의 존재 여부를 확인하는데 최적화 되어 있으며, Set에 요소가 얼마나 많든 has()메서드는 아주 빠르다는 점입니다.
배열의 `includes()`메서드도 요소의 존재 여부를 확인하지만 배열 크기에 따라 속도가 달리지며,
배열을 세트처럼 사용하면 실제 Set 객체에 비해 훨씬 느릴 수 있습니다.

Set 클래스는 이터러블이므로 for/of 루프로 Set의 요소를 열거할 수 있습니다. 또한, 분해 연산자 `...`를 써서 배열이나 인자 리스트로 변환할 수 있습니다.

```js
let s = new Set([2, 3, 5, 7]);

let sum = 0;
for (let p of s) {
  sum += p;
}
sum; // 17

const max = Math.max(...s); // 7
const arr = [...s]; // [2, 3, 5, 7]

let product = 1;
s.forEach((n) => (product *= n));
product; // 210
```

Set는 종종 순서 없는 집합이라고 표현되지만 자바스크립트의 Set 클래스는 그렇지 않습니다.
자바스크립트 Set는 인덱스가 없으므로 배열처럼 첫 번째 요소가 뭐지, 혹은 마지막 요소가 뭔지 알 수 없습니다.
하지만 자바스크립트 Set 클래스는 항상 요소가 삽입된 순서를 기억하고 있으며, Set를 순회할 때 항상 이 순서대로 순회합니다.
Set에 첫 번째로 삽입한 요소는 순회할 때도 첫 번째로 반환되며, 마지막에 삽입한 요소는 마지막으로 반환됩니다.

```js
const arr = [1, 2, 3];
const s = new Set([1, 2, 3]);

arr.forEach((value, index) => console.log(value, index));
/*
1 0
2 1
3 2
*/

s.forEach((value, index) => console.log(value, index));
/*
1 1
2 2
3 3
*/
```

Set 클래스는 이터러블이기도 하지만 `forEach()`메서드 또한 지원합니다.
배열의 `forEach()`메서드는 배열 인덱스를 두 번째 인자로 전달하지만 세트에는 인덱스가 없으므로 Set클래스의 `forEach()`는 첫 번째와 두번째 인자 모두에 요소 값을 전달합니다.

<br>

---

### Map 클래스

Map 객체는 키로 구성된 값 집합이며 각 키는 다시 다른 값과 연결됩니다.
어떤 면에서는 Map도 배열과 비슷하지만, 연속된 정수를 키로 사용하는 대신 임의의 값을 인덱스로 사용할 수 있습니다.
배열과 마찬가지로 Map도 아주 빠른 데이터 구조를 갖습니다.
Map의 크기와 상관없이 키와 연결된 값을 빨리 찾을 수 있습니다. (배열만큼 빠르지는 않습니다.)

새 Map을 생성할 때는 `Map()`생성자를 사용합니다.

```js
let m = new Map();
let n = new Map([
  ["one", 1],
  ["two", 2],
]);

let copy = new Map(n); // [['one', 1], ['two', 2]]
let obj = { x: 1, y: 2 };
let p = new Map(Object.entries(obj)); // [['x', 1], ['y', 2]];
```

`Map()` 생성자의 선택 사항인 인자는 `[key, value]`배열을 전달하는 이터러블 객체여야 합니다.
따라서 Map을 생성하는 동시에 초기화하고 싶다면 원하는 키와 값을 배열의 배열 형태로 준비해야 합니다.
하지만 다음과 같이 `Map()` 생성자로 다른 Map을복사하거나 기존 객체의 프로퍼티 이름과 값을 복사할 수 있습니다.

Map 객체를 만들면 `get()`으로 주어진 키와 연결된 값을 검색할 수 있고, `set()`으로 키-값 쌍을 추가할 수 있습니다.
하지만 Map은 키의 집합이며 각 키가 값과 연결될 뿐, 키-값 쌍 집합이 아닙니다.
Map에 이미 존재하는 키로 `set()`을 호출하면 해당 키에 연결된 값을 수정할 뿐, 새 키-값 쌍을 맵에 추가하는 것은 아닙니다.
Map 클래스는 `get()`과 `set()` 외에도 Set과 비슷한 메서드를 가집니다.
지정된 키가 맵에 존재하는지 확인할 때는 `has()`를,
키를 제거하고 연결된 값도 제거할 때는 `delete()`를,
맵에서 키-값 쌍을 모두 제거할 때는 `clear()`를,
맵에 포함된 키의 개수를 확인할 때는 `size` 프로퍼티를 사용합니다.

```js
let m = new Map().set("one", 1).set("two", 2).set("three", 3);
m.size; // 3
m.get("two"); // 2
```

세트의 `add()`메서드와 마찬가지로 맵의 `set()`메서드 역시 체인으로 연결할 수 있으므로,
맵을 초기화할 때 배열의 배열을 사용하지 않아도 됩니다.

세트와 마찬기로 자바스크립트 값이라면 어떤 것이든 맵의 키나 값으로 사용할 수 있습니다.
`null, undefined, NaN`, 객체와 배열같은 참조 타입도 가능합니다.

또한 Set 클래스와 마찬가지로 맵도 키를 비교할 때 동등성이 아니라 일치성으로 비교하므로 객체나 배열을 키로 사용한다면 그 프로퍼티와 요소가 정확히 일치하더라도 항상 다른 것으로 판단합니다.

```js
let m = new Map([
  ["x", 1],
  ["y", 2],
]);
[...m]; // [['x', 1], ['y', 2]]

for (let [key, value] of m) {
  console.log(key, value);
}

/*
x 1
y 2
*/

[...m.keys()]; // ['x', 'y']
[...m.values()]; // [1, 2]
[...m.entries()]; // [['x', 1], ['y', 2]]

m.forEach((value, key) => {
  console.log(value, key);
});

/*
1 'x'
2 'y'
*/
```

Map 객체는 이터러블이며 순회할 때 반환되는 값은, 첫 번째 요소는 키이고 두번째 요소는 값인 배열입니다.
Map 객체에 분해 연산자를 사용하면 `Map()`생성자에 전달했을 배열의 배열을 반환합니다.
for/of 루프로 맵을 순회할 때는 다음과 같이 분해 할당을 써서 키와 값을 별도의 변수에 할당하는 것이 일반적입니다.

Set 클래스와 마찬가지로 Map 클래스 역시 삽입된 순서대로 순회합니다.
맵에 처음으로 추가한 키-값 쌍이 순회할 때도 첫 번째로 반환되며, 마지막으로 추가한 키-값 쌍이 순회할 때도 마지막으로 반환됩니다.

맵의 키나 값 중 하나만 순회하고 싶을 때는 `keys()`와 `values()`메서드를 사용하면 됩니다.
이들은 키나 값을 삽입 순서대로 순회하는 이터러블 객체를 반환합니다.
`entries()`메서드가 키-값 쌍으로 이루어진 이터러블 객체를 반환하긴 하지만 맵을 직접 순회하는 것과 차이가 없습니다.

Map객체는 Array 클래스의 forEach() 메서드도 지원합니다.

for/of에서는 키가 앞에 있으므로 위 예제에서 값 매개변수가 키 매개변수보다 앞에 있는 것이 이상해 보일 수 있습니다.
맵은 정수인 배열 인덱스를 임의의 키 값으로 대체한 일반화된 배열이라고 볼 수 있습니다.
배열의 `forEach()`메서드는 배열 요소 다음에 배열 인덱스를 전달하므로, 맵의 `forEach()`메서드는 이에 맞게 맵의 값을 먼저 전달하고, 그 다음에 맵의 키를 전달합니다.

<br>

---

### WeakMap과 WeakSet

WeakMap 클래스는 Map 클래스의 변형이지만 서브클래스는 아닙니다.
이 클래스는 키 값이 가비지 컬렉션에 포함되지 않게 막아 주지 않습니다.
가비지 컬렉션은 자바스크립트 인터프리터가 프로그램에서 더는 접근하거나 사용할 수 없는 객체가 사용하던 메모리를 회수하는 작업입니다.

일반적인 맵은 키 값을 강하게 참조하며 키 값에 대한 다른 참조가 더 이상 남아 있지 않더라도 참조 관계를 유지합니다.
반면 WeakMap은 키 값을 약하게 참조하므로 WeakMap을 통해 해당 키 값을 참조할 수 없고, 키 값이 WeakMap에 존재하더라도 메모리를 회수할 수 있습니다.

`WeakMap()`생성자는 `Map()` 생성자와 비슷하지만 WeakMap과 Map 사이에는 중요한 차이가 있습니다.

- WeakMap의 키는 반드시 객체 또는 배열이어야 합니다.
- 기본 값은 가비지 컬렉션 대상이 되지 않으며 키로 사용할 수 없습니다.

- WeakMap에는 `get(), set(), has(), delete()`메서드만 있습니다.
  특히 WeakMap은 이터러블이 아니며 `keys(), values(), forEach()`메서드가 없습니다.
  WeakMap이 이터러블이었다면 키에 접근할 수 있게 되므로 약한 참조가 성립할 수 없습니다.

- WeakMap에는 size 프로퍼티가 없습니다. WeakMap의 크기는 가비지 컬렉션이 일어날 때마다 언제든 바뀔 수 있기 때문입니다.

WeakMap의 설계 의도는 메모리 누수를 방지하면서 객체와 값을 연결할 수 있게 하는 겁니다.
Map 객체를 통해 캐시를 구현한다면 객체에서 사용하는 메모리를 회수할 가능성이 전혀 없지만, WeakMap을 사용하면 그런 문제가 생기지 않습니다.

WeakSet는 객체가 가비지 컬렉션에 포함되도록 허용하는 객체 세트입니다.

- WeakSet는 기본 값을 요소로 허용하지 않습니다.
- WeakSet는 오직 `add(), has(), delete()`메서드만 가지며 이터러블이 아닙니다.
- WeakSet에는 size 프로퍼티가 없습니다.

WeakSet는 자주 사용되지는 않으며 용도는 WeakMap과 비슷합니다.
예를 들어 객체에 특별한 프로퍼티나 타입이 있다고 분류하고 싶다면 WeakSet에 추가하는 방법이 있습니다.
그리고 다른 코드에서 그 프로퍼티나 타입을 체크할 때 WeakSet의 요소인지 확인하면 됩니다.
일반적인 세트로 이런 일을 하면 마크된 객체는 모두 가비지 컬렉션 대상이 되지 않지만, WeakSet를 사용하면 그런 걱정이 필요 없습니다.

<br>

---

### 정규표현식과 패턴 매칭

정규 표현식은 텍스트 패턴을 정의하는 객체입니다.
자바스크립트의 RegExp 클래스는 정규 표현식이며 문자열과 RegExp 모두 정규 표현식을 사용해 텍스트에서 패턴을 찾고 대체하는 메서드를 정의합니다.
하지만 RegExp API를 효율적으로 사용하려면 정규 표현식 문법을 사용해 텍스트 패턴을 만는는 법도 알아야 하는데, 정규 표현식은 그 자체로 하나의 작은 프로그래밍 언어입니다.

### 정규표현식 정의

자바스크립트에서는 RegExp 객체로 정규 표현식을 표현합니다.
물론 `RegExp()`생성자로도 RegExp 객체를 생성할 수 있지만, 보통은 특별한 리터럴 문법을 더 자주 사용합니다.
문자열 리터럴이 따옴표 안에 문자를 쓰는 것과 마찬가지로 정규 표현식 리터럴은 슬래시 (/) 한 쌍 안에 문자를 씁니다.

```js
let pattern = /s$/;

let pattern = new RegExp("s$");
```

위 행은 RegExp 객체를 생성하고 이를 변수 pattern에 할당합니다.
이 RegExp 객체는 s로 끝나는 문자열 전체에 일치합니다.
이 정규 표현식은 다음과 같이 `RegExp()` 생성자로도 정의할 수 있습니다.

<br>

---

정규표현식을 왜 학습해야 하는가?

만약 비밀번호의 조건을 설정해야 되는 상황이 주어졌다고 가정해봅시다.

- 8자 이상, 16자 이하
- 숫자, 문자, 특수문자가 모두 포함되어 있어야 합니다.

```js
const isValidLength = (str) => {
  str.length >= 8 && str.length <= 16
}

const isIncludeNum = (str) => {
  str.some((character) => character >= '0' && character <= '9';)
}

...
```

보통은 이런식으로 함수형으로 분리해서 작성을 하지만, 만약 조건이 점점 늘어날수록 코드가 길어지고 복잡해지는 문제를 맞이합니다.

정규표현식의 사용법을 알고있다면, 같은 조건이 주어졌을 때 이 조건이 복잡하다고 판단한다면 자연스레 정규식을 작성할 것 입니다.

보통 정규식 작성보단 구글링에 의존하게 되는데, 애플리케이션의 특성상 조건이 늘어나게 된다면 이 또한 한계를 맞이하게 됩니다.

정규표현식은 패스워드 유효성 뿐 만아니라, URL 제거, 주석 제거, 특정 단어 치환등 많은 상황에서 유용하게 사용될 수 있습니다.
때문에 정규표현식을 활용한다면 보다 더 편리하게 문자열을 다룰 수 있을 것입니다.

- 정규표현식의 기본 문법
- 정규표현식 활용 예시
- 자바스크립트에서의 정규표현식 활용

짧고 굵게 정규표현식에서 기본적으로 많이 사용되는 문법 위주로 살펴봅시다.

우선 문자에 대한 문법입니다.
기본적으로 JS 내에서는 슬래쉬(/) 안에 해당 정규표현식 패턴을 삽입하면 정규 표현식이 선언됩니다.

```js
/ABC/
/\d/
/\D/
/\w/
/\W/
/\s/
/\b/
```

백슬래쉬(`\`) 소문자 d를 사용하면 숫자만을 Selecting 할 수 있습니다.
반대로 백슬래쉬(`\`)대문자 D를 사용하면 문자만을 Selecting 할 수 있습니다.
w 키워드는 word의 약자로, 문자를 나타날 때 사용합니다. (대문자, 소문자, `_`(언더스코어)까지 포함합니다.)
대문자 W는 word가 아닌 것들을 나타냅니다.

`\s`키워드는 tab과 space 등 공백을 나타냅니다.
`\b`키워드도 위와 유사하지만, boundary의 약자로 위치(경계)를 나타냅니다.
(`^`문장의 시작, `$`문장의 끝 처럼 위치를 나타냅니다.)
`\s`키워드는 공백을 Selecting하는 반면, `\b`키워드는 Selecting에 포함되지 않습니다.

다음은 문자의 수를 제한할 수 있는 수량자에 대한 기본 문법입니다.

```js
/a{n,m}/ //a가 n번이상 m번 이하 반복됨을 뜻합니다.
/a?/
/a+/
/a*/
```

기본적으로 문자 뒤에 중괄호를 사용하게 되면 문자의 수를 표현할 수 있습니다.
중괄호 앞의 문자열이 첫번째 숫자 이상, 2번째 숫자 이하 반복됨을 나타냅니다.

`?`키워드는 `{0,1}`과 동일합니다. 앞에 있는 문자열이 없거나, 1개 임을 표현할 수 있습니다.
`+`키워드는 해당 문자열이 1번 이상 반복됨을 뜻합니다. `{1,}`과 동일합니다.
`*`키워드는 `?`와 `+`를 합친 키워드라고 볼 수 있습니다. 앞에 문자가 0번 이상 반복됨을 뜻하는 키워드 입니다.
`{0,}`와 동일합니다.

```js
/\b(\d{2})-(?:\d{4})-(?<lastNumber>\d{4})\b/g;

console.log(
  "01-2222-3333".match(/\b(\d{2})-(?:\d{4})-(?<lastNumber>\d{4})\b/).groups
    .lastNumber
); // 3333
```

정규표현식에서는 Group이라는 기능을 소괄호`()`를 통해서 사용할 수 있습니다.
기본적으로 소괄호로 문자열을 감싸면 해당 그룹을 캡처링 할 수 있습니다.
캡처링 된 그룹들은 `match`나 `exec`메서드를 통해 확인할 수 있습니다.

캡처링을 원하지 않고 그룹핑만을 원한다면, `(?:)`을 사용하여 캡처링에서 제외되고, 다음 인덱스부터 이어서 캡처링을 진행하게 됩니다.
이러한 그룹핑에서도 이름을 붙일 수 있는데 `(?<groupName>)`을 사용하면 그룹의 이름을 지정할 수 있습니다.
match나 exec의 groups 프로퍼티에서 해당 name으로 접근이 가능합니다.

```js
/\d{2}(?=-\d{2})/g; // - 앞의 2자리 숫자를 셀렉팅하는 표현식
```

그룹핑과 많이 혼동하는게 `(?=)`키워드 입니다.
해당 키워드는 전방 탐색 키워드로 일치 영역을 발견해도 그 값을 반환하지 않습니다.

### 정규표현식 활용 예시

정규표현식을 사용해서 휴대폰 번호의 조건을 설정해봅시다.
먼저, 요구사항을 작성합니다.

- 첫 세글자는 01x(x는 숫자)의 형태입니다.
- 구분자는 -, 공백, /을 허용합니다.
- 두번째 구역은 3글자 이상 4글자 이하, 마지막 구역은 4글자의 숫자로 이루어집니다.

```js
/^01\d[-\s/]\d{3,4}[-\s/]\d{4}$/;
```

일단 첫번째 조건을 만족시키기 위해 시작을 나타내는 `^`캐럿과 함께 작성합니다.
01과 함께 숫자를 나타내는 `\d`키워드를 사용해줍니다.

2번째 조건인 구분자는 -, 공백, `/`를 허용해주기로 하였으므로, `[]`을 통해 연산자를 대체해주고, -와 공백을 표현하는 `\s`키워드, `/`로 표현해줍니다.

마지막 조건을 만족시켜주기 위해선, 두번째 구역은 3글자 이상 4글자 이하, 마지막 구역은 4글자 이하로 표현해야 하므로,
숫자를 나타내는 형식은 `\d`키워드와 함께 `{}`로 표현해줍니다.

이렇게 작성을 완료한 테스트가 항상 옳을 수는 없습니다.
때문에 테스트는 필수적입니다. `https://regexr.com` 사이트를 이용하면 여러가지 테스트 케이스를 작성하면서 오류가 있는지 확인할 수 있습니다.

이와 같은 방식을 사용한다면, 휴대폰 번호의 조건 뿐만이 아니라, 이메일, 주민등록번호와 같은 복잡한 정규식도 생각보다 손쉽게 작성할 수 있습니다.

```js
// 이메일 조건
/^(?=[^_])+[￦w-.]+@[a-zA-Z0-9]+￦.[a-zA-Z0-9]+$/;

// 주민등록번호
/^[\d]{2}(?:(?:0[13578]|1[02])(?:[0-2]\d|3[01])|(?:02(?:[01]\d|2[0-9]))|(?:0[469]|11)(?:[0-2]\d|30))[-/.][1-4]\d{6}$/;
```

### 자바스크립트에서의 정규표현식 활용

`/RegExp/flags`

정규표현식은 기본적으로 슬래쉬안에 패턴을 삽입하고, flags를 옵션으로 삽입할 수 있습니다.

- g: global의 약자, 전 구역을 복수로 검사합니다.
- i: ignore의 약자, 대소문자를 구분하지 않습니다.
- m: multiline의 약자, 다중행 검사를 합니다.

다음은 JS에서 정규표현식을 활용하는 메서드들 입니다.

- `String.prototype.match()` : 정규식과 겹치는 전체 문자열을 첫번째 요소로 포함하는 Array를 반환한 다음 괄호 안에 캡처된 결과를 리턴합니다.

```js
"I am Super Man 12345".match(/\d/); // ['1', index: 15, input: 'I am Super Man 12345', groups: undefined]
"I am Super Man 12345".match(/\d/g); // ['1', '2', '3', '4', '5']
```

match와 group 네이밍을 활용해서 다음과 같이 주민번호에서 생년월일을 손쉽게 추출 해낼 수 있습니다.

```js
const { year, month, date } = "970201-1111111".match(
  /^(?<year>\d{2})(?<month>\d{2})(?<date>\d{2})/
).groups;
console.log(year, "년", month, "월", date, "일생"); // 97 년 02 월 01 일생
```

다음은 유효성 검사에서 가장 많이 사용하는 `test()`메서드입니다.

- `RegExp.prototype.test()` : 주어진 문자열이 정규표현식을 만족하는지를 Boolean으로 반환해줍니다.

```js
/^01[\d][-\s/]\d{3,4}[-\s/]\d{4}$/.test("010-1111-2222"); // true
/^01[\d][-\s/]\d{3,4}[-\s/]\d{4}$/.test("010-1111-222"); // false
```

앞서 작성했던 휴대폰 번호의 조건을 활용하여 해당 문자열이 조건을 만족하는지 확인할 수 있습니다.

- `String.prototype.replace()`: 패턴에 일치하는 문자열의 일부 또는 모든 부분을 교체한 문자열을 반환합니다.

```js
const reg = /(-\d)(\d*)/
'980828-2345'.replace(reg, '*'); // '980828*' 뒷 번호를 *으로 변환

String.replace(reg, function(match, p1, p2, ..., offset, string) {
  return ...;
})

'980828-2345'.replace(reg, (match, p1, p2,) => p1 + ('*'.repeat(p2.length))); // '980828-2***'
```

replace의 두번째 인자로 함수를 넣을 수 있습니다.
replace의 첫번째 인자로는 정규식을 담은 후 두번째 인자로 함수를 넣으면, 함수의 파라미터로 4가지 종류의 인자를 받을 수 있습니다.

- match : 매치된 문자열
- p1, p2, ... : 그룹화된 문자열 순서대로 인자로 받을 수 있습니다.
- offset: 매치된 문자열의 index
- string: 조사된 전체 문자열

위의 예시와 같이 찾은 문자열에 따라 동적으로 변환을 원할때 유용하게 사용할 수 있습니다.

그렇다면, 이렇게 유용해보이는 정규표현식이 항상 좋을까요?
당연히 그것은 아닙니다.

정규표현식 엔진은 대부분 백트래킹을 사용하기 때문에, 최악의 경우 시간복잡도를 O(2^n)이 나오게 됩니다.
따라서 일반 내장 메서드나 for문보다 크진 않지만 성능상 떨어질 수 있습니다.
또 좋지 않은 가독성이 정규 표현식의 가장 큰 단점입니다.
기본적으로 정규표현식은 가독성이 좋지 않습니다. 일반적으로 사용되는 문자열이 아닌 meta문자열을 사용하기 때문에 기본적으로 가독성이 떨어질 수 밖에 없습니다.

따라서 간단한 로직은 내장 메서드를 활용해서 함수 분리를 하는 것이 성능이나 가독성면에서 더 좋고,
복잡하고 복합적인 로직을 검사하고 싶을때는 정규표현식이 유용하게 사용됩니다.
