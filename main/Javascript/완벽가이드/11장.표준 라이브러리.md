![](https://velog.velcdn.com/images/ninto_2/post/13375636-578d-493e-a046-4b42b868a4d3/image.png)

<h2 id = '1'>📌 목차 </h2>

- 🌱 **API와 Library, Framework**
  - **API**
  - **Library**
  - **Framework**

<br>

- 🌱 **Set과 Map**
  - **Set**
  - **Map**

<br>

- 🌱 **RegExp과 Ajax**
  - **정규 표현식과 패턴 매칭**
  - **JSON 직렬화와 분석**

<br>

- 🌱 **Date와 타이머**
  - **날짜와 시간**
  - **타이머**

<br>

- 🌱 **API**
  - **콘솔 API**
  - **URL API**
  - **국제화 API**
  - **Error 클래스**

<br>

- 🌱 **형식화 배열과 이진 데이터**

<br>

---

<h2 id='2'>📌 API와 라이브러리, 프레임워크 </h2>

![](https://velog.velcdn.com/images/ninto_2/post/9e7acf59-e4b1-4205-b9b8-0692af768ff1/image.png)

프로그래밍 언어를 배우는 것은 문법을 마스터한다고 끝나는 일이 아닙니다.
언어에 포함된 도구 전체에 익숙해질 수 있도록 **표준 라이브러리**를 공부하는 것도 마찬가지로 중요합니다.

그렇다면, 기본적으로 먼저 API와 라이브러리 그리고 프레임워크의 개념에 대해 살펴보고,
**자바스크립트의 표준 라이브러리**와 자주 사용되는 **API**에 대해 알아보는 것이 필요합니다.

<h3 id='2.1'>🔗 API </h3>

API란 무엇일까요? 🤔

> **API (Application Programming Interface)란, 응용 프로그램에서 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스입니다.**

![](https://velog.velcdn.com/images/ninto_2/post/9d5c21a2-b03f-4374-a6d0-0f55c380a4e6/image.png)

조금 더 쉽게 말하자면, 프로그램 사이의 연결을 시켜주는 다리라고 생각할 수 있습니다.

- 구현과 독립적으로 사양만 정의되어 있습니다.
- API에 따라서 접근 권한이 필요할 수 있습니다.
- 예시로 Java API, 여러 기업들의 오픈 API가 있습니다.

<br>

<h3 id='2.2'>🔗 Library </h3>

![](https://velog.velcdn.com/images/ninto_2/post/9110c88d-1a76-4ef6-87b0-41d274455281/image.png)

단어적으로만 보았을 때, Library는 도서관을 떠올리기 쉽습니다. 책들을 카테고리별로 모아놓은 것이 책장이라면, 도서관은 그런 책장들이 굉장히 많이 있는 것을 생각할 수 있습니다.

라이브러리란 무엇일까요? 🤔

> **Library란, 응용 프로그램 개발을 위해 필요한 기능(함수)을 모아 놓은 소프트웨어입니다.**

- 독립성을 가집니다. (해당 라이브러리는 다른 라이브러리를 의존하지 않는걸 의미합니다.)
- 응용 프로그램이 능동적으로 라이브러리를 사용합니다.
- Apache Commons, Guava, Lombok, jQuery 등이 있습니다.

<br>

<h3 id='2.2'>🔗 Framework </h3>

단어적으로만 보았을 때, `Frame(틀) + work(일하다)`로 어떠한 틀 안에서 일을 한다고 볼 수 있습니다.

프레임워크란 무엇일까요? 🤔

> **Framework란, 응용 프로그램이나 소프트웨어의 솔루션 개발을 수월하게 하기 위해 제공된 소프트웨어 환경입니다.**

- 상호협력하는 클래스와 인터페이스의 집합입니다.
- 응용 프로그램이 수동적으로 프레임워크에 의해 사용됩니다.
- Spring Framework, Junit, Ruby on Rails 등이 있습니다.

<br>

<h3 id='2.3'>🔗 차이점 </h3>

- API와 라이브러리의 차이점은 구현 로직의 유무
- 라이브러리와 프레임워크의 차이점은 응용 프로그램의 흐름 주도권

|          | 라이브러리                    | 프레임워크         |
| :------- | :---------------------------- | :----------------- |
| 공통점   | 재사용과 관련이 있다.         |
| 목적     | 설계 재사용(일부 코드 재사용) | 코드 재사용        |
| 제어흐름 | 프레임워크 -> 코드            | 코드 -> 라이브러리 |
| 쓰임새   | 범용적                        | 특정 영역에서 강력 |

<br>

---

<h2 id = '10'>📌 참고 자료 </h2>

https://www.redhat.com/en/topics/api/what-are-application-programming-interfaces

https://www.youtube.com/watch?v=We8JKbNQeLo

---

- 30 Date, 31 RegExp, 37 Set, Map, 41 타이머, 43 Ajax,

## Set과 Map

자바스크립트의 Object 타입은 프로퍼티 이름인 문자열과 임의의 값을 연결하는 다재다능한 데이터 구조입니다.
그리고 연결되는 값이 true처럼 고정된 값이면 그 개체는 문자열 세트나 마찬가지입니다.

자바스크립트 프로그래밍에서는 객체를 실제로 맵과 세트처럼 사용하는 일이 흔하지만
키가 문자열이어야 한다는 제약이 있고, 객체에서 일반적으로 상속하는 to String 같은 프로퍼티를 실제 맵과 세트에서 사용하는 경우는 드물기 때문에 과도하게 복잡해지기도 합니다.
ES6에서 이 문제를 해결하고자 진정한 Set와 Map 클래스를 도입했습니다.

### Set

Set은 배열과 마찬가지로 값의 집합입니다.
하지만 배열과 달리 Set은 순서가 없고 인덱스도 없으며, 중복을 허용하지 않습니다.
값은 세트의 요소이거나 요소가 아닐 뿐, 그 값이 세트에 몇 개 있는지 알 수 없습니다.

Set 객체는 `Set()` 생성자로 만듭니다.

```js
let s = new Set();
let t = new Set([1, s]);

let t = new Set(s);
let unique = new Set("Mississippi"); // 'M', 'i', 's', 'p'
unique.size; // 4
```

`Set()`생성자의 인자로는 배열과 Set 객체를 포함한 이터러블 객체 모두 허용됩니다.
Set의 size 프로퍼티는 배열의 length 프로퍼티와 마찬가지로 Set에 포함된 값의 개수를 반환합니다.

Set을 생성하면서 동시에 초기화할 필요는 없습니다.
언제든 `add(), deleare(), clear()`로 요소를 추가하거나 제거할 수 있습니다.
Set은 중복을 허용하지 않으므로 이미 Set에 존재하는 값을 추가해도 아무 효과가 없습니다.

```js
let s = new Set();
s.add(1); // 1
console.log(s);
s.add(1); // 1
console.log(s);
s.add([1]);
console.log(s);
```

`add()`메서드는 인자를 하나 받습니다.
배열을 전달하면 개별 배열 요소가 아니라 배열 자체를 추가합니다.
`add()`는 항상 자신을 호출한 Set를 반환하므로 Set에 여러 가지 값을 추가할 때는 `s.add('a').add('b').add('c')`처럼 메서드를 체인으로 연결할 수 있습니다.

```js
let s = new Set("abc");
s.delete(1); // false
s.delete("a"); // true
console.log(s); // { 'b', 'c' }
```

`delete()`메서드는 세트 요소를 한 번에 하나씩 삭제합니다. 불 값을 반환하며, 지정한 값이 실제로 세트의 요소라면 그 요소를 제거하고 true를 반환합니다.
그렇지 않다면 아무 일도 하지 않고 false를 반환합니다.

Set는 일치 여부를 판할 때 `===`연산자처럼 엄격하게 체크합니다.
Set는 숫자 1과 문자열 '1'을 별개의 값으로 간주하므로 세트 요소로 이 둘을 모두 포함할 수 있습니다.
값이 객체, 배열, 함수일 경우에도 `===`로 비교합니다.

```js
let s = new Set();
s.add([1, 2, 3]);
s.delete([1, 2, 3]); // false
```

Set의 배열을 삭제할 수 없었던 이유가 이 때문입니다. 배열을 세트에 추가한 다음 `delete()`메서드에 요소는 같지만 다른 배열을 전달해 제거하려고 시도해서 실패했습니다. 삭제에 성공하려면 정확히 같은 배열을 가리키는 참조를 전달해야 합니다.

```js
const arr = [1, 2, 3];
const s = new Set();
s.add(arr);
s.delete(arr); // true
```

현실에서 Set로 할 수 있는 가장 중요한 일은 요소를 추가하거나 제거하는 일이 아니라 지정된 값이 Set의 요소인지 체크하는 일입니다.
`has()`메서드가 바로 그 일을 담당합니다.

```js
let s = new Set([2, 3, 5, 7]);
s.has(2); // true
s.has(4); // false
s.has("3"); // false
```

Set에 광해 이해해야 할 가장 중요한 점은 Set가 요소의 존재 여부를 확인하는데 최적화 되어 있으며, Set에 요소가 얼마나 많든 has()메서드는 아주 빠르다는 점입니다.
배열의 `includes()`메서드도 요소의 존재 여부를 확인하지만 배열 크기에 따라 속도가 달리지며,
배열을 세트처럼 사용하면 실제 Set 객체에 비해 훨씬 느릴 수 있습니다.

Set 클래스는 이터러블이므로 for/of 루프로 Set의 요소를 열거할 수 있습니다. 또한, 분해 연산자 `...`를 써서 배열이나 인자 리스트로 변환할 수 있습니다.

```js
let s = new Set([2, 3, 5, 7]);

let sum = 0;
for (let p of s) {
  sum += p;
}
sum; // 17

const max = Math.max(...s); // 7
const arr = [...s]; // [2, 3, 5, 7]

let product = 1;
s.forEach((n) => (product *= n));
product; // 210
```

Set는 종종 순서 없는 집합이라고 표현되지만 자바스크립트의 Set 클래스는 그렇지 않습니다.
자바스크립트 Set는 인덱스가 없으므로 배열처럼 첫 번째 요소가 뭐지, 혹은 마지막 요소가 뭔지 알 수 없습니다.
하지만 자바스크립트 Set 클래스는 항상 요소가 삽입된 순서를 기억하고 있으며, Set를 순회할 때 항상 이 순서대로 순회합니다.
Set에 첫 번째로 삽입한 요소는 순회할 때도 첫 번째로 반환되며, 마지막에 삽입한 요소는 마지막으로 반환됩니다.

```js
const arr = [1, 2, 3];
const s = new Set([1, 2, 3]);

arr.forEach((value, index) => console.log(value, index));
/*
1 0
2 1
3 2
*/

s.forEach((value, index) => console.log(value, index));
/*
1 1
2 2
3 3
*/
```

Set 클래스는 이터러블이기도 하지만 `forEach()`메서드 또한 지원합니다.
배열의 `forEach()`메서드는 배열 인덱스를 두 번째 인자로 전달하지만 세트에는 인덱스가 없으므로 Set클래스의 `forEach()`는 첫 번째와 두번째 인자 모두에 요소 값을 전달합니다.

<br>

---

### Map 클래스

Map 객체는 키로 구성된 값 집합이며 각 키는 다시 다른 값과 연결됩니다.
어떤 면에서는 Map도 배열과 비슷하지만, 연속된 정수를 키로 사용하는 대신 임의의 값을 인덱스로 사용할 수 있습니다.
배열과 마찬가지로 Map도 아주 빠른 데이터 구조를 갖습니다.
Map의 크기와 상관없이 키와 연결된 값을 빨리 찾을 수 있습니다. (배열만큼 빠르지는 않습니다.)

새 Map을 생성할 때는 `Map()`생성자를 사용합니다.

```js
let m = new Map();
let n = new Map([
  ["one", 1],
  ["two", 2],
]);

let copy = new Map(n); // [['one', 1], ['two', 2]]
let obj = { x: 1, y: 2 };
let p = new Map(Object.entries(obj)); // [['x', 1], ['y', 2]];
```

`Map()` 생성자의 선택 사항인 인자는 `[key, value]`배열을 전달하는 이터러블 객체여야 합니다.
따라서 Map을 생성하는 동시에 초기화하고 싶다면 원하는 키와 값을 배열의 배열 형태로 준비해야 합니다.
하지만 다음과 같이 `Map()` 생성자로 다른 Map을복사하거나 기존 객체의 프로퍼티 이름과 값을 복사할 수 있습니다.

Map 객체를 만들면 `get()`으로 주어진 키와 연결된 값을 검색할 수 있고, `set()`으로 키-값 쌍을 추가할 수 있습니다.
하지만 Map은 키의 집합이며 각 키가 값과 연결될 뿐, 키-값 쌍 집합이 아닙니다.
Map에 이미 존재하는 키로 `set()`을 호출하면 해당 키에 연결된 값을 수정할 뿐, 새 키-값 쌍을 맵에 추가하는 것은 아닙니다.
Map 클래스는 `get()`과 `set()` 외에도 Set과 비슷한 메서드를 가집니다.
지정된 키가 맵에 존재하는지 확인할 때는 `has()`를,
키를 제거하고 연결된 값도 제거할 때는 `delete()`를,
맵에서 키-값 쌍을 모두 제거할 때는 `clear()`를,
맵에 포함된 키의 개수를 확인할 때는 `size` 프로퍼티를 사용합니다.

```js
let m = new Map().set("one", 1).set("two", 2).set("three", 3);
m.size; // 3
m.get("two"); // 2
```

세트의 `add()`메서드와 마찬가지로 맵의 `set()`메서드 역시 체인으로 연결할 수 있으므로,
맵을 초기화할 때 배열의 배열을 사용하지 않아도 됩니다.

세트와 마찬기로 자바스크립트 값이라면 어떤 것이든 맵의 키나 값으로 사용할 수 있습니다.
`null, undefined, NaN`, 객체와 배열같은 참조 타입도 가능합니다.

또한 Set 클래스와 마찬가지로 맵도 키를 비교할 때 동등성이 아니라 일치성으로 비교하므로 객체나 배열을 키로 사용한다면 그 프로퍼티와 요소가 정확히 일치하더라도 항상 다른 것으로 판단합니다.

```js
let m = new Map([
  ["x", 1],
  ["y", 2],
]);
[...m]; // [['x', 1], ['y', 2]]

for (let [key, value] of m) {
  console.log(key, value);
}

/*
x 1
y 2
*/

[...m.keys()]; // ['x', 'y']
[...m.values()]; // [1, 2]
[...m.entries()]; // [['x', 1], ['y', 2]]

m.forEach((value, key) => {
  console.log(value, key);
});

/*
1 'x'
2 'y'
*/
```

Map 객체는 이터러블이며 순회할 때 반환되는 값은, 첫 번째 요소는 키이고 두번째 요소는 값인 배열입니다.
Map 객체에 분해 연산자를 사용하면 `Map()`생성자에 전달했을 배열의 배열을 반환합니다.
for/of 루프로 맵을 순회할 때는 다음과 같이 분해 할당을 써서 키와 값을 별도의 변수에 할당하는 것이 일반적입니다.

Set 클래스와 마찬가지로 Map 클래스 역시 삽입된 순서대로 순회합니다.
맵에 처음으로 추가한 키-값 쌍이 순회할 때도 첫 번째로 반환되며, 마지막으로 추가한 키-값 쌍이 순회할 때도 마지막으로 반환됩니다.

맵의 키나 값 중 하나만 순회하고 싶을 때는 `keys()`와 `values()`메서드를 사용하면 됩니다.
이들은 키나 값을 삽입 순서대로 순회하는 이터러블 객체를 반환합니다.
`entries()`메서드가 키-값 쌍으로 이루어진 이터러블 객체를 반환하긴 하지만 맵을 직접 순회하는 것과 차이가 없습니다.

Map객체는 Array 클래스의 forEach() 메서드도 지원합니다.

for/of에서는 키가 앞에 있으므로 위 예제에서 값 매개변수가 키 매개변수보다 앞에 있는 것이 이상해 보일 수 있습니다.
맵은 정수인 배열 인덱스를 임의의 키 값으로 대체한 일반화된 배열이라고 볼 수 있습니다.
배열의 `forEach()`메서드는 배열 요소 다음에 배열 인덱스를 전달하므로, 맵의 `forEach()`메서드는 이에 맞게 맵의 값을 먼저 전달하고, 그 다음에 맵의 키를 전달합니다.
