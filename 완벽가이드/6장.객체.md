![](https://velog.velcdn.com/images/ninto_2/post/1a76d999-dfe9-4e17-9076-8001518529ab/image.png)

<h2 id='1'>📌 객체 Object </h2>

> **객체는 프로퍼티의 순서 없는 집합체이며 각 프로퍼티에는 이름(key)과 값(value)이 있다.**

**객체는 자바스크립트의 가장 기본적인 데이터 타입이며 복합된 값이다.**
`자바스크립트에선 원시타입을 제외한 모든 값을 전부 객체라고 본다.`

여기에서 말하는 복합된 값이란, 여러가지의 값(기본 값이나 다른 객체)을 모아서 **이름을 통해 값을 저장하고 가져올 수 있다는 의미이다.**

객체는 단순히 이름과 값을 연결하는 것이 아니다. 자신만의 프로퍼티를 가지는 것 외에도 `프로토타입으로 다른 객체에서 프로퍼티를 상속`하기도 한다.

**객체의 메서드는 일반적으로 상속된 프로퍼티**이며 **프로토타입 상속이 자바스크립트의 중요한 기능**이다.

만약 상속되지 않은 프로퍼티가 있다면 이를 자체 프로퍼티(own property)라고 부른다.

**객체의 프로퍼티**에는 이름과 값이 있으며, 대표적으로 세 가지의 프로퍼티 속성(쓰기, 열거, 변경 가능)이 있다.

> `※ 자바스크립트 내장 객체의 프로퍼티 중 상당수는 읽기 전용이거나, 열거&변경 불가 기능이다.`

- **프로퍼티 이름**에는 빈 문자열과 심벌을 포함해 어떤 문자열이든 사용 가능하지만, `같은 이름의 프로퍼티는 존재 할 수 없다.`
- **프로퍼티 값**은 타입을 가리지 않는 자바스크립트의 값이며, getter 나 setter 또는 둘 다가 될 수 있다.

객체는 동적(가변)이기 때문에 일반적으로 프로퍼티를 추가하거나 삭제할 수 있지만, 정적인 객체를 흉내 낼 수 있고 정적 타입을 사용하는 언어의 구조 역시 사용할 수 있다.

객체는 값이 아닌 **참조로 조작**을 한다.

```
const obj = {
	name: 'kim'
}

let a = obj;
let b = a;

b.age = 20; //변수 b를 통해 obj를 조작

console.log(a.age); // 20
console.log(obj); // {name: 'kim', age: 20}

```

객체를 수정하게 되면 같은 참조를 하고 있는 모든 대상에게 똑같은 수정 결과가 반영된다.

아래에서 조금 더 자세하게 객체의 `리터럴 문법과 생성, 검색, 설정, 삭제, 테스트, 프로퍼티 열거`에 대해 알아보고 `확장, 직렬화, 메서드 정의`에 대해 자세히 살펴보자.

<br>

---

<h3 id='2.4'>🔗 프로토타입 </h3>

**객체의 조작 방법을 알기전에 먼저 프로토타입이라는 개념을 알고있어야 한다.**

**🔗 프로토타입 프로퍼티(`__prototype__`)**
**🔗 프로토타입 접근자(`[[prototype]]`)**
**🔗 프로토타입 체이닝(= 프로토타입 체인)**
**🔗 상속**

<br>

---

<h2 id='2'>📌 객체 생성</h2>

객체를 생성할 때는 다양한 방법이 존재한다.

**🔗 객체 리터럴**

> 가장 단순한 형태로 ` { 이름 : 값 , }` 의 형태

일반적으로 객체를 생성하는 가장 쉬운 방법은 객체 리터럴을 사용하는 것이다.

```
let empty = {} // 프로퍼티가 없는 빈 객체
let point = { x: 0, y: 0 } //숫자 프로퍼티 2개
let convention = { a: null, }
```

객체 리터럴의 마지막 프로퍼티 뒤에 콤마를 추가하게 되면 나중에 프로퍼티를 추가할 때 문법 에러를 초래할 가능성이 줄어든다.

반복적으로 호출되는 함수나 루프안에 객체 리터럴을 사용하면 새로운 객체를 여러개 만들 수 도 있다.

객체 안에 이름과 값을 변수로 설정해서 외부에서 변에 값을 할당해주어도 해당 객체의 프로퍼티를 추가할 수 있다.
`객체안에서 키를 변수로 받아올땐 bracket을 사용한다.`

```
const key = 'name';
const value = 'kim';

const obj = {
	[key] : value,
}

console.log(obj); // {name: 'kim'}
```

**🔗 new**

> new 연산자는 새 객체를 생성하고 초기화하며, 반드시 뒤에 함수호출이 있어야 한다.

```
// 자바스크립트의 내장 생성자 함수
new Object();
new Array();
new Date();
new Map();

```

이런 형태로 사용하는 함수를 생성자라고 부르며, 새로 생성된 객체를 초기화하는 목적으로 사용한다.

**생성자 함수를 통해서 생성한 객체는 자신을 생성한 생성자 함수의 프로토타입 프로퍼티(`__prototype__`)를 프로토타입으로 갖는다.**

**🔗 Object.creat()**

`Object.creat()`은 첫번째 인자를 프로토타입 삼아 새 객체를 생성한다.

```
let o1 = Object.creat({ x: 1, y: 2}) //o1은 x와 y를 상속한다.
o1.x + o1.y // 3
```

만약 인자로 null을 전달하게 된다면 기본적인 메서드 조차 없다.
객체리터럴이나 new Object()가 반환하는 것 처럼 일반적인 빈 객체를 만들고 싶다면 Object.prototype을 전달해야 한다.

```
let obj = Object.create(Object.prototype); // obj는 {}나 new Object()와 같다.
```

`Object.creat()`을 사용하는 목적 중 하나는 객체를 변경하는 사고를 막는 것이다. 부주의하게 객체의 값을 바꾸더라도 원래 객체에는 아무 영향이 없다.

**🔗 객체 직렬화**

객체 직렬화(serialize)는 객체를 문자열로 변환하는 작업이다.
이 문자열은 나중에 다시 객체로 되돌릴 수 있으며 객체를 문자열로 만들때는 `JSON.stringify()`를 사용하고 되돌릴때에는
`JSON.parse()`를 사용한다.

- JSON은 자바스크립트 객체 표기법의 약어이며 문법은 자바스크립트의 객체와 배열 리터럴과 아주 비슷하다.
- JSON문법은 자바스크립트 문법의 부분 집합이며 자바스크립트 값 전체를 표현하지는 못한다.

<br>

---

<h2 id='9'>📌 객체 메서드</h2>

명시적으로 프로토타입 없이 생성한 객체를 제외하면 자바스크립트 객체는 모두 `Object.prototype`에서 프로퍼티를 상속한다.

**🔗 toString()메서드**

이 메서드에는 인자가 없다. 호출한 객체의 값을 나타내는 문자열로 반환하는 특징을 가지고 있다.

```
let obj = { x: 1, y: 2 }.toString();
obj; // '[object Object]'
```

기본 메서드에서 유용한 정보를 제공하지 않으므로 여러 클래스에서 자신만의 toString을 정의하곤 한다.

- 배열에선 배열 요소 각각을 문자열로 변환한 리스트를 얻고, 함수를 문자열로 변환하면 소스 코드를 얻는다.

**🔗 toLocaleString()메서드**

이 메서드의 목적은 지역에 맞는 문자열 표현을 반환하는 것이다.
하지만 Object에 정의된 기본 toLocaleString() 메서드 자체에는 지역화 기능이 전혀 없고, 그저 toString()을 호출해 그 값을 반환하기만 한다.
Date와 숫자 클래스에는 숫자, 날짜, 시간을 지역의 관습에 맞게 표현하는 toLocaleString()이 있다.
배열의 toLocaleString()는 toString()과 거의 비슷하지만 배열 요소를 변환할때 toLocaleString()를 호출한다는 점이 다르다.

**🔗 valueOf()메서드**

이 메서드는 객체를 문자열이 아닌 다른 기본 타입, 보통은 숫자로 변환하려 할 때 호출한다.
ex. Date 클래스에서의 valueOf()는 날짜를 숫자로 변환한다.
자바스크립트는 기본 값을 예상하는 곳에 객체를 사용하면 자동으로 이 메서드를 호출한다.
point 객체로도 비슷한 일을 수행할 수 있다.

**🔗 toJSON()메서드**

Object.prototype에 실제로 toJSON() 메서드가 정의된 것은 아니지만, JSON.stringify() 메서드는 직렬화할 객체에서
toJSON()메서드를 검색한다. 직렬화할 객체에 이런 메서드가 존재하면 해당 메서드를 호출해 반환 값을 직렬화 한다.

<br>

---

<h2 id='10'>📌 확장된 객체 리터럴 문법</h2>

자바스크립트 최근 버전에서는 객체 리터럴 문법을 여러 가지 방법으로 확장했다.

**🔗 단축 프로퍼티**

ES6 이후에는 아래와 같이 콜론을 생략한 훨씬 간결한 문법을 사용할 수 있다.

```
let num1 = 1, num2 = 2;
let obj = { num1, num2 };
obj.num1 + obj.num2 // 3
```

**🔗 계산된 프로퍼티 이름**

계산된 프로퍼티라는 기능은 말그대로 객체에 사용되어야하는 프로퍼티 이름이 변수에 저장되어 있거나 함수의 반환 값일 경우를 의미한다.
이때에는 객체의 프로퍼티 이름을 대괄호를 사용하여 객체 리터럴 안에 사용하면 해결할 수 있다.

```
const PROPERTY_NAME = 'p1';
function computePropertyName() { return 'p' + 2 };
const p = {
  [PROPERTY_NAME]: 1,
  [computePropertyName()]: 2,
}
p.p1 + p.p2 // 3
```

표현식을 평가한 값을 프로퍼티 이름으로 사용하며, 필요하다면 문자열로 변환한다.
프로퍼티 이름을 직접 쓰기보단 계산된 프로퍼티 문법을 사용하여 프로퍼티 이름 상수를 쓰는 편이 더 안전하다.

**🔗 프로퍼티 이름인 심벌**

ES6이후에는 프로퍼티 이름에 문자열이나 심벌을 사용할 수 있게 되었다.
심벌을 변수나 상수에 할당하면 계산된 프로퍼티 문법을 통해 해당 심벌을 프로퍼티 이름으로 사용할 수 있게 된다.

```
const age = Symbol('age');
const obj = {
  [age] : 20
}
obj // {Symbol(age): 20}
obj.age // undefined
obj[age] // 20
```

심벌을 사용하는 목적은 자바스크립트 객체가 사용할 수 있는 안전한 확장 메커니즘을 정의하는 것이다.
고유한 프로퍼티 이름을 만들때 안성맞춤이다.

**🔗 분해 연산자**

ES2018 이후 객체 리터럴 안에서 분해 연산자`...`를 사용해 기존 객체의 프로퍼티를 새 객체에 복사할 수 있게 되었다.

```
let dimensions = { width: 100, heigth: 75 };
let rect = { ...dimenstions };
rect.width + rect.heigth // 175
```

이런식으로 객체를 다른 객체에 분산하는 용도로 사용하는 것은 객체 리터럴이 유일하다.
분해되는 객체와 프로퍼티를 받는 객체 둘 다 같은 이름의 프로퍼티를 갖는다면 해당 프로퍼티의 값은 마지막에 오는 값이 된다.

분해 연산자는 자체 프로퍼티만 분해할 뿐 상속된 프로퍼티에는 적용되지 않는다.

분해 연산자를 루프나 재귀함수에 넣어 데이터를 큰 객체 하나에 누산한다면 비효율적인 알고리즘을 사용하게 된 다는 점을 주의해야한다.

**🔗 단축 메서드**

객체 안에 메서드를 정의할 때 function 키워드와 콜론을 생략할 수 있다.

```
let square = {
  area() { return this.side * this.side },
  side: 10,
};
square.area() // 100
```

객체 프로퍼티로 정의된 함수를 메서드라고 부른다.
단축 문법을 사용해 메서드를 작성할 때 프로퍼티 이름에는 객체 리터럴 안에 쓸 수 있다면 무엇이든 쓸 수 있게된다.
일반적인 자바스크립트 식별자 외에도 문자열 리터럴, 계산된 프로퍼티 이름, 심벌 역시 사용가능하다.
메서드 이름을 심벌로 사용하게 될 때에는 반드시 심벌 이름 `Symbol.iterator`를 사용해 메서드를 정의해야한다.

**🔗 프로퍼티 게터와 세터**

객체 프로퍼티 대부분은 이름과 값이 있는 데이터 프로퍼티이다.
자바스크립트는 접근자 메서드 게터(getter)와 세터(setter)를 갖는 접근자 프로퍼티 역시 지원한다.

프로그램이 접근자 프로퍼티의 값을 검색하면 자바스크립트는 인자 없이 게터 메서드를 호출한다.
이 메서드의 반환 값이 바로 프로퍼티 접근 표현식의 값이다.

프로그램에서 접근자 프로퍼티의 값을 설정하려 하면 자바스크립트는 세터 메서드를 호출하고, 할당 표현식의 오른쪽 값을
인자로 전달한다.

이 메서드가 프로퍼티 값 세팅을 담당하는 것이다.(세터 메서드의 반환 값은 무시)

- 프로퍼티에 게터와 세터 메서드가 모두 있으면 해당 프로퍼티는 읽기와 쓰기가 모두 가능한 프로퍼티이다.
- 게터 메서드 하나만 있다면 읽기 전용 프로퍼티이다.
- 세터 메서드 하나만 있다면 쓰기 전용 프로퍼티이다.(데이터 프로퍼티에는 불가능)
  - 값을 읽으려 하면 항상 undefined로 평가된다.

접근자 프로퍼티는 객체리터럴 문법의 확장으로 정의할 수 있다.
`다른 ES6 확장과 달리, 게터와 세터는 ES5에서 도입되었다.`

접근자 프로퍼티는 한 개 혹은 두 개의 메서드 형태로 정의되며, 그 이름은 프로퍼티 이름과 같다.
앞에 get과 set을 붙인다는 것 외에는 ES6 단축 문법으로 정의된 일반적인 메서드와 별로 다르지 않다.
